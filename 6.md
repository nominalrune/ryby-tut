[第6章ユーザーのモデルを作成する](/chapters/modeling_users?version=5.1#cha-modeling_users)
===========================================================================

[第5章](/chapters/filling_in_the_layout?version=5.1#cha-filling_in_the_layout)では、新しいユーザーを作成するためのスタブページを作ったところで終わりました ([5.4](/chapters/filling_in_the_layout?version=5.1#sec-user_signup))。これから6つの章を通して、ユーザー登録ページを作っていくことにしましょう。本章では、一番重要なステップであるユーザー用の_データモデル_の作成と、データを保存する手段の確保について学んでいきます。[第7章](/chapters/sign_up?version=5.1#cha-sign_up)では、ユーザーがサイトにユーザー登録できるようにし、ユーザープロフィールのためのページを作成します。ユーザー登録できるようになったら、ログインやログアウトをできる仕組みを作り ([第8章](/chapters/basic_login?version=5.1#cha-basic_login)と[第9章](/chapters/advanced_login?version=5.1#cha-advanced_login))、[第10章](/chapters/updating_and_deleting_users?version=5.1#cha-updating_showing_and_deleting_users)からは不正なアクセスを取り扱う方法について学んでいきます ([10.2.1](/chapters/updating_and_deleting_users?version=5.1#sec-requiring_logged_in_users))。最後に[第11章](/chapters/account_activation?version=5.1#cha-account_activation)と[第12章](/chapters/password_reset?version=5.1#cha-password_reset)でメールアドレスを使ってアカウントを有効化する方法と、パスワードを再設定する方法について学びます。まとめると、[第6章](/chapters/modeling_users?version=5.1#cha-modeling_users)から[第12章](/chapters/password_reset?version=5.1#cha-password_reset)を通して、Railsのログインと認証システムをひととおり開発します。ご存知の方もいると思いますが、Railsでは既にさまざまな認証方法が利用可能です。[コラム6.1](/chapters/modeling_users?version=5.1#aside-roll_your_own)では、少なくとも一度は自分で認証システムを作ってみるべき理由について説明しています。

コラム 6.1. 自分で認証システムを作ってみる

事実上、すべてのWebアプリケーションは何らかのログイン/認証システムを必要とします。そのため、多くのWebフレームワークではこのようなログイン/認証システムを実装するための選択肢が多数提供されています。Railsもまた例外ではありません。認証 (authentication) と認可 (authorization) のシステムの例だと、[Clearance](https://github.com/thoughtbot/clearance)、[Authlogic](https://github.com/binarylogic/authlogic)、[Devise](https://github.com/plataformatec/devise)、[CanCan](http://railscasts.com/episodes/192-authorization-with-cancan)などがあります (Railsに限らなければ[OpenID](https://ja.wikipedia.org/wiki/OpenID)や[OAuth](https://ja.wikipedia.org/wiki/OAuth)の上に構築する方法もあります)。なぜ車輪の再発明をするのか、という質問があるのも当然です。自分でわざわざ作らなくても、いつも使える方法をただ利用するだけではいけないのでしょうか。

ある実践的な実験によると、多くのサイトの認証システムは膨大なカスタマイズを必要とするため、サードパーティ製品を変更して導入する場合にはシステムをゼロから作成するよりも多くの仕事を要するという結果が出ています。加えて、既成品のシステムは内部がわかりづらいことが多く、ブラックボックスになっています。自分で作成したシステムであれば、それをとてもよく理解しているはずです。さらに言えば、最近のRailsへの変更 ([6.3](/chapters/modeling_users?version=5.1#sec-adding_a_secure_password)) により、カスタム認証システムを容易に作成できるようになりました。最後に、_あえて_最終的にサードパーティの認証システムを導入することになったとしても、自分自身で認証システムを構築した経験があれば、サードパーティ製品を理解して変更することがずっと容易になるはずです。

[6.1 Userモデル](/chapters/modeling_users?version=5.1#sec-user_model)
------------------------------------------------------------------

ここから3つの章にわたる最終目標はユーザー登録ページ ([図6.1](/chapters/modeling_users?version=5.1#fig-signup_mockup_preview)のモックアップ) を作成することですが、今のままでは新しいユーザーの情報を受け取っても保存する場所がないので、いきなりページを作成するわけにはいきません。ユーザー登録でまず初めにやることは、それらの情報を保存するためのデータ構造を作成することです。

図 6.1: ユーザー登録ページのモックアップ

Railsでは、データモデルとして扱うデフォルトのデータ構造のことを_モデル (Model)_ と呼びます ([1.3.3](/chapters/beginning?version=5.1#sec-mvc)で言うMVCのMのことです)。Railsでは、データを永続化するデフォルトの解決策として、_データベース_を使ってデータを長期間保存します。また、データベースとやりとりをするデフォルトのRailsライブラリは_Active Record_と呼ばれます[1](#cha-6_footnote-1) 。Active Recordは、データオブジェクトの作成/保存/検索のためのメソッドを持っています。これらのメソッドを使うのに、[リレーショナルデータベース](https://ja.wikipedia.org/wiki/%E9%96%A2%E4%BF%82%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9)で使うSQL (Structured Query Language)[2](#cha-6_footnote-2) を意識する必要はありません。さらに、Railsには_マイグレーション (Migration)_ という機能があります。データの定義をRubyで記述することができ、SQLのDDL (Data Definition Language) を新たに学ぶ必要がありません。つまりRailsは、データベースの細部をほぼ完全に隠蔽し、切り離してくれます。実際、本書ではSQLiteを開発 (development) 環境で使い、また、PostgreSQLを (Herokuでの) 本番環境 (production) で使います ([1.5](/chapters/beginning?version=5.1#sec-deploying)) が、本番環境のデータの保存方法の詳細について考える必要はほとんどありません。

Gitでバージョン管理を行なっているのであれば、このタイミングでユーザーをモデリングするためのトピックブランチを作成しておいてください。
```sh
$ git checkout -b modeling-users
```
### [6.1.1 データベースの移行](/chapters/modeling_users?version=5.1#sec-database_migrations)

[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)で扱ったカスタムビルドクラスの`User`を思い出してください。このクラスは、`name`と`email`を属性に持つユーザーオブジェクトでした。このクラスは役に立つ例として提供されましたが、Railsにとって極めて重要な部分である_永続性_という要素が欠けていました。RailsコンソールでUserクラスのオブジェクトを作っても、コンソールからexitするとそのオブジェクトはすぐに消えてしまいました。この節での目的は、簡単に消えることのないユーザーのモデルを構築することです。

[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)のユーザークラスと同様に、`name`と`email`の2つの属性からなるユーザーをモデリングするところから始めましょう。後者のemailを一意のユーザー名として使います[3](#cha-6_footnote-3) (パスワードのための属性は[6.3](/chapters/modeling_users?version=5.1#sec-adding_a_secure_password)で扱います)。[リスト4.17](/chapters/rails_flavored_ruby?version=5.1#code-example_user)では、次のようにRubyの`attr_accessor`メソッドを使いました。
```ruby
class User
  attr_accessor :name, :email
  .
  .
  .
end
```
それとは対照的に、Railsでユーザーをモデリングするときは、属性を明示的に識別する必要がありません。上で簡潔に述べたように、Railsはデータを保存する際にデフォルトでリレーショナルデータベースを使います。リレーショナルデータベースは、データ_行_で構成される_テーブル_からなり、各行はデータ属性の_カラム_ (列) を持ちます。例えばnameとemailを持つユーザーを保存するのであれば、`name`と`email`のカラムを持つ`users`テーブルを作成します (各行は1人のユーザーを表します)。テーブルに格納されるデータの例を[図6.2](/chapters/modeling_users?version=5.1#fig-users_table)に、対応するデータモデルを[図6.3](/chapters/modeling_users?version=5.1#fig-user_model_sketch)に示します (なお、[図6.3](/chapters/modeling_users?version=5.1#fig-user_model_sketch)は草案です。実際のデータモデルは[図6.4](/chapters/modeling_users?version=5.1#fig-user_model_initial)のようになります)。`name`や`email`といったカラム名を今のうちに考えておくことで、後ほどUserオブジェクトの各属性をActiveRecordに伝えるときに楽になります。

図 6.2: `users`テーブルに含まれるデータのサンプル

図 6.3: Userのデータモデルのスケッチ

[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)で、ユーザーコントローラ (と`new`アクション) を作ったときに使った次のコマンドを思い出してみてください。
```sh
$ rails generate controller Users new
```
モデルを作成するときは、上と似たようなパターンで`generate model`というコマンドを使います。さらに、今回は`name`や`email`といった属性を付けたUserモデルを使いたいので、実際に打つコマンドは[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)になります。

リスト 6.1: Userモデルを生成する
```sh
$ rails generate model User name:string email:string
     invoke  active_record
      create    db/migrate/20160523010738_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/models/user_test.rb
      create      test/fixtures/users.yml
```
(コントローラ名には複数形を使い、モデル名には単数形を用いるという慣習を頭に入れておいてください。コントローラは_Users_でモデルは_User_です。) `name:string`や`email:string`オプションのパラメータを渡すことによって、データベースで使いたい2つの属性をRailsに伝えます。このときに、これらの属性の型情報も一緒に渡します (この場合は`string`)。[リスト3.6](/chapters/static_pages?version=5.1#code-generating_pages)や[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)でアクション名を使って生成した例と比較してみてください。

[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)にある`generate`コマンドの結果のひとつとして、_マイグレーション_と呼ばれる新しいファイルが生成されます。マイグレーションは、データベースの構造をインクリメンタルに変更する手段を提供します。それにより、要求が変更された場合にデータモデルを適合させることができます。このUserモデルの例の場合、マイグレーションはモデル生成スクリプトによって自動的に作られました。[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)に示したように `name`と`email`の2つのカラムを持つ`users`テーブルを作成します ([6.2.5](/chapters/modeling_users?version=5.1#sec-uniqueness_validation)で、マイグレーションを１から手動で作成する方法について説明します)。

リスト 6.2: (`users`テーブルを作るための) Userモデルのマイグレーション `db/migrate/[timestamp]_create_users.rb`
```ruby
class CreateUsers < ActiveRecord::Migration[5.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :email

      t.timestamps
    end
  end
end
```

マイグレーションファイル名の先頭には、それが生成された時間の*タイムスタンプ*が追加されます。以前はインクリメンタルな整数が追加されましたが、複数の開発者によるチームでは、複数のプログラマが同じ整数を持つマイグレーションを生成してしまい、コンフリクトを引き起こしていました。現在のタイムスタンプによる方法であれば、まったく同時にマイグレーションが生成されるという通常ではありえないことが起きない限り、そのようなコンフリクトは避けられます。

マイグレーション自体は、データベースに与える変更を定義した`change`メソッドの集まりです。[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)の場合、`change`メソッドは`create_table`というRailsのメソッドを呼び、ユーザーを保存するためのテーブルをデータベースに作成します。`create_table`メソッドはブロック変数を1つ持つブロック ([4.3.2](/chapters/rails_flavored_ruby?version=5.1#sec-blocks)) を受け取ります。ここでは (“table”の頭文字を取って) `t`です。そのブロックの中で`create_table`メソッドは`t`オブジェクトを使って、`name`と`email`カラムをデータベースに作ります。型はどちらも`string`です[4](#cha-6_footnote-4) 。モデル名は単数形 (User) ですが、テーブル名は複数形 (`users`) です。これはRailsで用いられる言葉の慣習を反映しています。モデルはひとりのユーザーを表すのに対し、データベースのテーブルは複数のユーザーから構成されます。ブロックの最後の行`t.timestamps`は特別なコマンドで、`created_at`と`updated_at`という２つの「_マジックカラム (Magic Columns)_」を作成します。これらは、あるユーザーが作成または更新されたときに、その時刻を自動的に記録するタイムスタンプです (このマジックカラムの使用例を[6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)から具体的に見ていきます)。[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)のマイグレーションによって作成された完全なデータモデルを[図6.4](/chapters/modeling_users?version=5.1#fig-user_model_initial)に示します ([図6.3](/chapters/modeling_users?version=5.1#fig-user_model_sketch)のスケッチには無かったマジックカラムが追加されています)。

図 6.4: [リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)で生成されたUserのデータモデル

マイグレーションは、次のように`db:migrate`コマンド を使って実行することができます。これを「_マイグレーションの適用 (migrating up)_」と呼びます。
```sh
$ rails db:migrate
```


([2.2](/chapters/toy_app?version=5.1#sec-demo_users_resource)で、このコマンドを似たような状況で実行したことを思い出してみてください) 。初めて`db:migrate`が実行されると、`db/development.sqlite3`という名前のファイルが生成されます。これは[SQLite](http://sqlite.org/)[5](#cha-6_footnote-5) データベースの実体です。`development.sqlite3`ファイルを開くための[DB Browser for SQLite](http://sqlitebrowser.org/)という素晴らしいツールを使うと、データベースの構造を見ることができます (クラウドIDEを使っている場合は、[図6.5](/chapters/modeling_users?version=5.1#fig-sqlite_download)のようにまずはファイルをお手元にダウンロードする必要があります)。結果は[図6.6](/chapters/modeling_users?version=5.1#fig-sqlite_database_browser)のようになるので、[図6.4](/chapters/modeling_users?version=5.1#fig-user_model_initial)と比べて見てください。[図6.6](/chapters/modeling_users?version=5.1#fig-sqlite_database_browser)の中に、`id`というマイグレーションのときに説明されなかったカラムの存在に気づいたかもしれません。[2.2](/chapters/toy_app?version=5.1#sec-demo_users_resource)で簡単に説明したとおり、このカラムは自動的に作成され、Railsが各行を一意に識別するために使います。

図 6.5: クラウドIDEからファイルをダウンロードする

図 6.6: [DB Browser for SQLite](http://sqlitebrowser.org/)で作成した`users`テーブルを確認する

#### [演習](#sec-exercises_database_migrations)

1.  Railsは`db/`ディレクトリの中にある`schema.rb`というファイルを使っています。これはデータベースの構造 (_スキーマ (schema)_ と呼びます) を追跡するために使われます。さて、あなたの環境にある`db/schema.rb`の内容を調べ、その内容とマイグレーションファイル ([リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)) の内容を比べてみてください。
2.  ほぼすべてのマイグレーションは、_元に戻すことが可能です_ (少なくとも本チュートリアルにおいてはすべてのマイグレーションを元に戻すことができます)。元に戻すことを「_ロールバック (rollback)_と呼び、Railsでは`db:rollback`というコマンドで実現できます。
    ```sh
    $ rails db:rollback
    ```
    上のコマンドを実行後、`db/schema.rb`の内容を調べてみて、ロールバックが成功したかどうか確認してみてください ([コラム3.1](/chapters/static_pages?version=5.1#aside-undoing_things)ではマイグレーションに関する他のテクニックもまとめているので、参考にしてみてください)。上のコマンドでは、データベースから`users`テーブルを削除するために`drop_table`コマンドを内部で呼び出しています。これがうまくいくのは、`drop_table`と`create_table`がそれぞれ対応していることを`change`メソッドが知っているからです。この対応関係を知っているため、ロールバック用の逆方向のマイグレーションを簡単に実現することができるのです。なお、あるカラムを削除するような不可逆なマイグレーションの場合は、`change`メソッドの代わりに、`up`と`down`のメソッドを別々に定義する必要があります。詳細については、Railsガイドの「[Active Record マイグレーション](http://railsguides.jp/active_record_migrations.html)」を参照してください。
3.  もう一度`rails db:migrate`コマンドを実行し、`db/schema.rb`の内容が元に戻ったことを確認してください。

### [6.1.2 modelファイル](/chapters/modeling_users?version=5.1#sec-the_model_file)

これまで、[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)のUserモデルの作成によってどのように ([リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)の) マイグレーションファイルが作成されるかを見てきました。そして[図6.6](/chapters/modeling_users?version=5.1#fig-sqlite_database_browser)でこのマイグレーションを実行した結果を見ました。`users`テーブルを作成することで、`development.sqlite3`という名のファイルを更新し、`id`、`name`、`email`、`created_at`、`updated_at`を作成しました。また、[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)ではモデル用のuser.rbも作られました。この節では、以後このモデル用ファイルを理解することに専念します。

まずは`app/models/`ディレクトリにある、`user.rb`に書かれたUserモデルのコードを見てみましょう。これは控えめに言ってもとてもよくまとまっているコードです ([リスト6.3](/chapters/modeling_users?version=5.1#code-raw_user_model))。

リスト 6.3: 生成されたばかりのUserモデル `app/models/user.rb`
```ruby
class User < ApplicationRecord
end
```

[4.4.2](/chapters/rails_flavored_ruby?version=5.1#sec-a_class_of_our_own)で学んだことを思い出してみましょう。`class User < ApplicationRecord`という構文で、`User`クラスは`ApplicationRecord`を_継承_するので、Userモデルは自動的に`ActiveRecord::Base`クラスのすべての機能を持つことになります ([図2.18](/chapters/toy_app?version=5.1#fig-demo_model_inheritance))。とはいえ、継承されていることが分かっていても、`ActiveRecord::Base`に含まれるメソッドなどについて知らなければ何の役にも立ちません。そこで、このクラスでできることについて、これから一緒に学んでいきましょう。

#### [演習](#sec-exercises_the_model_file)

1.  Railsコンソールを開き、`User.new`で`User`クラスのオブジェクトが生成されること、そしてそのオブジェクトが`ApplicationRecord`を継承していることを確認してみてください (_ヒント_: [4.4.4](/chapters/rails_flavored_ruby?version=5.1#sec-a_controller_class)で紹介したテクニックを使ってみてください)。
2.  同様にして、`ApplicationRecord`が`ActiveRecord::Base`を継承していることについて確認してみてください。

### [6.1.3 ユーザーオブジェクトを作成する](/chapters/modeling_users?version=5.1#sec-creating_user_objects)

[第4章](/chapters/rails_flavored_ruby?version=5.1#cha-rails_flavored_ruby)と同じく、Railsコンソールを使ってデータモデルを調べてみましょう。(この時点では) データベースを変更したくないので、コンソールを_サンドボックス_モードで起動します。
```ruby
$ rails console --sandbox
loading development environment in sandbox
Any modifications you make will be rolled back on exit
>>
```
"Any modifications you make will be rolled back on exit" (ここで行ったすべての変更は終了時にロールバックされます) というメッセージにわかりやすく示されているように、コンソールをサンドボックスで起動すると、そのセッションで行ったデータベースへの変更をコンソールの終了時にすべて “ロールバック” (取り消し) してくれます。

[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)のコンソールセッションでは`User.new`で新しいユーザーオブジェクトを生成しましたが、[リスト4.17](/chapters/rails_flavored_ruby?version=5.1#code-example_user)のexample_userファイルを明示的にrequireするまでこのオブジェクトにはアクセスできませんでした。しかし、モデルを使うと状況は異なります。[4.4.4](/chapters/rails_flavored_ruby?version=5.1#sec-a_controller_class)で見たように、Railsコンソールは起動時にRailsの環境を自動的に読み込み、その環境にはモデルも含まれます。つまり、新しいユーザーオブジェクトを作成するときに余分な作業を行わずに済むということです。
```ruby
>> User.new
=> #<User id: nil, name: nil, email: nil, created_at: nil, updated_at: nil>
```
上の出力は、ユーザーオブジェクトをコンソール用に出力したものです。

`User.new`を引数なしで呼んだ場合は、すべての属性が`nil`のオブジェクトを返します。[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)では、オブジェクトの属性を設定するための_初期化ハッシュ (hash)_ を引数に取るように、Userクラスの例 (user_example.rb) を設計しました。この設計は、同様の方法でオブジェクトを初期化するActive Recordの設計に基づいています。
```ruby
>> user = User.new(name: "Michael Hartl", email: "mhartl@example.com")
=> #<User id: nil, name: "Michael Hartl", email: "mhartl@example.com",
created_at: nil, updated_at: nil>
```
上のように、nameとemail属性が期待どおり設定されていることがわかります。

また、Active Recordを理解する上で、「_有効性 (Validity)_」という概念も重要です。[6.2](/chapters/modeling_users?version=5.1#sec-user_validations)で詳細について解説しますが、今はまず先ほどの`user`オブジェクトが有効かどうか確認してみましょう。確認するためには`valid?`メソッドを使います。
```ruby
>> user.valid?
true
```
現時点ではまだデータベースにデータは格納されていません。つまり、`User.new`は_メモリ上で_オブジェクトを作成しただけで、`user.valid?`という行はただオブジェクトが有効かどうかを確認しただけとなります (データベースにデータがあるかどうかは有効性には関係ありません)。データベースにUserオブジェクトを保存するためには、`user`オブジェクトから`save`メソッドを呼び出す必要があります。
```ruby
>> user.save
   (0.1ms)  SAVEPOINT active_record_1
  SQL (0.8ms)  INSERT INTO "users" ("name", "email", "created_at",
  "updated_at") VALUES (?, ?, ?, ?)  [["name", "Michael Hartl"],
  ["email", "mhartl@example.com"], ["created_at", 2016-05-23 19:05:58 UTC],
  ["updated_at", 2016-05-23 19:05:58 UTC]]
   (0.1ms)  RELEASE SAVEPOINT active_record_1
=> true
```
`save`メソッドは、成功すれば`true`を、失敗すれば`false`を返します (現状では、保存はすべて成功するはずです。失敗する場合については[6.2](/chapters/modeling_users?version=5.1#sec-user_validations)で説明します)。また、Railsコンソール上では`user.save`に対応するSQLコマンドやその結果 (`INSERT INTO "users"`…) も表示するようになっています。なお、本書では生のSQLが必要になる場面がほとんどないので[6](#cha-6_footnote-6) 、SQLコマンドに関する解説は省略します。とはいえ、Active Recordに対応するSQLコマンドをザッと眺めておくだけでも勉強にはなるはずです。

作成した時点でのユーザーオブジェクトは、`id`属性、マジックカラムである`created_at`属性と`updated_at`属性の値がいずれも`nil`であったことを思い出してください。`save`メソッドを実行した後に何が変更されたのかを確認してみましょう。
```ruby
>> user
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">
```
上の結果から、`id`には`1`という値が代入され、一方でマジックカラムには現在の日時が代入されているのがわかります[7](#cha-6_footnote-7) 。現在、作成と更新のタイムスタンプは同一ですが、更新するようになると ([6.1.5](/chapters/modeling_users?version=5.1#sec-updating_user_objects)) これらの値が異なっていきます。

[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)のUserクラスと同様に、Userモデルのインスタンスはドット記法を用いてその属性にアクセスすることができます。
```ruby
>> user.name
=> "Michael Hartl"
>> user.email
=> "mhartl@example.com"
>> user.updated_at
=> Mon, 23 May 2016 19:05:58 UTC +00:00
```
詳細は[第7章](/chapters/sign_up?version=5.1#cha-sign_up)でも説明しますが、上で見たようにモデルの生成と保存を2つのステップに分けておくと何かと便利です。しかし、Active Recordでは`User.create`でモデルの生成と保存を同時におこなう方法も提供されています。
```ruby
>> User.create(name: "A Nother", email: "another@example.org")
#<User id: 2, name: "A Nother", email: "another@example.org", created_at:
"2016-05-23 19:18:46", updated_at: "2016-05-23 19:18:46">
>> foo = User.create(name: "Foo", email: "foo@bar.com")
#<User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2016-05-23
19:19:06", updated_at: "2016-05-23 19:19:06">
```
`User.create`は、`true`か`false`を返す代わりに、ユーザーオブジェクト自身を返すことに注目してください。返されたユーザーオブジェクトは (上の2つ目のコマンドにある`foo`のように) 変数に代入することもできます。

`destroy`は`create`の逆です。
```ruby
>> foo.destroy
   (0.1ms)  SAVEPOINT active_record_1
  SQL (0.2ms)  DELETE FROM "users" WHERE "users"."id" = ?  [["id", 3]]
   (0.1ms)  RELEASE SAVEPOINT active_record_1
=> #<User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2016-05-23
19:19:06", updated_at: "2016-05-23 19:19:06">
```
`create`と同じように`destroy`はそのオブジェクト自身を返しますが、その戻り値を使ってもう一度`destroy`を呼ぶことはできません。さらに、削除されたオブジェクトは次のようにまだメモリ上に残っています。
```ruby
>> foo
=> #<User id: 3, name: "Foo", email: "foo@bar.com", created_at: "2016-05-23
19:19:06", updated_at: "2016-05-23 19:19:06">
```
では、オブジェクトが本当に削除されたかどうかをどのようにして知ればよいのでしょうか。そして、保存して削除されていないオブジェクトの場合、どうやってデータベースからユーザーを取得するのでしょうか。これらの問いに答えるためには、Active Recordを使ってUserオブジェクトを検索する方法について学ぶ必要があります。

#### [演習](#sec-exercises_creating_user_objects)

1.  `user.name`と`user.email`が、どちらも`String`クラスのインスタンスであることを確認してみてください。
2.  `created_at`と`updated_at`は、どのクラスのインスタンスでしょうか?

### [6.1.4 ユーザーオブジェクトを検索する](/chapters/modeling_users?version=5.1#sec-finding_user_objects)

Active Recordには、オブジェクトを検索するための方法がいくつもあります。これらの機能を使って、過去に作成した最初のユーザーを探してみましょう。また、3番目のユーザー (`foo`) が削除されていることを確認しましょう。まずは存在するユーザーから探してみましょう。
```ruby
>> User.find(1)
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">
```
ここでは、`User.find`にユーザーのidを渡しています。その結果、Active Recordはそのidのユーザーを返します。

次に、`id`=`3`のユーザーがまだデータベースに存在するかどうかを確認してみましょう。
```ruby
>> User.find(3)
ActiveRecord::RecordNotFound: Couldn't find User with ID=3
```
[6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)で3番目のユーザーを削除したので、Active Recordはこのユーザーをデータベースの中から見つけることができませんでした。代わりに、`find`メソッドは_例外 (exception)_ を発生します。例外はプログラムの実行時に何か例外的なイベントが発生したことを示すために使われます。この場合、存在しないActive Recordのidによって、`find`で`ActiveRecord::RecordNotFound`という例外が発生しました[8](#cha-6_footnote-8) 。

一般的な`find`メソッド以外に、Active Recordには特定の属性でユーザーを検索する方法もあります。
```ruby
>> User.find_by(email: "mhartl@example.com")
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">

これまでメールアドレスをユーザー名として使ってきたので、このような`find`関連メソッドは、ユーザーをサイトにログインさせる方法を学ぶときに役に立ちます ([第7章](/chapters/sign_up?version=5.1#cha-sign_up))。ユーザー数が膨大になると`find_by`では検索効率が低下するのではないかと心配する方もいるかもしれませんが、あせる必要はありません。この問題およびデータベースのインデックスを使った解決策については[6.2.5](/chapters/modeling_users?version=5.1#sec-uniqueness_validation)で扱います。
```
ユーザーを検索する一般的な方法をあと少しだけご紹介して、この節を終わりにすることにしましょう。まず初めに`first`メソッドです。
```ruby
>> User.first
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">
```
読んで字のごとく、`first`は単にデータベースの最初のユーザーを返します。次は`all`メソッドです。
```
>> User.all
=> #<ActiveRecord::Relation [#<User id: 1, name: "Michael Hartl",
email: "mhartl@example.com", created_at: "2016-05-23 19:05:58",
updated_at: "2016-05-23 19:05:58">, #<User id: 2, name: "A Nother",
email: "another@example.org", created_at: "2016-05-23 19:18:46",
updated_at: "2016-05-23 19:18:46">]>
```
コンソールの出力結果を見ると、`User.all`でデータベースのすべてのUserオブジェクトが返ってくることがわかります。また、返ってきたオブジェクトのクラスが`ActiveRecord::Relation`となっています。これは、各オブジェクトを配列として効率的にまとめてくれるクラスです ([4.3.1](/chapters/rails_flavored_ruby?version=5.1#sec-arrays_and_ranges))。

#### [演習](#sec-exercises_finding_user_objects)

1.  `name`を使ってユーザーオブジェクトを検索してみてください。また、 `find_by_name`メソッドが使えることも確認してみてください (古いRailsアプリケーションでは、古いタイプの`find_by`をよく見かけることでしょう)。
2.  実用的な目的のため、`User.all`はまるで配列のように扱うことができますが、実際には配列ではありません。`User.all`で生成されるオブジェクトを調べ、`Array`クラスではなく`User::ActiveRecord_Relation`クラスであることを確認してみてください。
3.  `User.all`に対して`length`メソッドを呼び出すと、その長さを求められることを確認してみてください ([4.2.3](/chapters/rails_flavored_ruby?version=5.1#sec-objects_and_message_passing))。Rubyの性質として、そのクラスを詳しく知らなくても_なんとなく_オブジェクトをどう扱えば良いかわかる、という性質があります。これを_ダックタイピング (duck typing)_ と呼び、よく次のような格言で言い表されています「もしアヒルのような容姿で、アヒルのように鳴くのであれば、それはもうアヒルだろう」。(訳注: そういえば[RubyKaigi 2016](http://rubykaigi.org/2016)の基調講演で、[Ruby作者のMatzがダックタイピングについて説明](https://www.youtube.com/watch?v=2Ag8l-wq5qk)していました。２〜３分の短くて分かりやすい説明なので、ぜひ視聴してみてください!)

### [6.1.5 ユーザーオブジェクトを更新する](/chapters/modeling_users?version=5.1#sec-updating_user_objects)

いったんオブジェクトを作成すれば、今度は何度でも更新したくなるものです。基本的な更新の方法は2つです。ひとつは、[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)でやったように属性を個別に代入する方法です。
```ruby
>> user           # userオブジェクトが持つ情報のおさらい
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">
>> user.email = "mhartl@example.net"
=> "mhartl@example.net"
>> user.save
=> true
```
変更をデータベースに保存するために最後にsaveを実行する必要があることを忘れないでください。保存を行わずに`reload`を実行すると、データベースの情報を元にオブジェクトを再読み込みするので、次のように変更が取り消されます。
```ruby
>> user.email
=> "mhartl@example.net"
>> user.email = "foo@bar.com"
=> "foo@bar.com"
>> user.reload.email
=> "mhartl@example.net"
```
`user.save`を実行したことでユーザーが更新できました。この時、[6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)で触れたように、マジックカラムの更新日時も更新されていることにも注目してください。
```ruby
>> user.created_at
=> "2016-05-23 19:05:58"
>> user.updated_at
=> "2016-05-23 19:08:23"
```
属性を更新するもう１つの方法は、`update_attributes`を使うケースです[9](#cha-6_footnote-9) 。
```ruby
>> user.update_attributes(name: "The Dude", email: "dude@abides.org")
=> true
>> user.name
=> "The Dude"
>> user.email
=> "dude@abides.org"
```
`update_attributes`メソッドは属性のハッシュを受け取り、成功時には更新と保存を続けて同時に行います (保存に成功した場合は`true`を返します)。ただし、検証に1つでも失敗すると、 `update_attributes`の呼び出しは失敗します。例えば[6.3](/chapters/modeling_users?version=5.1#sec-adding_a_secure_password)で実装すると、パスワードの保存を要求するようになり、検証で失敗するようになります。特定の属性のみを更新したい場合は、次のように`update_attribute`を使います。この`update_attribute`には、検証を回避するといった効果もあります。
```ruby
>> user.update_attribute(:name, "El Duderino")
=> true
>> user.name
=> "El Duderino"
```
#### [演習](#sec-exercises_updating_user_objects)

1.  userオブジェクトへの代入を使ってname属性を使って更新し、`save`で保存してみてください。
2.  今度は`update_attributes`を使って、email属性を更新および保存してみてください。
3.  同様にして、マジックカラムである`created_at`も直接更新できることを確認してみてください。_ヒント_: 更新するときは「`1.year.ago`」を使うと便利です。これはRails流の時間指定の１つで、現在の時刻から１年前の時間を算出してくれます。

[6.2 ユーザーを検証する](/chapters/modeling_users?version=5.1#sec-user_validations)
--------------------------------------------------------------------------

ついに、[6.1](/chapters/modeling_users?version=5.1#sec-user_model)で作成したUserモデルに、アクセス可能な`name`と`email`属性が与えられました。しかし、これらの属性はどんな値でも取ることができてしまいます。現在は (空文字を含む) あらゆる文字列が有効です。名前とメールアドレスには、もう少し何らかの制限があってよいはずです。例えば`name`は空であってはならず、`email`はメールアドレスのフォーマットに従う必要があります。さらに、メールアドレスをユーザーがログインするときの一意のユーザー名として使おうとしているので、メールアドレスがデータベース内で重複することのないようにする必要もあります。

要するに、`name`と`email`にあらゆる文字列を許すのは避けるべきです。これらの属性値には、何らかの制約を与える必要があります。Active Record では_検証 (Validation)_ という機能を通して、こういった制約を課すことができるようになっています (実は[2.3.2](/chapters/toy_app?version=5.1#sec-putting_the_micro_in_microposts)で少しだけ使っていました)。ここでは、よく使われるケースのうちのいくつかについて説明します。それらは_存在性 (presence)_の検証、_長さ (length)_の検証、_フォーマット (format)_の検証、_一意性 (uniqueness)_の検証です。[6.3.2](/chapters/modeling_users?version=5.1#sec-has_secure_password)では、よく使われる最終検証として_確認 (confirmation)_を追加します。[7.3](/chapters/sign_up?version=5.1#sec-unsuccessful_signups)では、ユーザーが制約に違反したときに、検証機能によって自動的に表示される有用なエラーメッセージをお見せします。

### [6.2.1 有効性を検証する](/chapters/modeling_users?version=5.1#sec-a_validity_test)

[コラム3.3](/chapters/static_pages?version=5.1#aside-when_to_test)で言及したとおり、テスト駆動開発は仕事で常に正しく適用できるとは限りませんが、モデルのバリデーション機能は、テスト駆動開発とまさにピッタシの機能と言えます。バリデーション機能は強力ですが、うまく動いている自信を持つのが難しいです。しかし、(テスト駆動開発のように) まず失敗するテストを書き、次にテストを成功させるように実装すると、期待した通りに動いている自信を持てるようになります。

具体的なテスト方法についてですが、まず_有効な_モデルのオブジェクトを作成し、その属性のうちの1つを有効でない属性に意図的に変更します。そして、バリデーションで失敗するかどうかをテストする、といった方針で進めていきます。念のため、最初に作成時の状態に対してもテストを書いておき、最初のモデルが有効であるかどうかも確認しておきます。このようにテストすることで、バリデーションのテストが失敗したとき、バリデーションの実装に問題があったのか、オブジェクトそのものに問題があったのかを確認することができます。

[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)のコマンドを実行してUser用テストの原型ができているはずなので、まずはその中身から見ていきましょう ([リスト6.4](/chapters/modeling_users?version=5.1#code-default_user_test))。

リスト 6.4: デフォルトのUserテスト (モックのみ) `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
```

有効なオブジェクトに対してテストを書くために、`setup`という特殊なメソッドを使って有効なUserオブジェクト (`@user`) を作成します (このメソッドは[第3章](/chapters/static_pages?version=5.1#cha-static_pages)の演習でも少し取り上げました)。setupメソッド内に書かれた処理は、各テストが走る直前に実行されます。`@user`はインスタンス変数ですが、setupメソッド内で宣言しておけば、すべてのテスト内でこのインスタンス変数が使えるようになります。したがって、`valid?`メソッドを使ってUserオブジェクトの有効性をテストすることができます ([6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects))。作成したコードを[リスト6.5](/chapters/modeling_users?version=5.1#code-valid_user_test)に示します。

リスト 6.5: 有効なUserかどうかをテストする **green** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end
end
```

[リスト6.5](/chapters/modeling_users?version=5.1#code-valid_user_test)では、シンプルな`assert`メソッドを使ってテストします。`@user.valid?`が`true`を返すと成功し、`false`を返すと失敗します。

とはいえ、Userモデルにはまだバリデーションがないので、このテストは成功するはずです。

リスト 6.6: **green**
```sh
$ rails test:models
```
上では`rails test:models`というコマンドを実行していますが、これはモデルに関するテストだけを走らせるコマンドです ([5.3.4](/chapters/filling_in_the_layout?version=5.1#sec-layout_link_tests)で使った`rails test:integration`と似ていますね)。

#### [演習](#sec-exercises_a_validity_test)

1.  コンソールから、新しく生成したuserオブジェクトが有効 (valid) であることを確認してみましょう。
2.  [6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)で生成したuserオブジェクトも有効であるかどうか、確認してみましょう。

### [6.2.2 存在性を検証する](/chapters/modeling_users?version=5.1#sec-presence_validation)

おそらく最も基本的なバリデーションは「_存在性 (Presence)_」です。これは単に、渡された属性が存在することを検証します。例えばこの節では、ユーザーがデータベースに保存される前にnameとemailフィールドの両方が存在することを保証します。[7.3.3](/chapters/sign_up?version=5.1#sec-signup_error_messages)では、この要求を新しいユーザーを作るためのユーザー登録フォームにまで徹底させる方法を確認します。

まずは[リスト6.5](/chapters/modeling_users?version=5.1#code-valid_user_test)に、 `name`属性の存在性に関するテストを追加します。具体的には[リスト6.7](/chapters/modeling_users?version=5.1#code-name_presence_test)のように、まず`@user`変数の`name`属性に対して空白の文字列をセットします。そして、`assert_not`メソッドを使って Userオブジェクトが有効でなくなったことを確認します。

リスト 6.7: `name`属性にバリデーションに対するテスト **red** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end

  test "name should be present" do
    @user.name = "     "
    assert_not @user.valid?
  end
end
```

この時点では、モデルのテストは **red**になっているはずです。

リスト 6.8: **red**
```sh
$ rails test:models
```
[第2章](/chapters/toy_app?version=5.1#cha-a_toy_app)の演習で少し触れましたが、name属性の存在を検査する方法は、[リスト6.9](/chapters/modeling_users?version=5.1#code-validates_presence_of_name)に示したとおり、`validates` メソッドに`presence: true`という引数を与えて使うことです。`presence: true`という引数は、要素が１つの_オプションハッシュ_です。[4.3.4](/chapters/rails_flavored_ruby?version=5.1#sec-css_revisited)のようにメソッドの最後の引数としてハッシュを渡す場合、波カッコを付けなくても問題ありません ([5.1.1](/chapters/filling_in_the_layout?version=5.1#sec-adding_to_the_layout)でも説明したように、Railsのオプションハッシュは繰り返し登場するテーマです)。

リスト 6.9: `name`属性の存在性を検証する **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  validates :name, presence: true
end
```

[リスト6.9](/chapters/modeling_users?version=5.1#code-validates_presence_of_name)は一見魔法のように見えるかもしれませんが、`validates`は単なるメソッドです。カッコを使って[リスト6.9](/chapters/modeling_users?version=5.1#code-validates_presence_of_name)を同等のコードに書き換えたものを次に示します。
```ruby
class User < ApplicationRecord
  validates(:name, presence: true)
end
```
コンソールを起動して、Userモデルに検証を追加した効果を見てみましょう[10](#cha-6_footnote-10) 。
```sh
$ rails console --sandbox
> user = User.new(name: "", email: "mhartl@example.com")
>> user.valid?
=> false
```
このように、`user`変数が有効かどうかを`valid?`メソッドでチェックすることができます。もしオブジェクトが１つ以上の検証に失敗したときは、`false`を返します。また、すべてのバリデーションに通ったときに`true`を返します。今回の場合、検証が1つしかないので、どの検証が失敗したかわかります。しかし、失敗したときに作られる`errors`オブジェクトを使って確認すれば、さらに便利です。
```ruby
>> user.errors.full_messages
=> ["Name can't be blank"]
```
(Railsが属性の存在性を検査するときに、エラーメッセージはヒントになります。これには`blank?`メソッドを用います。[4.4.3](/chapters/rails_flavored_ruby?version=5.1#sec-modifying_built_in_classes)の終わりに見ました)。

Userオブジェクトは有効ではなくなったので、データベースに保存しようとすると自動的に失敗するはずです。
```ruby
>> user.save
=> false
```
この変更により[リスト6.7](/chapters/modeling_users?version=5.1#code-name_presence_test)のテストは **green**しているはずです。

リスト 6.10: **green**
```sh
$ rails test:models
```
[リスト6.7](/chapters/modeling_users?version=5.1#code-name_presence_test)のモデルに倣って、`email`属性の存在性についてもテストを書いてみましょう ([リスト6.11](/chapters/modeling_users?version=5.1#code-email_presence_test))。最初は失敗しますが、[リスト6.12](/chapters/modeling_users?version=5.1#code-validates_presence_of_email)のコードを追加することで成功するようになります。

リスト 6.11: `email`属性の検証に対するテスト **red** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end

  test "should be valid" do
    assert @user.valid?
  end

  test "name should be present" do
    @user.name = ""
    assert_not @user.valid?
  end

  test "email should be present" do
    @user.email = "     "
    assert_not @user.valid?
  end
end
```

リスト 6.12: `email`属性の存在性を検証する **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  validates :name,  presence: true
  validates :email, presence: true
end
```

これですべての存在性がチェックされたので、テストスイートは **green**になるはずです。

リスト 6.13: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_presence_validation)

1.  新しいユーザー`u`を作成し、作成した時点では有効ではない (invalid) ことを確認してください。なぜ有効ではないのでしょうか? エラーメッセージを確認してみましょう。
2.  `u.errors.messages`を実行すると、ハッシュ形式でエラーが取得できることを確認してください。emailに関するエラー情報だけを取得したい場合、どうやって取得すれば良いでしょうか?

### [6.2.3 長さを検証する](/chapters/modeling_users?version=5.1#sec-length_validation)

各ユーザーは、Userモデル上に名前を持つことを強制されるようになりました。しかし、これだけでは十分ではありません。ユーザーの名前はサンプルWebサイトに表示されるものなので、名前の長さにも制限を与える必要があります。[6.2.2](/chapters/modeling_users?version=5.1#sec-presence_validation)で既に同じような作業を行ったので、この実装は簡単です。

最長のユーザー名の長さに科学的な根拠はありませんので、単に`50`を上限として手頃な値を使うことにします。つまりここでは、`51`文字の名前は長すぎることを検証します。また、実際に問題になることはほとんどありませんが、問題になる可能性もあるので長すぎるメールアドレスに対してもバリデーションを掛けましょう。ほとんどのデータベースでは文字列の上限を255としているので、それに合わせて255文字を上限とします。[6.2.4](/chapters/modeling_users?version=5.1#sec-format_validation)で説明するメールアドレスのフォーマットに関するバリデーションでは、こういった長さの検証はできないので、本節で長さに関するバリデーションを事前に追加しておきます。結果を[リスト6.14](/chapters/modeling_users?version=5.1#code-length_validation_test)に示します。

リスト 6.14: `name`の長さの検証に対するテスト **red** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "name should not be too long" do
    @user.name = "a" * 51
    assert_not @user.valid?
  end

  test "email should not be too long" do
    @user.email = "a" * 244 + "@example.com"
    assert_not @user.valid?
  end
end
```

[リスト6.14](/chapters/modeling_users?version=5.1#code-length_validation_test)では、51文字の文字列を簡単に作るために_文字列のかけ算_を使いました。結果をコンソール上で確認できます。
```ruby
>> "a" * 51
=> "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
>> ("a" * 51).length
=> 51

メールアドレスの長さに対するバリデーションも、次のように長い文字列を作成して検証します。

>> "a" * 244 + "@example.com"
=> "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
a@example.com"
>> ("a" * 244 + "@example.com").length
=> 256
```
この時点では、[リスト6.14](/chapters/modeling_users?version=5.1#code-length_validation_test)のテストは **red**になっているはずです。

リスト 6.15: **red**
```sh
$ rails test
```
これをパスさせるためには、長さを強制するための検証の引数を使う必要があります。`:maximum`パラメータと共に用いられる`:length`は、長さの上限を強制します ([リスト6.16](/chapters/modeling_users?version=5.1#code-length_validation))。

リスト 6.16: `name`属性に長さの検証を追加する **green** `app/models/user.rb`
```ruby

class User < ApplicationRecord
  validates :name,  presence: true, length: { maximum: 50 }
  validates :email, presence: true, length: { maximum: 255 }
end
```

これでテストが **green**になるはずです。

リスト 6.17: **green**
```sh
$ rails test
```
成功したテストスイートを再利用して、今度は少し難しい、メールアドレスのフォーマット検証作業に取りかかりましょう。

#### [演習](#sec-exercises_length_validation)

1.  長すぎるnameとemail属性を持ったuserオブジェクトを生成し、有効でないことを確認してみましょう。
2.  長さに関するバリデーションが失敗した時、どんなエラーメッセージが生成されるでしょうか? 確認してみてください。

### [6.2.4 フォーマットを検証する](/chapters/modeling_users?version=5.1#sec-format_validation)

`name`属性の検証には、空文字でない、名前が51文字未満であるという最小限の制約しか与えていませんでした。`email`属性の場合は、有効なメールアドレスかどうかを判定するために、もっと厳重な要求を満たさなければなりません。これまでは空のメールアドレスのみを禁止してきましたが、ここではメールアドレスにおなじみのパターン`user@example.com`に合っているかどうかも確認することを要求します。(なお今回ここで使うテストや検証は、形式があからさまに無効なものを拒否するだけであり、すべての有効なメールアドレスを受け入れられるものではない点に注意してください。)

最初に、有効なメールアドレスと無効なメールアドレスのコレクションに対するテストを行いましょう。このコレクションを作る方法として、次に示すように、文字列の配列を簡単に作れる`%w[]`という便利なテクニックを知っておくと良いでしょう。
```ruby
>> %w[foo bar baz]
=> ["foo", "bar", "baz"]
>> addresses = %w[USER@foo.COM THE_US-ER@foo.bar.org first.last@foo.jp]
=> ["USER@foo.COM", "THE_US-ER@foo.bar.org", "first.last@foo.jp"]
>> addresses.each do |address|
?>   puts address
>> end
USER@foo.COM
THE_US-ER@foo.bar.org
first.last@foo.jp
```
`each`メソッドを使って`addresses`配列の各要素を繰り返し取り出しました ([4.3.2](/chapters/rails_flavored_ruby?version=5.1#sec-blocks))。このテクニックを学んだことで、基本となるメールアドレスフォーマット検証のテストを書く準備が整いました。

メールアドレスのバリデーションは扱いが難しく、エラーが発生しやすい部分なので、_有効な_メールアドレスと無効なメールアドレスをいくつか用意して、バリデーション内のエラーを検知していきます。具体的には、_user@example,com_のような無効なメールアドレスが弾かれることと、_user@example.com_のような有効なメールアドレスが通ることを確認しながら、バリデーションを実装していきます (ちなみに今の状態では、空でない文字列はすべてメールアドレスとして通ってしまいます) 。まずは、有効なメールアドレスを[リスト6.18](/chapters/modeling_users?version=5.1#code-email_format_valid_tests)に示します。

リスト 6.18: 有効なメールフォーマットをテストする **green** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "email validation should accept valid addresses" do
    valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org
                         first.last@foo.jp alice+bob@baz.cn]
    valid_addresses.each do |valid_address|
      @user.email = valid_address
      assert @user.valid?, "#{valid_address.inspect} should be valid"
    end
  end
end
```

ここでは、assertメソッドの第2引数にエラーメッセージを追加していることに注目してください。これによって、どのメールアドレスでテストが失敗したのかを特定できるようになります。
```ruby
assert @user.valid?, "#{valid_address.inspect} should be valid"
```
(詳細な文字列を調べるために[4.3.3](/chapters/rails_flavored_ruby?version=5.1#sec-hashes_and_symbols)で紹介した`inspect`メソッドを使っています。) どのメールアドレスで失敗したのかを知ることは非常に便利です。そこで[リスト6.18](/chapters/modeling_users?version=5.1#code-email_format_valid_tests)では、`each`メソッドを使って各メールアドレスを順にテストしています。ループさせずにテストすると、失敗した行番号とメールアドレスの行数を照らし合わせて、失敗したメールアドレスを特定するといった作業が発生してしまいます。

次に、_user@example,com_ (ドットではなくカンマになっている) や_user_at_foo.org_ (アットマーク ‘@’ がない) といった無効なメールアドレスを使って _「無効性 (Invalidity)_」についてテストしていきます。[リスト6.18](/chapters/modeling_users?version=5.1#code-email_format_valid_tests)と同様に、[リスト6.19](/chapters/modeling_users?version=5.1#code-email_format_validation_tests)でもエラーメッセージをカスタマイズして、どのメールアドレスで失敗したのかすぐに特定できるようにしておきます。

リスト 6.19: メールフォーマットの検証に対するテスト **red** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase
  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "email validation should reject invalid addresses" do
    invalid_addresses = %w[user@example,com user_at_foo.org user.name@example.
                           foo@bar_baz.com foo@bar+baz.com]
    invalid_addresses.each do |invalid_address|
      @user.email = invalid_address
      assert_not @user.valid?, "#{invalid_address.inspect} should be invalid"
    end
  end
end
```

この時点では、テストは **red**になるはずです。

リスト 6.20: **red**
```sh
$ rails test
```
メールアドレスのフォーマットを検証するためには、次のように`format`というオプションを使います。
```ruby
validates :email, format: { with: /<regular expression>/ }
```
このオプションは引数に_正規表現 (Regular Expression)_ (_regex_とも呼ばれます) を取ります。正規表現は一見謎めいて見えますが、文字列のパターンマッチングにおいては非常に強力な言語です。つまり、有効なメールアドレスだけにマッチして、無効なメールアドレスには_マッチしない_正規表現を組み立てる必要があります。

メールアドレス標準を定める公式サイトに完全な正規表現があるのですが、非常に巨大かつ意味不明で、場合によっては逆効果になりかねます[11](#cha-6_footnote-11) 。本チュートリアルではもっと実用的で、堅牢であることが実戦で保証されている正規表現を採用します。これが、その正規表現です。
```ruby
VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
```
この正規表現を理解するために、お手頃なサイズに分割して[表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)にまとめました[12](#cha-6_footnote-12) 。

<table><tbody><tr><td><strong>正規表現</strong></td><td><strong>意味</strong></td></tr><tr><td><code>/A[w+-.]+@[a-zd-.]+.[a-z]+z/i</code></td><td>(完全な正規表現)</td></tr><tr><td><code>/</code></td><td>正規表現の開始を示す</td></tr><tr><td><code>A</code></td><td>文字列の先頭</td></tr><tr><td><code>[w+-.]+</code></td><td>英数字、アンダースコア (_)、プラス (+)、ハイフン (-)、ドット (.) のいずれかを少なくとも1文字以上繰り返す</td></tr><tr><td><code>@</code></td><td>アットマーク</td></tr><tr><td><code>[a-zd-.]+</code></td><td>英小文字、数字、ハイフン、ドットのいずれかを少なくとも1文字以上繰り返す</td></tr><tr><td><code>.</code></td><td>ドット</td></tr><tr><td><code>[a-z]+</code></td><td>英小文字を少なくとも1文字以上繰り返す</td></tr><tr><td><code>z</code></td><td>文字列の末尾</td></tr><tr><td><code>/</code></td><td>正規表現の終わりを示す</td></tr><tr><td><code>i</code></td><td>大文字小文字を無視するオプション</td></tr></tbody></table>

表 6.1: メールの正規表現を分解した結果

[表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)からも多くのことを学べるとは思いますが、正規表現を本当に理解するためには実際に使って見るのが一番です。例えば[Rubular](http://www.rubular.com/)という対話的に正規表現を試せるWebサイトがあります ([図6.7](/chapters/modeling_users?version=5.1#fig-rubular))[13](#cha-6_footnote-13) このWebサイトはインタラクティブ性に富んだインターフェイスを持っていて、また、正規表現のクイックリファレンスも兼ね備えています。Rubularをブラウザで開き、[表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)の内容を実際に試してみることを強くお勧めします。正規表現は、読んで学ぶより対話的に学んだほうが早いです。(_注意_: [表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)の正規表現をRubularで使って学ぶ場合、冒頭の`A`と末尾の`z`を含めずに試してみてください。こうすることで、複数のメールアドレスを１回で検知できるようになり便利です。また、Rubularではスラッシュ `/.../` の内側の部分を書くだけで大丈夫ですので、両端付近にあるスラッシュは取り除いてください。)

図 6.7: 素晴らしい正規表現エディタ[Rubular](http://www.rubular.com/)

[表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)の正規表現を適用して`email`のフォーマットを検証した結果を、[リスト6.21](/chapters/modeling_users?version=5.1#code-validates_format_of_email)に示します。

リスト 6.21: メールフォーマットを正規表現で検証する **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX }
end
```

正規表現`VALID_EMAIL_REGEX`は_定数_です。大文字で始まる名前はRubyでは定数を意味します。次のコードは、
```ruby
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX }
```
これで、このパターンに一致するメールアドレスだけが有効であることをチェックできるようになります。ただ上の正規表現には、少しだけ残念な点があります。それは`foo@bar..com`のようなドットの連続を誤りとして検出できない、という点です。[リスト6.21](/chapters/modeling_users?version=5.1#code-validates_format_of_email)の正規表現を修正すると直りますが、これについては演習 ([6.2.4.1](/chapters/modeling_users?version=5.1#sec-exercises_format_validation)) に持ち越すことにしましょう (訳注: ドットの連続だけでなく、[国際化ドメイン](https://www.nic.ad.jp/ja/dom/idn.html)にも対応できた方が良いでしょう。指摘してくれた[@znz](https://twitter.com/znz/status/912701557715562497)さん、ありがとうございます!)。

この時点では、テストは **green**になるはずです。

リスト 6.22: **green**
```sh
$ rails test:models
```
残る制約は、メールアドレスが一意であることを強制することだけとなりました。

#### [演習](#sec-exercises_format_validation)

1.  [リスト6.18](/chapters/modeling_users?version=5.1#code-email_format_valid_tests)にある有効なメールアドレスのリストと、[リスト6.19](/chapters/modeling_users?version=5.1#code-email_format_validation_tests)にある無効なメールアドレスのリストをRubularの_Your test string:_に転記してみてください。その後、[リスト6.21](/chapters/modeling_users?version=5.1#code-validates_format_of_email)の正規表現を_Your regular expression:_に転記して、有効なメールアドレスのみがすべてマッチし、無効なメールアドレスはすべてマッチしないことを確認してみましょう。
2.  先ほど触れたように、[リスト6.21](/chapters/modeling_users?version=5.1#code-validates_format_of_email)のメールアドレスチェックする正規表現は、_foo@bar..com_のようにドットが連続した無効なメールアドレスを許容してしまいます。まずは、このメールアドレスを[リスト6.19](/chapters/modeling_users?version=5.1#code-email_format_validation_tests)の無効なメールアドレスリストに追加し、これによってテストが失敗することを確認してください。次に、[リスト6.23](/chapters/modeling_users?version=5.1#code-better_email_regex)で示した、少し複雑な正規表現を使ってこのテストがパスすることを確認してください。
3.  _foo@bar..com_をRubularのメールアドレスのリストに追加し、[リスト6.23](/chapters/modeling_users?version=5.1#code-better_email_regex)の正規表現をRubularで使ってみてください。有効なメールアドレスのみがすべてマッチし、無効なメールアドレスはすべてマッチしないことを確認してみましょう。

リスト 6.23: ２つの連続したドットはマッチさせないようにする **green** `app/models/user.rb`
```ruby

class User < ApplicationRecord
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-]+(.[a-zd-]+)*.[a-z]+z/i
  validates :email, presence:   true, length: { maximum: 255 },
                    format:     { with: VALID_EMAIL_REGEX }
end
```

### [6.2.5 一意性を検証する](/chapters/modeling_users?version=5.1#sec-uniqueness_validation)

[解説動画](https://railstutorial.jp/trial?utm_source=tutorial&utm_medium=text&utm_campaign=screencast_trial&utm_content=uniqueness_validation)「第6章 後編: 8. 一意性の問題」で詳しく解説

メールアドレスの一意性を強制するために (ユーザー名として使うために)、`validates`メソッドの`:unique`オプションを使います。ただしここで_重大な_警告があります。次の文面は流し読みせず、必ず注意深く読んでください。

まずは小さなテストから書いていきます。モデルのテストではこれまで、主に`User.new`を使ってきました。このメソッドは単にメモリ上にRubyのオブジェクトを作るだけです。しかし、一意性のテストのためには、メモリ上だけではなく、実際にレコードをデータベースに登録する必要があります[14](#cha-6_footnote-14) 。そのため、まずは重複したメールアドレスからテストしていきます ([リスト6.24](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_test))。

リスト 6.24: 重複するメールアドレス拒否のテスト **red** `test/models/user_test.rb`
```ruby

require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "email addresses should be unique" do
    duplicate_user = @user.dup
    @user.save
    assert_not duplicate_user.valid?
  end
end
```

上のコードでは、`@user`と同じメールアドレスのユーザーは作成できないことを、`@user.dup`を使ってテストしています。dupは、同じ属性を持つデータを複製するためのメソッドです。`@user`を保存した後では、複製されたユーザーのメールアドレスが既にデータベース内に存在するため、ユーザの作成は無効になるはずです。

[リスト6.24](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_test)のテストをパスさせるために、`email`のバリデーションに`uniqueness: true`というオプションを追加します [リスト6.25](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email)。

リスト 6.25: メールアドレスの一意性を検証する **green** `app/models/user.rb`
```ruby

class User < ApplicationRecord
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: true
end
```

実装の途中ですが、ここで１つ補足します。通常、メールアドレスでは大文字小文字が区別されません。すなわち、`foo@bar.com`は`FOO@BAR.COM`や`FoO@BAr.coM`と書いても扱いは同じです。したがって、メールアドレスの検証ではこのような場合も考慮する必要があります[15](#cha-6_footnote-15) 。この性質のため、大文字を区別しないでテストすることが重要になり、実際のテストコードは[リスト6.26](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_case_insensitive_test)のようにしなければなりません。

リスト 6.26: 大文字小文字を区別しない、一意性のテスト **red** `test/models/user_test.rb`
```ruby

require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "email addresses should be unique" do
    duplicate_user = @user.dup
    duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end
end
```

上のコードではStringの`upcase`メソッドを使っています ([4.3.2](/chapters/rails_flavored_ruby?version=5.1#sec-blocks))。このテストは最初のメールアドレスの重複テストと同じことをしていますが、大文字に変換したメールアドレスを使っている点が異なります。もしこのテストが少し抽象的すぎると感じるなら、Railsコンソールを起動して確認しましょう。
```sh
$ rails console --sandbox
```
> user = User.create(name: "Example User", email: "user@example.com")
>> user.email.upcase
=> "USER@EXAMPLE.COM"
>> duplicate_user = user.dup
>> duplicate_user.email = user.email.upcase
>> duplicate_user.valid?
=> true

現在の一意性検証では大文字小文字を区別しているため、`duplicate_user.valid?`は`true`になります。しかし、ここでは`false`になる必要があります。幸い、`:uniqueness`では`:case_sensitive`という打ってつけのオプションが使えます ([リスト6.27](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_case_insensitive))。

リスト 6.27: メールアドレスの大文字小文字を無視した一意性の検証 **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
end
```

ここで、[リスト6.25](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email)の`true`を`case_sensitive: false`に置き換えただけであることに注目してください ([リスト6.27](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_case_insensitive))。Railsはこの場合、`:uniqueness`を`true`と判断します。

この時点で、アプリケーションは重要な警告と共にメールアドレスの一意性を強制し、テストスイートもパスするはずです。

リスト 6.28: **green**
```sh
$ rails test
```
しかし、依然としてここには1つの問題が残っています。それは_Active Recordはデータベースのレベルでは一意性を保証していない_という問題です。具体的なシナリオを使ってその問題を説明します。

1.  アリスはサンプルアプリケーションにユーザー登録します。メールアドレスはalice@wonderland.comです。
2.  アリスは誤って “Submit” を素早く_2回_クリックしてしまいます。そのためリクエストが2つ連続で送信されます。
3.  次のようなことが順に発生します。リクエスト1は、検証にパスするユーザーをメモリー上に作成します。リクエスト2でも同じことが起きます。リクエスト1のユーザーが保存され、リクエスト2のユーザーも保存されます。
4.  この結果、一意性の検証が行われているにもかかわらず、同じメールアドレスを持つ2つのユーザーレコードが作成されてしまいます。

上のシナリオが信じがたいもののように思えるかもしれませんが、どうか信じてください。RailsのWebサイトでは、トラフィックが多いときにこのような問題が発生する可能性があるのです (筆者もこれを理解するのに苦労しました)。幸い、解決策の実装は簡単です。実は、この問題はデータベースレベルでも一意性を強制するだけで解決します。具体的にはデータベース上のemailのカラムに_インデックス (index)_ を追加し、そのインデックスが一意であるようにすれば解決します ([コラム6.2](/chapters/modeling_users?version=5.1#aside-database_indices))。

コラム 6.2. データベースのインデックス

データベースにカラムを作成するとき、そのカラムでレコードを_検索する (find)_ 必要があるかどうかを考えることは重要です。例えば、[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)のマイグレーションによって作成された `email`属性について考えてみましょう。[第7章](/chapters/sign_up?version=5.1#cha-sign_up)ではユーザーをサンプルアプリにログインできるようにしますが、このとき、送信されたものと一致するメールアドレスのユーザーのレコードをデータベースの中から探しだす必要があります。残念なことに、(インデックスなどの機能を持たない) 素朴なデータモデルにおいてユーザーをメールアドレスで検索するには、データベースの_ひとりひとり_のユーザーの行を端から順に読み出し、そのemail属性と渡されたメールアドレスを比較するという非効率的な方法しかありません。つまり、例えばデータベース上の最後のユーザを探す場合でも、すべてのユーザーを最初から順に_一人ずつ_探していくことになります。これは、データベースの世界では_全表スキャン (Full-table Scan)_ として知られており、数千のユーザーがいる実際のサイトでは[極めて不都合](http://catb.org/jargon/html/B/Bad-Thing.html)です。

emailカラムにインデックスを追加することで、この問題を解決することができます。データベースのインデックスを理解するためには、本の索引との類似性を考えるとよいでしょう。索引のない本では、渡された言葉 (例えば、"foobar") が出てくる箇所をすべて見つけるためには、ページを端から順にめくって最後まで探す必要があります (紙バージョンの全表スキャン)。しかし索引のある本であれば、"foobar"を含むすべてのページを索引の中から探すだけで済みます。データベースのインデックスも本質的には本の索引と同じように動作します。

emailインデックスを追加すると、データモデリングの変更が必要になります。Railsでは ([6.1.1](/chapters/modeling_users?version=5.1#sec-database_migrations)で見たように) マイグレーションでインデックスを追加します。[6.1.1](/chapters/modeling_users?version=5.1#sec-database_migrations)で、Userモデルを生成すると自動的に新しいマイグレーションが作成されたことを思い出してください ([リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration))。今回の場合は、既に存在するモデルに構造を追加するので、次のように`migration`ジェネレーターを使ってマイグレーションを直接作成する必要があります。
```sh
$ rails generate migration add_index_to_users_email
```
ユーザー用のマイグレーションと異なり、メールアドレスの一意性のマイグレーションは未定義になっています。[リスト6.29](/chapters/modeling_users?version=5.1#code-email_uniqueness_index)のように定義を記述する必要があります[16](#cha-6_footnote-16) 。

リスト 6.29: メールアドレスの一意性を強制するためのマイグレーション `db/migrate/[timestamp]_add_index_to_users_email.rb`
```ruby
class AddIndexToUsersEmail < ActiveRecord::Migration[5.1]
  def change
    add_index :users, :email, unique: true
  end
end
```

上のコードでは、`users`テーブルの`email`カラムにインデックスを追加するために`add_index`というRailsのメソッドを使っています。インデックス自体は一意性を強制しませんが、オプションで`unique: true`を指定することで強制できるようになります。

最後に、データベースをマイグレートします。
```sh
$ rails db:migrate
```
(上のコマンドが失敗した場合は、実行中のサンドボックスのコンソールセッションを終了してみてください。そのセッションがデータベースをロックしてマイグレーションを妨げている可能性があります。)

この時点では、テストDB用のサンプルデータが含まれているfixtures内で一意性の制限が保たれていないため、テストは **red** になります。つまり、[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)でユーザー用のfixtureが自動的に生成されていましたが、ここのメールアドレスが一意になっていないことが原因です ([リスト6.30](/chapters/modeling_users?version=5.1#code-default_fixtures)) (実はこのデータはいずれも_有効では_ありませんが、fixture内のサンプルデータはバリデーションを通っていなかったので今まで問題にはなっていなかっただけでした)。

リスト 6.30: Userのデフォルトfixture **red** `test/fixtures/users.yml`
```yml
# Read about fixtures at http://api.rubyonrails.org/classes/ActiveRecord/
# FixtureSet.html

one:
  name: MyString
  email: MyString

two:
  name: MyString
  email: MyString
```
また、このfixtureは[第8章](/chapters/basic_login?version=5.1#cha-basic_login)になるまで使わない予定なので、今のところはこれらのデータを削除しておき、ユーザー用のfixtureファイルを空にしておきましょう ([リスト6.31](/chapters/modeling_users?version=5.1#code-empty_fixtures))。

リスト 6.31: 空のfixtureファイル **green** `test/fixtures/users.yml`
```yml
# 空にする (既存のコードは削除する)
```
これで1つの問題が解決されましたが、メールアドレスの一意性を保証するためには、もう1つやらなければならないことがあります。それは、いくつかのデータベースのアダプタが、常に大文字小文字を区別するインデックス を使っているとは限らない問題への対処です。例えば、Foo@ExAMPle.Comとfoo@example.comが別々の文字列だと解釈してしまうデータベースがありますが、私達のアプリケーションではこれらの文字列は同一であると解釈されるべきです。この問題を避けるために、今回は「データベースに保存される直前にすべての文字列を小文字に変換する」という対策を採ります。例えば"Foo@ExAMPle.CoM"という文字列が渡されたら、保存する直前に"foo@example.com"に変換してしまいます。これを実装するためにActive Recordの[_コールバック (callback)_](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)) メソッドを利用します。このメソッドは、ある特定の時点で呼び出されるメソッドです。今回の場合は、オブジェクトが保存される時点で処理を実行したいので、`before_save`というコールバックを使います。これを使って、ユーザーをデータベースに保存する前にemail属性を強制的に小文字に変換します[17](#cha-6_footnote-17) 。作成したコードを[リスト6.32](/chapters/modeling_users?version=5.1#code-email_downcase)に示します。(本チュートリアルで初めて紹介したテクニックですが、このテクニックについては[11.1](/chapters/account_activation?version=5.1#sec-account_activations_resource)でもう一度取り上げます。そこではコールバックを定義するときに_メソッドを参照する_という慣習について説明します。)

リスト 6.32: email属性を小文字に変換してメールアドレスの一意性を保証する **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  before_save { self.email = email.downcase }
  validates :name,  presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
end
```

[リスト6.32](/chapters/modeling_users?version=5.1#code-email_downcase)のコードは、`before_save`コールバックにブロックを渡してユーザーのメールアドレスを設定します。設定されるメールアドレスは、現在の値をStringクラスの`downcase`メソッドを使って小文字バージョンにしたものです (メールアドレスの小文字化に対するテストは、演習[6.2.5.1](/chapters/modeling_users?version=5.1#sec-exercises_uniqueness_validation)に回します)。

また、[リスト6.32](/chapters/modeling_users?version=5.1#code-email_downcase)では次のように書くこともできましたが、

self.email = self.email.downcase

Userモデルの中では右式の`self`を省略できるので、今回は次のように書きました (ちなみにこの`self`は現在のユーザーを指します)。

self.email = email.downcase

実は[4.4.2](/chapters/rails_flavored_ruby?version=5.1#sec-a_class_of_our_own)の`palindrome`内で`reverse`メソッドを使っていたときも、同様のケースであったことを思い出してください。そのときと同様で、左式では`self`を省略することは_できません_。したがって、

email = email.downcase

と書くとうまく動きません。(このトピックについては、[9.1](/chapters/advanced_login?version=5.1#sec-remember_me)でより深く解説していきます。)

これで、先に述べたアリスのシナリオはうまくいくようになります。データベースは、最初のリクエストに基づいてユーザーのレコードを保存しますが、2度目の保存は一意性の制約に反するので拒否します(Railsのログにエラーが出力されますが、害は生じません)。さらに、インデックスをemail属性に追加したことで、[6.1.4](/chapters/modeling_users?version=5.1#sec-finding_user_objects)で挙げた2番目の目標である「多数のデータがあるときの検索効率を向上させる」も達成されました。これは、`email`属性にインデックスを付与したことによって、メールアドレスからユーザーを引くときに全表スキャンを使わずに済むようになったためです ([コラム6.2](/chapters/modeling_users?version=5.1#aside-database_indices))。

#### [演習](#sec-exercises_uniqueness_validation)

1.  [リスト6.33](/chapters/modeling_users?version=5.1#code-email_downcase_test)のように、メールアドレスを小文字にするテストを[リスト6.26](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_case_insensitive_test)に追加してみましょう。ちなみに追加するテストコードでは、データベースの値に合わせて更新する`reload`メソッドと、値が一致しているかどうか確認する`assert_equal`メソッドを使っています。[リスト6.33](/chapters/modeling_users?version=5.1#code-email_downcase_test)のテストがうまく動いているか確認するためにも、`before_save`の行をコメントアウトして **red**になることを、また、コメントアウトを解除すると **green**になることを確認してみましょう。
2.  テストスイートの実行結果を確認しながら、`before_save`コールバックを`email.downcase!`に書き換えてみましょう。_ヒント_: メソッドの末尾に`!`を付け足すことにより、`email`属性を直接変更できるようになります ([リスト6.34](/chapters/modeling_users?version=5.1#code-downcase_bang))。

リスト 6.33: [リスト6.32](/chapters/modeling_users?version=5.1#code-email_downcase)のメールアドレスの小文字化に対するテスト `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com")
  end
  .
  .
  .
  test "email addresses should be unique" do
    duplicate_user = @user.dup
    duplicate_user.email = @user.email.upcase
    @user.save
    assert_not duplicate_user.valid?
  end

  test "email addresses should be saved as lower-case" do
    mixed_case_email = "Foo@ExAMPle.CoM"
    @user.email = mixed_case_email
    @user.save
    assert_equal mixed_case_email.downcase, @user.reload.email
  end
end
```

リスト 6.34: もう１つのコールバック処理の実装方法 **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  before_save { email.downcase! }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
end
```

[6.3 セキュアなパスワードを追加する](/chapters/modeling_users?version=5.1#sec-adding_a_secure_password)
----------------------------------------------------------------------------------------

ユーザー属性の「名前」と「メールアドレス」に対してバリデーションを追加したので、最後の砦である「セキュアなパスワード」に取り掛かります。セキュアパスワードという手法では、各ユーザーにパスワードとパスワードの確認を入力させ、それを (そのままではなく) _ハッシュ化_したものをデータベースに保存します。いきなりハッシュ化と言われると少し困惑してしまうかもしれません。[4.3.3](/chapters/rails_flavored_ruby?version=5.1#sec-hashes_and_symbols)では_ハッシュ_とはRubyのデータ構造であると説明しましたが、今回の「ハッシュ化」とはそういった構造ではなく、[ハッシュ関数](http://en.wikipedia.org/wiki/Hash_function)を使って、入力されたデータを元に戻せない (不可逆な) データにする処理を指します。なお、このハッシュ化されたパスワードは、[第8章](/chapters/basic_login?version=5.1#cha-basic_login)のログイン機構でユーザーを_認証 (authenticate)_ する際に利用します。

ユーザーの認証は、パスワードの送信、ハッシュ化、データベース内のハッシュ化された値との比較、という手順で進んでいきます。比較の結果が一致すれば、送信されたパスワードは正しいと認識され、そのユーザーは認証されます。ここで、生のパスワードではなく、ハッシュ化されたパスワード同士を比較していることに注目してください。こうすることで、生のパスワードをデータベースに保存するという危険なことをしなくてもユーザーを認証できます。これで、仮にデータベースの内容が盗まれたり覗き見されるようなことがあっても、パスワードの安全性が保たれます。

### [6.3.1 ハッシュ化されたパスワード](/chapters/modeling_users?version=5.1#sec-a_hashed_password)

[解説動画](https://railstutorial.jp/trial?utm_source=tutorial&utm_medium=text&utm_campaign=screencast_trial&utm_content=a_hashed_password)「第6章 後編: 9. パスワードについて」から詳しく解説

セキュアなパスワードの実装は、`has_secure_password`というRailsのメソッドを呼び出すだけでほとんど終わってしまいます。このメソッドは、Userモデルで次のように呼び出せます。
```ruby
class User < ApplicationRecord
  .
  .
  .
  has_secure_password
end
```
上のようにモデルにこのメソッドを追加すると、次のような機能が使えるようになります。

*   セキュアにハッシュ化したパスワードを、データベース内の`password_digest`という属性に保存できるようになる。
*   2つのペアの仮想的な属性 (`password`と`password_confirmation`) が使えるようになる。また、存在性と値が一致するかどうかのバリデーションも追加される[18](#cha-6_footnote-18) 。
*   `authenticate`メソッドが使えるようになる (引数の文字列がパスワードと一致するとUserオブジェクトを、間違っていると`false`を返すメソッド) 。

この魔術的な`has_secure_password`機能を使えるようにするには、1つだけ条件があります。それは、モデル内に`password_digest`という属性が含まれていることです。ちなみに_digest_という言葉は、[暗号化用ハッシュ関数](https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%AD%A6%E7%9A%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0)という用語が語源です。したがって、今回の用途では_ハッシュ化されたパスワード_と_暗号化されたパスワード_は類義語となります[19](#cha-6_footnote-19) 。今回はUserモデルで使うので、Userのデータモデルは次の図のようになります ([図6.8](/chapters/modeling_users?version=5.1#fig-user_model_password_digest))。

図 6.8: Userモデルに`password_digest`属性を追加する

[図6.8](/chapters/modeling_users?version=5.1#fig-user_model_password_digest)のようなデータモデルにするために、まずは`password_digest`カラム用の適切なマイグレーションを生成します。マイグレーション名は自由に指定できますが、次に示すように、末尾を`to_users`にしておくことをオススメします。こうしておくと、`users`テーブルにカラムを追加するマイグレーションがRailsによって自動的に作成されるからです。`add_password_digest_to_users`というマイグレーションファイルを生成するためには、次のコマンドを実行します。
```sh
$ rails generate migration add_password_digest_to_users password_digest:string
```
上のコマンドでは`password_digest:string`という引数を与えて、今回必要になる属性名と型情報を渡しています。[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)で`users`テーブルを最初に生成するとき、`name:string`や`email:string`といった引数を与えていたことを思い出してください。そのときと同様に`password_digest:string`という引数を与えることで、完全なマイグレーションを生成するための十分な情報をRailsに与えることができます ([リスト6.35](/chapters/modeling_users?version=5.1#code-password_migration))。

リスト 6.35: `password_digest`カラムを追加するマイグレーション `db/migrate/[timestamp]_add_password_digest_to_users.rb`
```ruby
class AddPasswordDigestToUsers < ActiveRecord::Migration[5.1]
  def change
    add_column :users, :password_digest, :string
  end
end
```

[リスト6.35](/chapters/modeling_users?version=5.1#code-password_migration)では、`add_column`メソッドを使って`users`テーブル`password_digest`カラムを追加しています。これを適用させるには、データベースでマイグレーションを実行します。
```sh
$ rails db:migrate
```
また、`has_secure_password`を使ってパスワードをハッシュ化するためには、最先端のハッシュ関数である[bcrypt](http://en.wikipedia.org/wiki/Bcrypt)が必要になります。パスワードを適切にハッシュ化することで、たとえ攻撃者によってデータベースからパスワードが漏れてしまった場合でも、Webサイトにログインされないようにできます。サンプルアプリケーションで`bcrypt`を使うために、`bcrypt` gemを`Gemfile`に追加します ([リスト6.36](/chapters/modeling_users?version=5.1#code-bcrypt_ruby))[20](#cha-6_footnote-20) 。

リスト 6.36: `bcrypt`を`Gemfile`に追加する `Gemfile`
```Gemfile
source 'https://rubygems.org'

gem 'rails',          '5.1.6'
gem 'bcrypt',         '3.1.12'
.
.
.
```
次に、いつものように`bundle install`を実行します。
```sh
$ bundle install
```
### [6.3.2 ユーザーがセキュアなパスワードを持っている](/chapters/modeling_users?version=5.1#sec-has_secure_password)

Userモデルに`password_digest`属性を追加し、Gemfileにbcryptを追加したことで、ようやくUserモデル内で`has_secure_password`が使えるようになりました ([リスト6.37](/chapters/modeling_users?version=5.1#code-has_secure_password))。

リスト 6.37: Userモデルに`has_secure_password`を追加する **red** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
end
```

[リスト6.37](/chapters/modeling_users?version=5.1#code-has_secure_password)で **red**と示されている、テストが落ちるようになったはずです。コマンドラインからテストを実行して確認してみてください。

リスト 6.38: **red**
```sh
$ rails test
```
テストが失敗する理由は、[6.3.1](/chapters/modeling_users?version=5.1#sec-a_hashed_password)で触れたように`has_secure_password`には、仮想的な`password`属性と`password_confirmation`属性に対してバリデーションをする機能も(強制的に)追加されているからです。しかし[リスト6.26](/chapters/modeling_users?version=5.1#code-validates_uniqueness_of_email_case_insensitive_test)のテストでは、`@user` 変数にこのような値がセットされておりません。
```ruby
def setup
  @user = User.new(name: "Example User", email: "user@example.com")
end
```
テストをパスさせるために、[リスト6.39](/chapters/modeling_users?version=5.1#code-test_with_password_confirmation)のようにパスワードとパスワード確認の値を追加します。

リスト 6.39: パスワードとパスワード確認を追加する **green** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com",
                     password: "foobar", password_confirmation: "foobar")
  end
  .
  .
  .
end
```

`setup`メソッド内の１行目の末尾で、カンマ `,` を追加している点に注意してください。これはRubyの文法的に必須となるカンマです ([4.3.3](/chapters/rails_flavored_ruby?version=5.1#sec-hashes_and_symbols))。試しにこのカンマを消してみると、_文法エラー (Syntax Error)_ と表示されるはずです。逆に言えば、本書を進めていく途中で文法エラーが表示された場合、どこかしらの文法が間違っているということになります。今後、エラーが出たときに動じないために、どんなときにどんなエラーが発生するのかを覚えていくと良いでしょう ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。

話を戻して、上の変更でテストが **green**になるはずです。

リスト 6.40: **green**
```sh
$ rails test
```
Userモデルに対して`has_secure_password`を追加する利点は[6.3.4](/chapters/modeling_users?version=5.1#sec-creating_and_authenticating_a_user)で少しだけ説明しますが、 その前に、パスワードの最小文字数を設定する方法について説明します。

#### [演習](#sec-exercises_has_secure_password)

1.  この時点では、userオブジェクトに有効な名前とメールアドレスを与えても、`valid?`で失敗してしまうことを確認してみてください。
2.  なぜ失敗してしまうのでしょうか? エラーメッセージを確認してみてください。

### [6.3.3 パスワードの最小文字数](/chapters/modeling_users?version=5.1#sec-minimum_password_standards)

パスワードを簡単に当てられないようにするために、パスワードの最小文字数を設定しておくことは一般に実用的です。[Railsでパスワードの長さを設定する方法](http://lmgtfy.com/?q=rails+enforce+password+strength)はたくさんありますが、今回は簡潔にパスワードが空でないことと最小文字数 (6文字) の2つを設定しましょう。パスワードの長さが6文字以上であることを検証するテストを、次の[リスト6.41](/chapters/modeling_users?version=5.1#code-minimum_password_length_test)に示します。

リスト 6.41: パスワードの最小文字数をテストする **red** `test/models/user_test.rb`
```ruby
require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com",
                     password: "foobar", password_confirmation: "foobar")
  end
  .
  .
  .
  test "password should be present (nonblank)" do
    @user.password = @user.password_confirmation = " " * 6
    assert_not @user.valid?
  end

  test "password should have a minimum length" do
    @user.password = @user.password_confirmation = "a" * 5
    assert_not @user.valid?
  end
end
```

ここで、次のような_多重代入 (Multiple Assignment)_ を使っていることに注目してください。
```ruby
@user.password = @user.password_confirmation = "a" * 5
```
これは[リスト6.41](/chapters/modeling_users?version=5.1#code-minimum_password_length_test)で使われていました。`password`と`password_confirmation`に対して同時に代入をしています (このケースでは、[リスト6.14](/chapters/modeling_users?version=5.1#code-length_validation_test)と同じように、文字列の乗算を利用して5文字の文字列を代入しています)。

[リスト6.16](/chapters/modeling_users?version=5.1#code-length_validation)では`maximum`を使ってユーザー名の最大文字数を制限していましたが、これと似たような形式の`minimum`というオプションを使って、最小文字数のバリデーションを実装することができます。

validates :password, length: { minimum: 6 }

また、_空のパスワード_を入力させないために、存在性のバリデーション ([6.2.2](/chapters/modeling_users?version=5.1#sec-presence_validation)) も一緒に追加します。結果として、Userモデルのコードは[リスト6.42](/chapters/modeling_users?version=5.1#code-password_implementation)のようになります。ちなみに`has_secure_password`メソッドは存在性のバリデーションもしてくれるのですが、これは新しくレコードが追加されたときだけに適用される性質を持っています。したがって、例えばユーザーが `' '` (6文字分の空白スペース) といった文字列をパスワード欄に入力して更新しようとすると、バリデーションが適用されずに更新されてしまう問題が発生してしまうのです。

リスト 6.42: セキュアパスワードの完全な実装 **green** `app/models/user.rb`
```ruby
class User < ApplicationRecord
  before_save { self.email = email.downcase }
  validates :name, presence: true, length: { maximum: 50 }
  VALID_EMAIL_REGEX = /A[w+-.]+@[a-zd-.]+.[a-z]+z/i
  validates :email, presence: true, length: { maximum: 255 },
                    format: { with: VALID_EMAIL_REGEX },
                    uniqueness: { case_sensitive: false }
  has_secure_password
  validates :password, presence: true, length: { minimum: 6 }
end
```

この時点では、テストは **green**になるはずです。

リスト 6.43: **green**
```sh
$ rails test:models
```
#### [演習](#sec-exercises_minimum_password_length)

1.  有効な名前とメールアドレスでも、パスワードが短すぎるとuserオブジェクトが有効にならないことを確認してみましょう。
2.  上で失敗した時、どんなエラーメッセージになるでしょうか? 確認してみましょう。

### [6.3.4 ユーザーの作成と認証](/chapters/modeling_users?version=5.1#sec-creating_and_authenticating_a_user)

以上でUserモデルの基本部分が完了しましたので、今度は[7.1](/chapters/sign_up?version=5.1#sec-showing_users)でユーザー情報表示ページを作成するときに備えて、データベースに新規ユーザーを1人作成しましょう。また、Userモデルに`has_secure_password`を追加した効果についても (例えば`authenticate`メソッドの効果なども) 見ていきましょう。

ただしWebからのユーザー登録はまだできない ([第7章](/chapters/sign_up?version=5.1#cha-sign_up)で完成させます) ので、今回はRailsコンソールを使ってユーザーを手動で作成することにしましょう。[6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)で説明した`create`を使いますが、後々実際のユーザーを作成する必要が出てくるので、今回はサンドボックス環境は_使いません_。したがって、今回作成したユーザーを保存すると、データベースに反映されます。それでは、まず`rails console`コマンドを実行してセッションを開始し、次に有効な名前・メールアドレス・パスワード・パスワード確認を渡してユーザーを作成してみましょう。
```ruby
$ rails console
>> User.create(name: "Michael Hartl", email: "mhartl@example.com", password: "foobar", password_confirmation: "foobar")
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2016-05-23 20:36:46", updated_at: "2016-05-23 20:36:46", password_digest: "$2a$10$xxucoRlMp06RLJSfWpZ8hO8Dt9AZXlGRi3usP3njQg3...">
```
うまくデータベースに保存されたかどうかを確認するために、開発環境用のデータベースを[DB Browser for SQLite](http://sqlitebrowser.org/)で開き、`users`テーブルの中身を見てみましょう ([図6.9](/chapters/modeling_users?version=5.1#fig-sqlite_user_row))[21](#cha-6_footnote-21) 。もしクラウドIDEを使っている場合は、データベースのファイルをダウンロードして開いてください ([図6.5](/chapters/modeling_users?version=5.1#fig-sqlite_download))。このとき、先ほど定義したUserモデルの属性 ([図6.8](/chapters/modeling_users?version=5.1#fig-user_model_password_digest)) に対応したカラムがあることにも注目しておいてください。

図 6.9: SQLiteデータベース`db/development.sqlite3`に登録されたユーザーの行

コンソールに戻って`password_digest`属性を参照してみると、[リスト6.42](/chapters/modeling_users?version=5.1#code-password_implementation)の`has_secure_password`の効果を確認できます。
```ruby
>> user = User.find_by(email: "mhartl@example.com")
>> user.password_digest
=> "$2a$10$xxucoRlMp06RLJSfWpZ8hO8Dt9AZXlGRi3usP3njQg3yOcVFzb6oK"
```
これは、Userオブジェクトを作成したときに、`"foobar"`という文字列がハッシュ化された結果です。bcryptを使って生成されているので、この文字列から元々のパスワードを導出することは、コンピュータを使っても非現実的です[22](#cha-6_footnote-22) 。

また[6.3.1](/chapters/modeling_users?version=5.1#sec-a_hashed_password)で説明したように、`has_secure_password`をUserモデルに追加したことで、そのオブジェクト内で`authenticate`メソッドが使えるようになっています。このメソッドは、引数に渡された文字列 (パスワード) をハッシュ化した値と、データベース内にある`password_digest`カラムの値を比較します。試しに、先ほど作成したuserオブジェクトに対して間違ったパスワードを与えてみましょう。
```ruby
>> user.authenticate("not_the_right_password")
false
>> user.authenticate("foobaz")
false
```
間違ったパスワードを与えた結果、`user.authenticate`が`false`を返したことがわかります。次に、正しいパスワードを与えてみましょう。今度は`authenticate`がそのユーザーオブジェクトを返すようになります。
```ruby
>> user.authenticate("foobar")
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2016-05-23 20:36:46", updated_at: "2016-05-23 20:36:46", password_digest: "$2a$10$xxucoRlMp06RLJSfWpZ8hO8Dt9AZXlGRi3usP3njQg3...">
```
[第8章](/chapters/basic_login?version=5.1#cha-basic_login)では、この`authenticate`メソッドを使ってログインする方法を解説します。なお、`authenticate`がUserオブジェクトを返すことは重要ではなく、返ってきた値の論理値が`true`であることが重要です。[4.2.3](/chapters/rails_flavored_ruby?version=5.1#sec-objects_and_message_passing)で紹介した、`!!`でそのオブジェクトが対応する論理値オブジェクトに変換できることを思い出してください。この性質を利用すると、`user.authenticate`がいい感じに仕事をしてくれるようになります。
```ruby
>> !!user.authenticate("foobar")
=> true
```
#### [演習](#sec-exercises_creating_and_authenticating_a_user)

1.  コンソールを一度再起動して (userオブジェクトを消去して)、このセクションで作ったuserオブジェクトを検索してみてください。
2.  オブジェクトが検索できたら、名前を新しい文字列に置き換え、`save`メソッドで更新してみてください。うまくいきませんね...、なぜうまくいかなかったのでしょうか?
3.  今度は[6.1.5](/chapters/modeling_users?version=5.1#sec-updating_user_objects)で紹介したテクニックを使って、`user`の名前を更新してみてください。

[6.4 最後に](/chapters/modeling_users?version=5.1#sec-modeling_users_conclusion)
-----------------------------------------------------------------------------

この章では、ゼロからUserモデルを作成し、そこにname属性やemail属性、パスワード属性を加えました。また、それぞれの値を制限する多くの重要なバリデーションも追加しました。さらに、渡されたパスワードをセキュアに認証できる機能も実装しました。たった12行でここまでの機能が実装できたことは、Railsの注目に値する特長でもあります。

次の[第7章](/chapters/sign_up?version=5.1#cha-sign_up)では、ユーザーを作成するためのユーザー登録フォームを作成し、各ユーザーの情報を表示するためのページも作成します。[第8章](/chapters/basic_login?version=5.1#cha-basic_login)では、[6.3](/chapters/modeling_users?version=5.1#sec-adding_a_secure_password)の認証システムを利用して、ユーザーが実際にWebサイトにログインできるようにします。

さて、Gitでしばらくコミットしていなかったのであれば、この時点でコミットしておきましょう。

```sh
$ rails test
$ git add -
$ git commit -m "Make a basic User model (including secure passwords)"
```
次にmasterブランチにマージして、リモートにあるリポジトリに対してpushします。

```sh
$ git checkout master
$ git merge modeling-user
$ git push
```
なお、本番環境でUserモデルを使うためには、`heroku run`コマンドを使ってHeroku上でもマイグレーションを走らせる必要があります。

```sh
$ rails test
$ git push heroku
$ heroku run rails db:migrate
```
うまくできたかどうかは、本番環境のコンソールに接続することで確認できます。
```ruby
$ heroku run rails console --sandbox
>> User.create(name: "Michael Hartl", email: "michael@example.com",
>>             password: "foobar", password_confirmation: "foobar")
=> #<User id: 1, name: "Michael Hartl", email: "michael@example.com",
created_at: "2016-05-23 20:54:41", updated_at: "2016-05-23 20:54:41",
password_digest: "$2a$10$74xFguZRoTZBXTUqs1FjpOf3OoLhrvgxC2wlohtTEcH...">
```
### [6.4.1 本章のまとめ](/chapters/modeling_users?version=5.1#sec-modeling_users_what_we_learned_in_this_chapter)

*   マイグレーションを使うことで、アプリケーションのデータモデルを修正することができる
*   Active Recordを使うと、データモデルを作成したり操作したりするための多数のメソッドが使えるようになる
*   Active Recordのバリデーションを使うと、モデルに対して制限を追加することができる
*   よくあるバリデーションには、存在性・長さ・フォーマットなどがある
*   正規表現は謎めいて見えるが非常に強力である
*   データベースにインデックスを追加することで検索効率が向上する。また、データベースレベルでの一意性を保証するためにも使われる
*   `has_secure_password`メソッドを使うことで、モデルに対してセキュアなパスワードを追加することができる


[1.](#cha-6_footnote-ref-1) この名前の由来は「[Active Record Pattern](https://ja.wikipedia.org/wiki/Active_Record)」です。Martin Fowler著「_エンタープライズ アプリケーションアーキテクチャパターン_ 」で特定および命名されました。

[2.](#cha-6_footnote-ref-2) 「エスキューエル」と発音しますが、「スィークゥエル」もよく使われます。ちなみに文中から執筆者がどちらを好んでいるかを判別する方法があります。もし “an SQL database” と書いていれば前者を、“a SQL database” と書いていれば後者を好んでいるといった具合です。ちなみに私 (筆者) は後者の呼び方を好んでいます。

[3.](#cha-6_footnote-ref-3) メールアドレスをユーザー名にしたことで、ユーザー同士で通信できるように拡張できる可能性が開かれます ([第11章](/chapters/account_activation?version=5.1#cha-account_activation)と[第12章](/chapters/password_reset?version=5.1#cha-password_reset))。

[4.](#cha-6_footnote-ref-4) `t`オブジェクトが具体的に何をしているのかを正確に知る必要はありませんので、どうか心配しないでください。_抽象化レイヤ_の素晴らしい点は、それが何であるかを知る必要がないという点です。安心して`t`オブジェクトに仕事を任せればよいのです。

[5.](#cha-6_footnote-ref-5) 公式には「エスキューエライト (ess-cue-ell-ite)」と発音しますが、(本来は誤りとされている)「スィークゥエライト (sequel-ite)」もよく使われています。

[6.](#cha-6_footnote-ref-6) この唯一の例外が[14.3.3](/chapters/following_users?version=5.1#sec-scopes_subselects_and_a_lambda)に記されています。

[7.](#cha-6_footnote-ref-7) このタイムスタンプは[協定世界時 (UTC)](https://ja.wikipedia.org/wiki/%E5%8D%94%E5%AE%9A%E4%B8%96%E7%95%8C%E6%99%82) に合わせてあります。これは[グリニッジ標準時 (GMT)](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AA%E3%83%8B%E3%83%83%E3%82%B8%E6%A8%99%E6%BA%96%E6%99%82) と同様、標準時間として使われます。「NIST時刻と周波数FAQ」によると、**問:** 協定世界時 (Coordinated Universal Time) の略称がCUTではなくUTCなのはなぜですか 。**答え:** 協定世界時システムは、1970年に国際電気通信連合 (ITU) の技術専門家の国際諮問グループによって考案されました。このときITUは、混乱を最小限にとどめるために、略称を1つだけにしたいと考えました。このとき、英語式のCUTもフランス式のTUCも満場一致とならず、両者の妥協案としてUTCという略語が採用されました。

[8.](#cha-6_footnote-ref-8) 例外と例外ハンドリングは、Rubyの高度なテーマです。本書では例外についてこれ以上言及しません。しかし例外が重要なものであることも確かなので、[14.4.2](/chapters/following_users?version=5.1#sec-guide_to_further_resources)で紹介するRubyの推薦図書で例外について詳しく学ぶことをオススメします。

[9.](#cha-6_footnote-ref-9) `update_attributes`メソッドは`update`メソッドのエイリアスですが、バリデーションを省略して単一属性を変更する`update_attribute`メソッドとの違いを明確にするために、筆者は長いメソッド名の方を好んで使っています。

[10.](#cha-6_footnote-ref-10) 今後、コンソールコマンドの出力は、特に教育的効果が高いと思える場合 (ここでの`User.new`の場合など) を除いて省略いたします。

[11.](#cha-6_footnote-ref-11) 驚いたことに公式標準によると、例えば`"Michael Hartl"@example.com`のようなクォートとスペースを使ったメールアドレスも有効なのだそうです。まったく馬鹿げています。

[12.](#cha-6_footnote-ref-12) [表6.1](/chapters/modeling_users?version=5.1#table-valid_email_regex)の正規表現の説明における「文字」は、実は「小文字のみ」が対象になっていることに注意してください。ただし、正規表現の末尾に`i`オプションを追加してあるので、大文字小文字が区別されずにマッチするようになっています。

[13.](#cha-6_footnote-ref-13) もしRubularのサービスが便利だと思ったら、素晴らしい功績を残した開発者である[Michael Lovitt](http://bit.ly/donate-to-rubular)さんに報いるために[Rubularへの寄付](http://lovitt.net/)をお勧めします。

[14.](#cha-6_footnote-ref-14) この節の冒頭で簡単に紹介したように、この目的のために用意されたテスト専用のデータベース`db/test.sqlite3`があります。

[15.](#cha-6_footnote-ref-15) 技術的には、メールアドレスのうちドメイン名部分だけが (本当は) 大文字小文字を区別しません。_foo@bar.com_は、本来は_Foo@bar.com_とは別のアドレスです。ただし現実的には、[about.com](http://email.about.com/od/emailbehindthescenes/f/email_case_sens.htm)でも指摘されているように、メールアドレスの大文字小文字を区別することを前提にするのはまずい方法です。「メールアドレスの大文字小文字を区別すると、果てしない混乱と相互運用性の問題とひどい頭痛が発生する。メールアドレスの入力時に大文字小文字の区別を要求するのは賢い方法とは言えない。現実には、メールアドレスの大文字小文字の区別を強制するメールサービスやISPはめったに存在しない。メールアドレスのすべての文字を大文字にするなど、受信者のメールアドレスが誤って入力されていれば、メールは返送されるだけだ。」Riley Mosesによるご指摘に感謝いたします。

[16.](#cha-6_footnote-ref-16) もちろん、[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)の`users`テーブル用のマイグレーションファイルを単に編集することも可能なのですが、その場合ロールバックが必要となり、マイグレーションが戻ってしまいます。データモデルの変更が必要になったらその都度マイグレーションを行うのがRails流です。

[17.](#cha-6_footnote-ref-17) 他にどんなコールバックがあるのか知りたい場合は、[Rails APIのコールバック](http://api.rubyonrails.org/v5.1.6/classes/ActiveRecord/Callbacks.html) (英語) を読んでみてください。

[18.](#cha-6_footnote-ref-18) ここでいう「_仮想的 (Virtual)_」とは、Userモデルのオブジェクトからは存在しているように見えるが、データベースには対応するカラムが存在しない、という意味です。

[19.](#cha-6_footnote-ref-19) ハッシュ化されたパスワードは、_暗号化されたパスワード_とよく誤解されがちです。例えば、(実は本書の第1版や第2版でも間違っていたのですが) `has_secure_password`の[ソースコード](https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb)でもこの手の間違いがあります。というのも、専門用語としての「暗号」というのは、設計上_元に戻す_ことができることを指します (暗号化できるという文には、_復号もできる_というニュアンスが含まれます)。一方、「パスワードのハッシュ化」では_元に戻せない (不可逆)_ という点が重要になります。したがって、「計算量的に元のパスワードを復元するのは困難である」という点を強調するために、暗号化ではなくハッシュ化という用語を使っています。この間違った用語について指摘してくれたAndy Philipsに感謝します。(訳注: さらに詳しい仕組みを知りたい方には [@hyuki](https://twitter.com/hyuki) さんの著作「[暗号技術入門](http://www.hyuki.com/cr/)」が分かりやすくてオススメです。)

[20.](#cha-6_footnote-ref-20) これまでと同様に、Gemfileで指定した各gemのバージョンは[gemfiles-4th-ed.railstutorial.org](http://gemfiles-4th-ed.railstutorial.org/)と一致している必要があります。もしうまく次に進めない場合はチェックしてみてください。

[21.](#cha-6_footnote-ref-21) もしうまくいかなくても、いつでもデータベースの中身をリセットできるので安心してください。リセットしたい場合は、次の手順を踏んでください。

1.  まずはコンソールから脱出してください (Ctrl-C)
2.  次に、コマンドラインから`$ rm -f development.sqlite3`を実行してデータベースの中身を削除してください ([第7章](/chapters/sign_up?version=5.1#cha-sign_up)でもっと便利なメソッドを紹介します)
3.  `$ rails db:migrate`コマンドを実行して、もう一度マイグレーションを走らせてください
4.  再度Railsコンソールを開き、コンソール上での作業をもう一度やり直してみてください

[22.](#cha-6_footnote-ref-22) 設計上、bcryptアルゴリズムではハッシュ化する前に[_ソルト化されたハッシュ (Salted Hash)_](https://ja.wikipedia.org/wiki/%E3%83%91%E3%82%B9%E3%83%AF%E3%83%BC%E3%83%89%E3%82%AF%E3%83%A9%E3%83%83%E3%82%AF#.E3.82.BD.E3.83.AB.E3.83.88) を追加しています。これにより、[辞書攻撃 (Dictionary Attacks)](https://ja.wikipedia.org/wiki/%E8%BE%9E%E6%9B%B8%E6%94%BB%E6%92%83) や[レインボーテーブル攻撃 (Rainbow Table Attacks)](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%A4%E3%83%B3%E3%83%9C%E3%83%BC%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB) といったタイプの攻撃を防ぐことができます。
