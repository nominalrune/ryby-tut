[第13章ユーザーのマイクロポスト](/chapters/user_microposts?version=5.1#cha-user_microposts)
=============================================================================

サンプルアプリケーションのコア部分を開発するために、これまでにユーザー、セッション、アカウント有効化、パスワードリセットという４つのリソースについて見てきました。そして、これらのうち「ユーザー」というリソースだけが、Active Recordによってデータベース上のテーブルと紐付いています。全ての準備が整った今、ユーザーが短いメッセージを投稿できるようにするためのリソース「_マイクロポスト_」を追加していきます[1](#cha-13_footnote-1) 。[第2章](/chapters/toy_app?version=5.1#cha-a_toy_app)で簡易的なマイクロポスト投稿フォームに触れましたが、この章では、[2.3](/chapters/toy_app?version=5.1#sec-microposts_resource)で記述したMicropostデータモデルを作成し、Userモデルと`has_many`および`belongs_to`メソッドを使って関連付けを行い、さらに、結果を処理し表示するために必要なフォームとその部品を作成します ([13.4](/chapters/user_microposts?version=5.1#sec-micropost_images)で画像のアップロードも実装します)。[第14章](/chapters/following_users?version=5.1#cha-following_users)では、マイクロポストの_フィード_を受け取るために、ユーザーを_フォロー_するという概念を導入し、Twitterのミニクローンを完成させます。

[13.1 Micropostモデル](/chapters/user_microposts?version=5.1#sec-a_micropost_model)
--------------------------------------------------------------------------------

まずはMicropostリソースの最も本質的な部分を表現するMicropostモデルを作成するところから始めましょう。[2.3](/chapters/toy_app?version=5.1#sec-microposts_resource)で作成したモデルと同様に、この新しいMicropostモデルもデータ検証とUserモデルの関連付けを含んでいます。以前のモデルとは違って、今回のマイクロポストモデルは完全にテストされ、デフォルトの_順序_を持ち、また親であるユーザーが破棄された場合には自動的に_破棄_されるようにします。

Git をバージョン管理に使っている場合は、いつものようにトピックブランチを作成しておきましょう。
```sh
$ git checkout -b user-microposts
```
### [13.1.1 基本的なモデル](/chapters/user_microposts?version=5.1#sec-the_basic_model)

Micropostモデルは、マイクロポストの内容を保存する`content`属性と、特定のユーザーとマイクロポストを関連付ける`user_id`属性の2つの属性だけを持ちます。実行した結果のMicropostモデルの構造は[図13.1](/chapters/user_microposts?version=5.1#fig-micropost_model)のようになります。

図 13.1: Micropostデータモデル

[図13.1](/chapters/user_microposts?version=5.1#fig-micropost_model)のモデルでは、マイクロポストの投稿に`String`型ではなく`Text`型を使っている点に注目してください。これは、ある程度の量のテキストを格納するときに使われる型です。`String`型でも255文字までは格納できるため、この型でも[13.1.2](/chapters/user_microposts?version=5.1#sec-micropost_validations)で実装する140文字制限を満たせるのですが、`Text`型の方が表現豊かなマイクロポストを実現できます。例えば、[13.3.2](/chapters/user_microposts?version=5.1#sec-creating_microposts)では投稿フォームにString用のテキストフィールドではなくてText用の_テキストエリア_を使うため、より自然な投稿フォームが実現できます。また、`Text`型の方が将来における柔軟性に富んでいて、例えばいつか国際化をするときに、言語に応じて投稿の長さを調節することもできます。さらに、`Text`型を使っていても本番環境で[パフォーマンスの差は出ません](http://www.postgresql.org/docs/9.1/static/datatype-character.html)[2](#cha-13_footnote-2) 。これらの理由から、デメリットよりもメリットの方が多いので、今回は`Text`型を採用しています。

[リスト6.1](/chapters/modeling_users?version=5.1#code-generate_user_model)でUserモデルを生成したときと同様に、Railsの`generate model`コマンドを使ってMicropostモデルを生成してみます ([リスト13.1](/chapters/user_microposts?version=5.1#code-generate_micropost_model))。

リスト 13.1: Micropostモデルを生成する
```sh
$ rails generate model Micropost content:text user:references
```
上のコマンドを実行すると、[リスト13.2](/chapters/user_microposts?version=5.1#code-micropost_model)に示すMicropostモデルが生成されます。つまり、[6.1.2](/chapters/modeling_users?version=5.1#sec-the_model_file)のときと同様に`ApplicationRecord`を継承したモデルが作られます。ただし、今回は生成されたモデルの中に、ユーザーと１対１の関係であることを表す`belongs_to`のコードも追加されています。これは先ほどのコマンドを実行したときに`user:references`という引数も含めていたからです ([リスト13.1](/chapters/user_microposts?version=5.1#code-generate_micropost_model))。この行の細かな説明については、[13.1.3](/chapters/user_microposts?version=5.1#sec-user_micropost_associations)で行います。

リスト 13.2: 自動生成されたMicropostモデル `app/models/micropost.rb`
```ruby

class Micropost < ApplicationRecord
   belongs_to :user
end
```

[リスト6.2](/chapters/modeling_users?version=5.1#code-users_migration)でデータベースに`users`テーブルを作るマイグレーションを生成したときと同様に、この`generate`コマンドは`microposts`テーブルを作成するためのマイグレーションファイルを生成します ([リスト13.1](/chapters/user_microposts?version=5.1#code-generate_micropost_model))。

Userモデルとの最大の違いは`references`型を利用している点です。これを利用すると、自動的にインデックスと外部キー参照付きの`user_id`カラムが追加され[3](#cha-13_footnote-3) 、UserとMicropostを関連付けする下準備をしてくれます。Userモデルのときと同じで、Micropostモデルのマイグレーションファイルでも`t.timestamps`という行 (マジックカラム) が自動的に生成されています。これにより、 [6.1.1](/chapters/modeling_users?version=5.1#sec-database_migrations)で説明したように`created_at`と`updated_at`というカラムが追加されます ([図 13.1](/chapters/user_microposts?version=5.1#fig-micropost_model))。なお、`created_at`カラムは、[13.1.4](/chapters/user_microposts?version=5.1#sec-ordering_and_dependency)の実装を進めていく上で必要なカラムになります。

リスト 13.3: インデックスが付与されたMicropostのマイグレーション `db/migrate/[timestamp]_create_microposts.rb`
```ruby

class CreateMicroposts < ActiveRecord::Migration[5.1]
  def change
    create_table :microposts do |t|
      t.text :content
      t.references :user, foreign_key: true

      t.timestamps
    end
    add_index :microposts, [:user_id, :created_at]
  end
end
```

ここで、[リスト13.3](/chapters/user_microposts?version=5.1#code-micropost_migration)では`user_id`と`created_at`カラムにインデックスが付与されていることに注目してください ([コラム6.2](/chapters/modeling_users?version=5.1#aside-database_indices))。こうすることで、`user_id`に関連付けられたすべてのマイクロポストを作成時刻の逆順で取り出しやすくなります。

add_index :microposts, [:user_id, :created_at]

また、`user_id`と`created_at`の両方を１つの配列に含めている点にも注目です。こうすることでActive Recordは、_両方_のキーを同時に扱う_複合キーインデックス (Multiple Key Index)_ を作成します。(訳注: 複合キーインデックスは、スタックオーバーフローの[What is a multiple key index?](https://stackoverflow.com/questions/14844780/what-is-a-multiple-key-index)で詳しく解説されています。)

それでは、[リスト13.3](/chapters/user_microposts?version=5.1#code-micropost_migration)をマイグレーションを使って、いつものようにデータベースを更新してみましょう。
```sh
$ rails db:migrate
```
#### [演習](#sec-exercises_the_basic_model)

1.  Railsコンソールで`Micropost.new`を実行し、インスタンスを変数`micropost`に代入してください。その後、`user_id`に最初のユーザーのidを、`content`に "Lorem ipsum" をそれぞれ代入してみてください。この時点では、 `micropost`オブジェクトのマジックカラム (`created_at`と`updated_at`) には何が入っているでしょうか?
2.  先ほど作ったオブジェクトを使って、`micropost.user`を実行してみましょう。どのような結果が返ってくるでしょうか? また、`micropost.user.name`を実行した場合の結果はどうなるでしょうか?
3.  先ほど作った`micropost`オブジェクトをデータベースに保存してみましょう。この時点でもう一度マジックカラムの内容を調べてみましょう。今度はどのような値が入っているでしょうか?

### [13.1.2 Micropostのバリデーション](/chapters/user_microposts?version=5.1#sec-micropost_validations)

基本的なモデルを作成したので、次に要求される制限を実現するためのバリデーションを追加しましょう。Micropostモデルを作成したときに、マイクロポストは投稿したユーザーのid (`user_id`) を持たせるようにしました。これを使って、慣習的に正しくActive Recordの_関連付け_を実装していきます ([13.1.3](/chapters/user_microposts?version=5.1#sec-user_micropost_associations)) が、まずは`Micropost`モデル単体を (テスト駆動開発で) 動くようにしてみます。

Micropostの初期テストはUserモデルの初期テスト ([リスト6.7](/chapters/modeling_users?version=5.1#code-name_presence_test)) と似ています。まずは`setup`のステップで、fixtureのサンプルユーザーと紐付けた新しいマイクロポストを作成しています。次に、作成したマイクロポストが有効かどうかをチェックしてます。最後に、あらゆるマイクロポストはユーザーのidを持っているべきなので、`user_id`の存在性のバリデーションに対するテストも追加します。これらの要素を1つにまとめると、[リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)のようなテストコードになります。

リスト 13.4: 新しいMicropostの有効性に対するテスト **green** `test/models/micropost_test.rb`
```ruby

require 'test_helper'

class MicropostTest < ActiveSupport::TestCase

  def setup
    @user = users(:michael)
    # このコードは慣習的に正しくない
    @micropost = Micropost.new(content: "Lorem ipsum", user_id: @user.id)
  end

  test "should be valid" do
    assert @micropost.valid?
  end

  test "user id should be present" do
    @micropost.user_id = nil
    assert_not @micropost.valid?
  end
end
```

`setup`メソッドの中でコメントしているとおり、マイクロポストを作成するコードは動きますが、慣習的には正しくありません ([13.1.3](/chapters/user_microposts?version=5.1#sec-user_micropost_associations)で修正します)。

元々あるUserモデルのテスト ([リスト6.5](/chapters/modeling_users?version=5.1#code-valid_user_test)) と同じで、[リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)の１つ目のテストでは、_正常な状態かどうかをテスト (sanity check)_ しています。２つ目のテストでは、`user_id`が存在しているかどうか (`nil`ではないか) をテストしています。このテストをパスさせるために、[リスト13.5](/chapters/user_microposts?version=5.1#code-micropost_user_id_validation)で存在性のバリデーションを追加してみましょう。

リスト 13.5: マイクロポストの`user_id`に対する検証 **green** `app/models/micropost.rb`
```ruby

class Micropost < ApplicationRecord
  belongs_to :user
  validates :user_id, presence: true
end
```

ちなみにRails5では、[リスト13.5](/chapters/user_microposts?version=5.1#code-micropost_user_id_validation)のバリデーションを追加しなくても[リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)のテストが成功してしまいます。しかしこれは、[リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)でハイライトした「慣習的な意味で正しくない」というコードを書いた場合でのみ発生します。この部分を「慣習的に正しい」コードで実装すると、`user_id`に対する存在性のバリデーションが期待通りに動きます ([リスト13.12](/chapters/user_microposts?version=5.1#code-micropost_validity_test_idiomatic))。この部分を説明しておきたかったので、先ほどのコメントでハイライトしておきました。

以上の背景を踏まえて、[リスト13.5](/chapters/user_microposts?version=5.1#code-micropost_user_id_validation)のテストが (今のところ) **green**になることを確認してみましょう。

リスト 13.6: **green**
```sh
$ rails test:models
```
次に、マイクロポストの`content`属性に対するバリデーションを追加しましょう ([2.3.2](/chapters/toy_app?version=5.1#sec-putting_the_micro_in_microposts)で紹介した例と同じです)。`user_id`属性と同様に、`content`属性も存在する必要があり、さらにマイクロポストが140文字より長くならないよう制限を加えます (これがマイクロポストを_マイクロ (micro)_ と名付けた理由です)。

[6.2](/chapters/modeling_users?version=5.1#sec-user_validations)でUserモデルにバリデーションを追加したときと同様に、テスト駆動開発でMicropostモデルのバリデーションを追加していきましょう。基本的には、Userモデルのときと同じようなバリデーションを追加しています ([リスト13.7](/chapters/user_microposts?version=5.1#code-micropost_validations_tests))。

リスト 13.7: Micropostモデルのバリデーションに対するテスト **red** `test/models/micropost_test.rb`
```ruby

require 'test_helper'

class MicropostTest < ActiveSupport::TestCase

  def setup
    @user = users(:michael)
    @micropost = Micropost.new(content: "Lorem ipsum", user_id: @user.id)
  end

  test "should be valid" do
    assert @micropost.valid?
  end

  test "user id should be present" do
    @micropost.user_id = nil
    assert_not @micropost.valid?
  end

  test "content should be present" do
    @micropost.content = "   "
    assert_not @micropost.valid?
  end

  test "content should be at most 140 characters" do
    @micropost.content = "a" * 141
    assert_not @micropost.valid?
  end
end
```

[6.2](/chapters/modeling_users?version=5.1#sec-user_validations)と同様で、[リスト13.7](/chapters/user_microposts?version=5.1#code-micropost_validations_tests)ではマイクロポストの長さをテストするために、文字列の乗算を使っています。
```sh
$ rails console
```
> "a" * 10
=> "aaaaaaaaaa"
>> "a" * 141
=> "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

これに対応するアプリケーション側の実装は、Userの`name`用バリデーション ([リスト6.16](/chapters/modeling_users?version=5.1#code-length_validation)) と全く同じです。[リスト13.8](/chapters/user_microposts?version=5.1#code-micropost_validations)に結果を示します。

リスト 13.8: Micropostモデルのバリデーション **green** `app/models/micropost.rb`
```ruby

class Micropost < ApplicationRecord
  belongs_to :user
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

この時点で、全てのテストが **green**になるはずです。

リスト 13.9: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_micropost_validations)

1.  Railsコンソールを開き、`user_id`と`content`が空になっているmicropostオブジェクトを作ってみてください。このオブジェクトに対して`valid?`を実行すると、失敗することを確認してみましょう。また、生成されたエラーメッセージにはどんな内容が書かれているでしょうか?
2.  コンソールを開き、今度は`user_id`が空で`content`が141文字以上のmicropostオブジェクトを作ってみてください。このオブジェクトに対して`valid?`を実行すると、失敗することを確認してみましょう。また、生成されたエラーメッセージにはどんな内容が書かれているでしょうか?

### [13.1.3 User/Micropostの関連付け](/chapters/user_microposts?version=5.1#sec-user_micropost_associations)

Webアプリケーション用のデータモデルを構築するにあたって、個々のモデル間での_関連付け_を十分考えておくことが重要です。今回の場合は、 [2.3.3](/chapters/toy_app?version=5.1#sec-demo_user_has_many_microposts)でも示したように、それぞれのマイクロポストは１人のユーザーと関連付けられ、それぞれのユーザーは (潜在的に) 複数のマイクロポストと関連付けられます。この関連付けを[図13.2](/chapters/user_microposts?version=5.1#fig-micropost_belongs_to_user)と[図13.3](/chapters/user_microposts?version=5.1#fig-user_has_many_microposts)に示します。これらの関連付けを実装するための一環として、Micropostモデルに対するテストを作成し、さらにUserモデルにいくつかのテストを追加します。

図 13.2: MicropostとそのUserは `belongs_to` (1対1) の関係性がある

図 13.3: UserとそのMicropostは `has_many` (1対多) の関係性がある

この節で定義する`belongs_to`/`has_many`関連付けを使うことで、[表13.1](/chapters/user_microposts?version=5.1#table-association_methods)に示すようなメソッドをRailsで使えるようになります。[表13.1](/chapters/user_microposts?version=5.1#table-association_methods)では次のメソッドではなく

Micropost.create
Micropost.create!
Micropost.new

このメソッドになっていることに注意してください。

user.microposts.create
user.microposts.create!
user.microposts.build

これらのメソッドは使うと、紐付いているユーザーを_通して_マイクロポストを作成することができます (慣習的に正しい方法です)。新規のマイクロポストがこの方法で作成される場合、`user_id`は自動的に正しい値に設定されます。この方法を使うと、例えば次のような

@user = users(:michael)
# このコードは慣習的に正しくない
@micropost = Micropost.new(content: "Lorem ipsum", user_id: @user.id)

という書き方 ([リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)) が、次のように書き換えられます。

@user = users(:michael)
@micropost = @user.microposts.build(content: "Lorem ipsum")

(`new`メソッドと同様に、`build`メソッドはオブジェクトを返しますがデータベースには反映されません。) 一度正しい関連付けを定義してしまえば、`@micropost`変数の`user_id`には、関連するユーザーのidが自動的に設定されます。

<table><tbody><tr><td><strong>メソッド</strong></td><td><strong>用途</strong></td></tr><tr><td><code>micropost.user</code></td><td>Micropostに紐付いたUserオブジェクトを返す</td></tr><tr><td><code>user.microposts</code></td><td>Userのマイクロポストの集合をかえす</td></tr><tr><td><code>user.microposts.create(arg)</code></td><td><code>user</code>に紐付いたマイクロポストを作成する</td></tr><tr><td><code>user.microposts.create!(arg)</code></td><td><code>user</code>に紐付いたマイクロポストを作成する (失敗時に例外を発生)</td></tr><tr><td><code>user.microposts.build(arg)</code></td><td><code>user</code>に紐付いた新しいMicropostオブジェクトを返す</td></tr><tr><td><code>user.microposts.find_by(id: 1)</code></td><td><code>user</code>に紐付いていて、<code>id</code>が<code>1</code>であるマイクロポストを検索する</td></tr></tbody></table>

表 13.1: user/micropost関連メソッドのまとめ

`@user.microposts.build`のようなコードを使うためには、 UserモデルとMicropostモデルをそれぞれ更新して、関連付ける必要があります。Micropostモデルの方では、`belongs_to :user`というコードが必要になるのですが、これは [リスト13.10](/chapters/user_microposts?version=5.1#code-micropost_belongs_to_user)のマイグレーションによって自動的に生成されているはずです ([リスト13.10](/chapters/user_microposts?version=5.1#code-micropost_belongs_to_user))。一方、Userモデルの方では、`has_many :microposts`と追加する必要があります。ここは自動的に生成されないので、手動で追加してください ([リスト13.11](/chapters/user_microposts?version=5.1#code-user_has_many_microposts))。

リスト 13.10: マイクロポストがユーザーに所属する (`belongs_to`) 関連付け **green** `app/models/micropost.rb`
```ruby

class Micropost < ApplicationRecord
  belongs_to :user
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

リスト 13.11: ユーザーがマイクロポストを複数所有する (`has_many`) 関連付け **green** `app/models/user.rb`
```ruby

class User < ApplicationRecord
  has_many :microposts
  .
  .
  .
end
```

正しく関連付けができたら、[リスト13.4](/chapters/user_microposts?version=5.1#code-micropost_validity_test)の`setup`メソッドを修正して、慣習的に正しくマイクロポストを作成してみます ([リスト13.12](/chapters/user_microposts?version=5.1#code-micropost_validity_test_idiomatic))。

リスト 13.12: 慣習的に正しくマイクロポストを作成する **green** `test/models/micropost_test.rb`
```ruby

require 'test_helper'

class MicropostTest < ActiveSupport::TestCase

  def setup
    @user = users(:michael)
    @micropost = @user.microposts.build(content: "Lorem ipsum")
  end

  test "should be valid" do
    assert @micropost.valid?
  end

  test "user id should be present" do
    @micropost.user_id = nil
    assert_not @micropost.valid?
  end
  .
  .
  .
end
```

もちろん、些細なリファクタリングでしかないので、テストは **green**のままになっているはずです。

リスト 13.13: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_user_micropost_associations)

1.  データベースにいる最初のユーザーを変数`user`に代入してください。そのuserオブジェクトを使って`micropost = user.microposts.create(content: "Lorem ipsum")`を実行すると、どのような結果が得られるでしょうか?
2.  先ほどの演習課題で、データベース上に新しいマイクロポストが追加されたはずです。`user.microposts.find(micropost.id)`を実行して、本当に追加されたのかを確かめてみましょう。また、先ほど実行した`micropost.id`の部分を`micropost`に変更すると、結果はどうなるでしょうか?
3.  `user == micropost.user`を実行した結果はどうなるでしょうか? また、`user.microposts.first == micropost` を実行した結果はどうなるでしょうか? それぞれ確認してみてください。

### [13.1.4 マイクロポストを改良する](/chapters/user_microposts?version=5.1#sec-ordering_and_dependency)

この項では、UserとMicropostの関連付けを改良していきます。具体的には、ユーザーのマイクロポストを特定の_順序_で取得できるようにしたり、マイクロポストをユーザーに_依存させて_、ユーザーが削除されたらマイクロポストも自動的に削除されるようにしていきます。

#### [デフォルトのスコープ](#sec-default_scope)

`user.microposts`メソッドはデフォルトでは読み出しの順序に対して何も保証しませんが、 ブログやTwitterの慣習に従って、作成時間の逆順、つまり最も新しいマイクロポストを最初に表示するようにしてみましょう[4](#cha-13_footnote-4) 。これを実装するためには、_default scope_というテクニックを使います。

この機能のテストは、見せかけの成功に陥りやすい部分で、「アプリケーション側の実装が本当は間違っているのにテストが成功してしまう」という罠があります。正しいテストを書くために、ここではテスト駆動開発で進めていきます。具体的には、まずデータベース上の最初のマイクロポストが、fixture内のマイクロポスト (`most_recent`) と同じであるか検証するテストを書いていきましょう ([リスト13.14](/chapters/user_microposts?version=5.1#code-micropost_order_test))。

リスト 13.14: マイクロポストの順序付けをテストする **red** `test/models/micropost_test.rb`
```ruby

require 'test_helper'

class MicropostTest < ActiveSupport::TestCase
  .
  .
  .
  test "order should be most recent first" do
    assert_equal microposts(:most_recent), Micropost.first
  end
end
```

[リスト13.14](/chapters/user_microposts?version=5.1#code-micropost_order_test)ではマイクロポスト用のfixtureファイルからサンプルデータを読み出しているので、次のfixtureファイルも必要になります ([リスト13.15](/chapters/user_microposts?version=5.1#code-micropost_fixtures))。

リスト 13.15: マイクロポスト用のfixture `test/fixtures/microposts.yml`
```yml
orange:
  content: "I just ate an orange!"
  created_at: <%= 10.minutes.ago %>

tau_manifesto:
  content: "Check out the @tauday site by @mhartl: http://tauday.com"
  created_at: <%= 3.years.ago %>

cat_video:
  content: "Sad cats are sad: http://youtu.be/PKffm2uI4dk"
  created_at: <%= 2.hours.ago %>

most_recent:
  content: "Writing a short test"
  created_at: <%= Time.zone.now %>
```
ここでは埋め込みRubyを使って`created_at`カラムに値をセットしている点に注目してください。このカラムはRailsによって自動的に更新されるため基本的には手動で更新できないのですが、fixtureファイルの中では更新可能になっています。この仕組みを使って意図的に順序を変更しています。例えばファイル内の一番下のサンプルデータは最後に生成されるので最も新しい投稿になるように修正する、といった感じです。多くのシステムでfixtureは上から順に実行されるため、ファイル内の最下部にあるサンプルデータが最後に作成されますが、この振る舞いに依存したテストは書くべきでは無いでしょう。

そこで、実行順序をテストする[リスト13.14](/chapters/user_microposts?version=5.1#code-micropost_order_test)と[リスト13.15](/chapters/user_microposts?version=5.1#code-micropost_fixtures)を追加します。このテストを実行すると **red**になるはずです。

リスト 13.16: **red**
```sh
$ rails test test/models/micropost_test.rb
```
次に、Railsの`default_scope`メソッドを使ってこのテストを成功させます。このメソッドは、データベースから要素を取得したときの、デフォルトの順序を指定するメソッドです。特定の順序にしたい場合は、`default_scope`の引数に`order`を与えます。例えば、`created_at`カラムの順にしたい場合は次のようになります。

`order(:created_at)`

ただし、残念ながらデフォルトの順序が_昇順 (ascending)_ となっているので、このままでは数の小さい値から大きい値にソートされてしまいます (最も古い投稿が最初に表示されてしまいます)。順序を逆にしたい場合は、一段階低いレベルの技術ではありますが、次のように生のSQLを引数に与える必要があります。

`order('created_at DESC')`

ここで使った`DESC`とは、SQLの_降順 (descending)_ を指します。したがって、これで新しい投稿から古い投稿の順に並びます[5](#cha-13_footnote-5) 。古いバージョンのRailsでは、欲しい振る舞いにするためには生のSQLを書くしか選択肢がなかったのですが、Rails 4.0からは次のようにRubyの文法でも書けるようになりました。

`order(created_at: :desc)`

このコードを使ってMicropostモデルを更新した結果を、[リスト13.17](/chapters/user_microposts?version=5.1#code-micropost_ordering)に示します。

リスト 13.17: `default_scope`でマイクロポストを順序付ける **green** `app/models/micropost.rb`
```ruby
class Micropost < ApplicationRecord
  belongs_to :user
  default_scope -> { order(created_at: :desc) }
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

[リスト13.17](/chapters/user_microposts?version=5.1#code-micropost_ordering)では新たに、ラムダ式 (Stabby lambda) という文法を使っています。これは、_Proc_や_lambda_ (もしくは_無名関数_)と呼ばれるオブジェクトを作成する文法です。`->`というラムダ式は、ブロック ([4.3.2](/chapters/rails_flavored_ruby?version=5.1#sec-blocks)) を引数に取り、Procオブジェクトを返します。このオブジェクトは、`call`メソッドが呼ばれたとき、ブロック内の処理を評価します。この構文をコンソールで確かめてみましょう。
```ruby
>> -> { puts "foo" }
=> #<Proc:0x007fab938d0108@(irb):1 (lambda)>
>> -> { puts "foo" }.call
foo
=> nil
```
(ProcはRubyの中でも少し高度なトピックなので、今すぐわからなくても心配する必要はありません。)

[リスト13.17](/chapters/user_microposts?version=5.1#code-micropost_ordering)のコードを追加することで、テストスイートは **green**になるはずです。

リスト 13.18: **green**
```sh
$ rails test
```
(訳注: _default scope_の使い方についてはRailsガイドの[デフォルトスコープを適用する](https://railsguides.jp/active_record_querying.html#%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B)をお読みください。)

#### [Dependent: destroy](#sec-dependent_destroy)

順序についてはひとまずここで区切ることにし、今度はマイクロポストに第二の要素を追加してみましょう。[10.4](/chapters/updating_and_deleting_users?version=5.1#sec-deleting_users)で書いたように、サイト管理者はユーザーを_破棄する_権限を持ちます。ユーザーが破棄された場合、ユーザーのマイクロポストも同様に破棄されるべきです。

この振る舞いは、`has_many`メソッドにオプションを渡してあげることで実装できます ([リスト13.19](/chapters/user_microposts?version=5.1#code-micropost_dependency))。

#### リスト 13.19: マイクロポストは、その所有者 (ユーザー) と一緒に破棄されることを保証する `app/models/user.rb`
```ruby
class User < ApplicationRecord
  has_many :microposts, dependent: :destroy
  .
  .
  .
end
```

`dependent: :destroy`というオプションを使うと、ユーザーが削除されたときに、そのユーザーに紐付いた (そのユーザーが投稿した) マイクロポストも一緒に削除されるようになります。これは、管理者がシステムからユーザーを削除したとき、持ち主の存在しないマイクロポストがデータベースに取り残されてしまう問題を防ぎます。

次に、[リスト13.19](/chapters/user_microposts?version=5.1#code-micropost_dependency)が正しく動くかどうか、テストを使ってUserモデルを検証してみます。このテストでは、 (idを紐づけるための) ユーザーを作成することと、そのユーザーに紐付いたマイクロポストを作成する必要があります。その後、ユーザーを削除してみて、マイクロポストの数が1つ減っているかどうかを確認します。作成したコードを[リスト13.20](/chapters/user_microposts?version=5.1#code-dependent_destroy_test)に示します。なお、以前に書いた [delete] リンクの統合テスト ([リスト10.62](/chapters/updating_and_deleting_users?version=5.1#code-delete_link_integration_test)) と比較してみると理解の助けになるかもしれません。

リスト 13.20: `dependent: :destroy`のテスト **green** `test/models/user_test.rb`
```ruby

require 'test_helper'

class UserTest < ActiveSupport::TestCase

  def setup
    @user = User.new(name: "Example User", email: "user@example.com",
                     password: "foobar", password_confirmation: "foobar")
  end
  .
  .
  .
  test "associated microposts should be destroyed" do
    @user.save
    @user.microposts.create!(content: "Lorem ipsum")
    assert_difference 'Micropost.count', -1 do
      @user.destroy
    end
  end
end
```

[リスト13.19](/chapters/user_microposts?version=5.1#code-micropost_dependency)のコードが正しく動いていれば、テストが **green**になります。

リスト 13.21: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_ordering_and_dependency)

1.  `Micropost.first.created_at`の実行結果と、`Micropost.last.created_at`の実行結果を比べてみましょう。
2.  `Micropost.first`を実行したときに発行されるSQL文はどうなっているでしょうか? 同様にして、`Micropost.last`の場合はどうなっているでしょうか? _ヒント_: それぞれをコンソール上で実行したときに表示される文字列が、SQL文になります。
3.  データベース上の最初のユーザーを変数`user`に代入してください。そのuserオブジェクトが最初に投稿したマイクロポストのidはいくつでしょうか? 次に、`destroy`メソッドを使ってそのuserオブジェクトを削除してみてください。削除すると、そのuserに紐付いていたマイクロポストも削除されていることを`Micropost.find`で確認してみましょう。

[13.2 マイクロポストを表示する](/chapters/user_microposts?version=5.1#sec-showing_microposts)
---------------------------------------------------------------------------------

Web経由でマイクロポストを作成する方法は現時点ではありませんが ([13.3.2](/chapters/user_microposts?version=5.1#sec-creating_microposts)から作り始めます)、マイクロポストを表示することと、テストすることならできます。ここでは、Twitterのような独立したマイクロポストの`index`ページは作らずに、[図13.4](/chapters/user_microposts?version=5.1#fig-user_microposts_mockup)のモックアップに示したように、ユーザーの`show`ページで直接マイクロポストを表示させることにします。ユーザープロフィールにマイクロポストを表示させるため、最初に極めてシンプルなERbテンプレートを作成します。次に、[10.3.2](/chapters/updating_and_deleting_users?version=5.1#sec-sample_users)のサンプルデータ生成タスクにマイクロポストのサンプルを追加して、画面にサンプルデータが表示されるようにしてみます。

図 13.4: マイクロポストが表示されたプロフィールページのモックアップ

### [13.2.1 マイクロポストの描画](/chapters/user_microposts?version=5.1#sec-rendering_microposts)

本項では、ユーザーのプロフィール画面 (`show.html.erb`) でそのユーザーのマイクロポストを表示させたり、これまでに投稿した総数も表示させたりしていきます。とはいえ、今回必要となるアイデアのほとんどは、[10.3](/chapters/updating_and_deleting_users?version=5.1#sec-showing_all_users)で実装したユーザーを表示する部分と似ています。

演習で既にマイクロポストをいくつか作成していた場合は、一度データベースをリセットし、サンプルデータを再生成しておいてください。
```ruby
$ rails db:migrate:rese
$ rails db:seed
```
まずは、Micropostのコントローラとビューを作成するために、コントローラを生成しましょう。なお、今回使うのはビューだけで、Micropostsコントローラは[13.3](/chapters/user_microposts?version=5.1#sec-manipulating_microposts)から使っていきます。
```sh
$ rails generate controller Microposts
```
今回の目的は、ユーザー毎にすべてのマイクロポストを描画できるようにすることです。[10.3.5](/chapters/updating_and_deleting_users?version=5.1#sec-partial_refactoring)で見た次のコードでは、
```erb
<ul class="users">
  <%= render @users %>
</ul>
```
`_user.html.erb`パーシャルを使って自動的に`@users`変数内のそれぞれのユーザーを出力していました。これを参考に、`_micropost.html.erb`パーシャルを使ってマイクロポストのコレクションを表示しようとすると、次のようになります。
```erb
<ol class="microposts">
  <%= render @microposts %>
</ol>
```
まずは、順序無しリストの`ul`タグではなく、_順序付き_リストの`ol`タグを使っている点に注目してください。これは、マイクロポストが特定の順序 (新しい→古い) に依存しているためです。次に、対応するパーシャルを[リスト13.22](/chapters/user_microposts?version=5.1#code-micropost_partial)に示します。

#### リスト 13.22: 1つのマイクロポストを表示するパーシャル `app/views/microposts/_micropost.html.erb`
```erb
<li id="micropost-<%= micropost.id %>">
  <%= link_to gravatar_for(micropost.user, size: 50), micropost.user %>
  <span class="user"><%= link_to micropost.user.name, micropost.user %></span>
  <span class="content"><%= micropost.content %></span>
  <span class="timestamp">
    Posted <%= time_ago_in_words(micropost.created_at) %> ago.
  </span>
</li>
```
ここでは`time_ago_in_words`というヘルパーメソッドを使っています。これはメソッド名の表すとおりですが、「3分前に投稿」といった文字列を出力します。具体的な効果について[13.2.2](/chapters/user_microposts?version=5.1#sec-sample_microposts)で説明します。また、[リスト13.22](/chapters/user_microposts?version=5.1#code-micropost_partial)では各マイクロポストに対してCSSのidを割り振っています。

`<li id="micropost-<%= micropost.id %>">`

これは一般的に良いとされる慣習で、例えば将来、JavaScriptを使って各マイクロポストを操作したくなったときなどに役立ちます。

次は、一度にすべてのマイクロポストが表示されてしまう潜在的問題に対処します。[10.3.3]ではページネーションを使いましたが、今回も同じ方法でこの問題を解決します。前回同様、`will_paginate`メソッドを使うと次のようになります。

`<%= will_paginate @microposts %>`

[リスト10.45](/chapters/updating_and_deleting_users?version=5.1#code-will_paginate_index_view)のユーザー一覧画面のコードと比較すると、少し違っています。以前は次のように単純なコードでした。

<%= will_paginate %>

実は、上のコードは引数なしで動作していました。これは`will_paginate`が、Usersコントローラのコンテキストにおいて、`@users`インスタンス変数が存在していることを_前提としている_ためです。このインスタンス変数は、[10.3.3](/chapters/updating_and_deleting_users?version=5.1#sec-pagination)でも述べたように`ActiveRecord::Relation`クラスのインスタンスです。今回の場合はUsersコントローラのコンテキストからマイクロポストをページネーションしたいため (つまりコンテキストが異なるため)、明示的に`@microposts`変数を`will_paginate`に渡す必要があります。したがって、そのようなインスタンス変数をUsersコントローラの`show`アクションで定義しなければなりません ([リスト13.23](/chapters/user_microposts?version=5.1#code-user_show_microposts_instance))。

リスト 13.23: `@microposts`インスタンス変数を`show`アクションに追加する `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController
  .
  .
  .
  def show
    @user = User.find(params[:id])
    @microposts = @user.microposts.paginate(page: params[:page])
  end
  .
  .
  .
end
```

`paginate`メソッドの素晴らしさに注目してください。_マイクロポストの関連付けを経由して_`microposts`テーブルに到達し、必要なマイクロポストのページを引き出してくれます。

最後の課題はマイクロポストの投稿数を表示することですが、これは`count`メソッドを使うことで解決できます。

`user.microposts.count`

`paginate`と同様に、関連付けをとおして`count`メソッドを呼び出すことができます。大事なことは、`count`メソッドではデータベース上のマイクロポストを全部読みだしてから結果の配列に対して`length`を呼ぶ、といった無駄な処理は_していない_という点です。そんなことをしたら、マイクロポストの数が増加するにつれて効率が低下してしまいます。そうではなく、(データベース内での計算は高度に最適化されているので) データベースに代わりに計算してもらい、特定の`user_id`に紐付いたマイクロポストの数をデータベースに問い合わせています。(それでもcountメソッドがアプリケーションのボトルネックになるようなことがあれば、さらに高速な[_counter cache_](http://railscasts.com/episodes/23-counter-cache-column)を使うこともできます。)

これですべての要素が揃ったので、プロフィール画面にマイクロポストを表示させてみましょう ([リスト13.24](/chapters/user_microposts?version=5.1#code-user_show_microposts))。(このとき、[リスト7.21](/chapters/sign_up?version=5.1#code-errors_partial)と同様に `if @user.microposts.any?` を使って、ユーザーのマイクロポストが1つもない場合には空のリストを表示させていない点にも注目してください。)

リスト 13.24: マイクロポストをユーザーの`show`ページ (プロフィール画面) に追加する `app/views/users/show.html.erb`
```erb
<% provide(:title, @user.name) %>
<div class="row">
  <aside class="col-md-4">
    <section class="user_info">
      <h1>
        <%= gravatar_for @user %>
        <%= @user.name %>
      </h1>
    </section>
  </aside>
  <div class="col-md-8">
    <% if @user.microposts.any? %>
      <h3>Microposts (<%= @user.microposts.count %>)</h3>
      <ol class="microposts">
        <%= render @microposts %>
      </ol>
      <%= will_paginate @microposts %>
    <% end %>
  </div>
</div>
```
ここで、改良した新しいプロフィール画面をブラウザで見てみましょう ([図13.5](/chapters/user_microposts?version=5.1#fig-user_profile_no_microposts))。 …何とも寂しいページで、がっかりですね。マイクロポストが1つもないのでは無理もありません。ではここでマイクロポストを追加しましょう。

図 13.5: マイクロポスト用のコードのあるユーザープロフィールページ (ただしマイクロポストがない)

#### [演習](#sec-exercises_rendering_microposts)

1.  [7.3.3](/chapters/sign_up?version=5.1#sec-signup_error_messages)で軽く説明したように、今回ヘルパーメソッドとして使った`time_ago_in_words`メソッドは、Railsコンソールの`helper`オブジェクトから呼び出すことができます。この`helper`オブジェクトの`time_ago_in_words`メソッドを使って、`3.weeks.ago`や`6.months.ago`を実行してみましょう。
2.  `helper.time_ago_in_words(1.year.ago)`と実行すると、どういった結果が返ってくるでしょうか?
3.  micropostsオブジェクトのクラスは何でしょうか? _ヒント_: [リスト13.23](/chapters/user_microposts?version=5.1#code-user_show_microposts_instance)内のコードにあるように、まずは`paginate`メソッド (引数は`page: nil`) でオブジェクトを取得し、その後`class`メソッドを呼び出してみましょう。

### [13.2.2 マイクロポストのサンプル](/chapters/user_microposts?version=5.1#sec-sample_microposts)

[13.2.1](/chapters/user_microposts?version=5.1#sec-rendering_microposts)のユーザーマイクロポストのテンプレート作成作業の成果は、何とも拍子抜けでした。[10.3.2](/chapters/updating_and_deleting_users?version=5.1#sec-sample_users)のサンプルデータ生成タスクにマイクロポストも追加して、この情けない状況を修正しましょう。

_すべての_ユーザーにマイクロポストを追加しようとすると時間が掛かり過ぎるので、`take`メソッドを使って最初の6人だけに追加します。

`User.order(:created_at).take(6)`

(このとき、`order`メソッドを経由することで、作成されたユーザーの最初の6人を明示的に呼び出すようにしています。)

この6人については、1ページの表示限界数 (30) を越えさせるために、それぞれ50個分のマイクロポストを追加するようにしています。また、各投稿内容についてですが、Faker gemに[`Lorem.sentence`](http://rubydoc.info/gems/faker/1.3.0/Faker/Lorem)という便利なメソッドがあるので、これを使います[^6.]。変更した結果は[リスト13.25](/chapters/user_microposts?version=5.1#code-sample_microposts)のとおりです。([リスト13.25](/chapters/user_microposts?version=5.1#code-sample_microposts)のループの順序に違和感があるかもしれませんが、これは[14.3](/chapters/following_users?version=5.1#sec-the_status_feed)でステータスフィード (いわゆるタイムライン) を実装するときに役立ちます。というのも、ユーザー毎に50個分のマイクロポストをまとめて作成してしまうと、ステータスフィードに表示される投稿がすべて同じユーザーになってしまい、視覚的な見栄えが悪くなるからです。)

リスト 13.25: サンプルデータにマイクロポストを追加する `db/seeds.rb`
```ruby

.
.
.
users = User.order(:created_at).take(6)
50.times do
  content = Faker::Lorem.sentence(5)
  users.each { |user| user.microposts.create!(content: content) }
end
```

ここで、いつものように開発環境用のデータベースで再度サンプルデータを生成します。
```ruby
$ rails db:migrate:rese
$ rails db:seed
```
生成し終わったら、Railsサーバーを一度落として、起動し直してください。

それぞれのマイクロポストの情報を表示することによって、[13.2.1](/chapters/user_microposts?version=5.1#sec-rendering_microposts)の地道な作業がやっと報われました[7](#cha-13_footnote-7) 。実行結果を[図13.6](/chapters/user_microposts?version=5.1#fig-user_profile_microposts_no_styling)に示します。

図 13.6: プロフィールとマイクロポスト (CSSは未適用)

[図13.6](/chapters/user_microposts?version=5.1#fig-user_profile_microposts_no_styling)のページにはマイクロポスト固有のスタイルが与えられていないので、[リスト13.26](/chapters/user_microposts?version=5.1#code-micropost_css)を追加して、結果のページを見てみましょう[8](#cha-13_footnote-8) 。

リスト 13.26: マイクロポスト用のCSS (本章で利用するCSSのすべて) `app/assets/stylesheets/custom.scss`
```scss
.
.
.
/* microposts */

.microposts {
  list-style: none;
  padding: 0;
  li {
    padding: 10px 0;
    border-top: 1px solid #e8e8e8;
  }
  .user {
    margin-top: 5em;
    padding-top: 0;
  }
  .content {
    display: block;
    margin-left: 60px;
    img {
      display: block;
      padding: 5px 0;
    }
  }
  .timestamp {
    color: $gray-light;
    display: block;
    margin-left: 60px;
  }
  .gravatar {
    float: left;
    margin-right: 10px;
    margin-top: 5px;
  }
}

aside {
  textarea {
    height: 100px;
    margin-bottom: 5px;
  }
}

span.picture {
  margin-top: 10px;
  input {
    border: 0;
  }
}
```
[図13.7](/chapters/user_microposts?version=5.1#fig-user_profile_with_microposts)では最初のユーザーのプロフィール画面を、[図13.8](/chapters/user_microposts?version=5.1#fig-other_profile_with_microposts)では2番目のユーザーのプロフィール画面を表示しています。最後の[図13.9](/chapters/user_microposts?version=5.1#fig-user_profile_microposts)では、最初のユーザーの_2番目_のページと、下部にあるページネーションのリンクを表示しています。各マイクロポストの表示には、3つのどの場合にも、それが作成されてからの時間 ("1分前に投稿" など) が表示されていることに注目してください。これは[リスト13.22](/chapters/user_microposts?version=5.1#code-micropost_partial)の`time_ago_in_words`メソッドによるものです。数分待ってからページを再度読み込むと、このテキストは自動的に新しい時間に基づいて更新されます。

図 13.7: プロフィールとマイクロポスト (/users/1)

図 13.8: 別ユーザーのプロフィールとマイクロポスト (/users/5).

図 13.9: マイクロポストのページネーション用リンク (/users/1?page=2).

#### [演習](#sec-exercises_sample_microposts)

1.  `(1..10).to_a.take(6)`というコードの実行結果を推測できますか? 推測した値が合っているかどうか、実際にコンソールを使って確認してみましょう。
2.  先ほどの演習にあった`to_a`メソッドの部分は本当に必要でしょうか? 確かめてみてください。
3.  Fakerは_lorem ipsum_以外にも、非常に多種多様の事例に対応しています。[Fakerのドキュメント](https://github.com/stympy/faker) (英語) を眺めながら画面に出力する方法を学び、実際に[大学名](https://github.com/stympy/faker#fakeruniversity)や[電話番号](https://github.com/stympy/faker#fakerphonenumber)、[Hipster Ipsum](https://github.com/stympy/faker#fakerhipster)や[Chuck Norris facts](https://github.com/stympy/faker#fakerchucknorris) (参考: [チャック・ノリスの真実](https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A3%E3%83%83%E3%82%AF%E3%83%BB%E3%83%8E%E3%83%AA%E3%82%B9%E3%83%BB%E3%83%95%E3%82%A1%E3%82%AF%E3%83%88)) を画面に出力してみましょう。(訳注: もちろん日本語にも対応していて、例えば沖縄らしい用語を出力する[faker-okinawa](https://github.com/okinawarb/faker-okinawa)もあります。ぜひ遊んでみてください。)

### [13.2.3 プロフィール画面のマイクロポストをテストする](/chapters/user_microposts?version=5.1#sec-profile_micropost_tests)

アカウントを有効化したばかりのユーザーはプロフィール画面にリダイレクトされるので、そのプロフィール画面が正しく描画されていることは、単体テストを通して確認済みです ([リスト11.33](/chapters/account_activation?version=5.1#code-signup_with_account_activation_test))。この項では、プロフィール画面で表示されるマイクロポストに対して、統合テストを書いていきます。まずは、プロフィール画面用の統合テストを生成してみましょう。
```sh
$ rails generate integration_test users_profile
```
     invoke  test_unit
      create    test/integration/users_profile_test.rb

プロフィール画面におけるマイクロポストをテストするためには、ユーザーに紐付いたマイクロポストのテスト用データが必要になります。Railsの慣習に従って、関連付けされたテストデータをfixtureファイルに追加すると、次のようになります。
```yml
orange:
  content: "I just ate an orange!"
  created_at: <%= 10.minutes.ago %>
  user: michael
```
`user`に`michael`という値を渡すと、Railsはfixtureファイル内の対応するユーザーを探し出して、(もし見つかれば) マイクロポストに関連付けてくれます。
```ruby
michael:
  name: Michael Example
  email: michael@example.com
  .
  .
  .
```
また、マイクロポストのページネーションをテストするためには、マイクロポスト用のfixtureにいくつかテストデータを追加する必要がありますが、これは[リスト10.47](/chapters/updating_and_deleting_users?version=5.1#code-users_fixtures_extra_users)でユーザーを追加したときと同様に、埋め込みRubyを使うと簡単です。
```erb
<% 30.times do |n| %>
micropost_<%= n %>:
  content: <%= Faker::Lorem.sentence(5) %>
  created_at: <%= 42.days.ago %>
  user: michael
<% end %>
```
これらのコードを1つにまとめると、マイクロポスト用のfixtureファイルは[リスト13.27](/chapters/user_microposts?version=5.1#code-updated_micropost_fixtures)のようになります。

リスト 13.27: ユーザーと関連付けされたマイクロポストのfixture `test/fixtures/microposts.yml`
```erb
orange:
  content: "I just ate an orange!"
  created_at: <%= 10.minutes.ago %>
  user: michael

tau_manifesto:
  content: "Check out the @tauday site by @mhartl: http://tauday.com"
  created_at: <%= 3.years.ago %>
  user: michael

cat_video:
  content: "Sad cats are sad: http://youtu.be/PKffm2uI4dk"
  created_at: <%= 2.hours.ago %>
  user: michael

most_recent:
  content: "Writing a short test"
  created_at: <%= Time.zone.now %>
  user: michael

<% 30.times do |n| %>
micropost_<%= n %>:
  content: <%= Faker::Lorem.sentence(5) %>
  created_at: <%= 42.days.ago %>
  user: michael
<% end %>
```
テストデータの準備は完了したので、これからテストを書いていきますが、今回のテストはやや単純です。今回のテストでは、プロフィール画面にアクセスした後に、ページタイトルとユーザー名、Gravatar、マイクロポストの投稿数、そしてページ分割されたマイクロポスト、といった順でテストしていきます。作成したコードを[リスト13.28](/chapters/user_microposts?version=5.1#code-user_profile_test)に示します。(Applicationヘルパーを読み込んだことで[リスト4.2](/chapters/rails_flavored_ruby?version=5.1#code-title_helper)の`full_title`ヘルパーが利用できている点に注目してください。)[9](#cha-13_footnote-9)

リスト 13.28: Userプロフィール画面に対するテスト **green** `test/integration/users_profile_test.rb`
```ruby
require 'test_helper'

class UsersProfileTest < ActionDispatch::IntegrationTest
  include ApplicationHelper

  def setup
    @user = users(:michael)
  end

  test "profile display" do
    get user_path(@user)
    assert_template 'users/show'
    assert_select 'title', full_title(@user.name)
    assert_select 'h1', text: @user.name
    assert_select 'h1>img.gravatar'
    assert_match @user.microposts.count.to_s, response.body
    assert_select 'div.pagination'
    @user.microposts.paginate(page: 1).each do |micropost|
      assert_match micropost.content, response.body
    end
  end
end
```

[リスト13.28](/chapters/user_microposts?version=5.1#code-user_profile_test)ではマイクロポストの投稿数をチェックするために、[第12章](/chapters/password_reset?version=5.1#cha-password_reset)の演習 ([12.3.3.1](/chapters/password_reset?version=5.1#sec-exercises_password_reset_test)) で紹介した`response.body`を使っています。名前を見ると誤解されがちですが、`response.body`にはそのページの完全なHTMLが含まれています (HTMLのbodyタグだけではありません)。したがって、そのページの_どこかしらに_マイクロポストの投稿数が存在するのであれば、次のように探し出してマッチできるはずです。

`assert_match @user.microposts.count.to_s, response.body`

これは`assert_select`よりもずっと抽象的なメソッドです。特に、`assert_select`ではどのHTMLタグを探すのか伝える必要がありますが、`assert_match`メソッドではその必要がない点が違います。

また、[リスト13.28](/chapters/user_microposts?version=5.1#code-user_profile_test)の`assert_select`の引数では、ネストした文法を使っている点にも注目してください。

`assert_select 'h1>img.gravatar'`

このように書くことで、`h1`タグ (トップレベルの見出し) の_内側にある_、`gravatar`クラス付きの`img`タグがあるかどうかをチェックできます。

そして、アプリケーション側のコードは実装済みなので、これらのテストは **green**になるはずです。

リスト 13.29: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_profile_micropost_tests)

1.  [リスト13.28](/chapters/user_microposts?version=5.1#code-user_profile_test)にある２つの`'h1'`のテストが正しいか確かめるため、該当するアプリケーション側のコードをコメントアウトしてみましょう。テストが **green** から **red**に変わることを確認してみてください。
2.  [リスト13.28](/chapters/user_microposts?version=5.1#code-user_profile_test)にあるテストを変更して、`will_paginate`が_１度のみ_表示されていることをテストしてみましょう。_ヒント_: [表5.2](/chapters/filling_in_the_layout?version=5.1#table-assert_select)を参考にしてください。

[13.3 マイクロポストを操作する](/chapters/user_microposts?version=5.1#sec-manipulating_microposts)
--------------------------------------------------------------------------------------

データモデリングとマイクロポスト表示テンプレートの両方が完成したので、次はWeb経由でそれらを作成するためのインターフェイスに取りかかりましょう。この節では、_ステータスフィード_ ([第14章](/chapters/following_users?version=5.1#cha-following_users)で完成させます) の最初のヒントをお見せします。最後に、ユーザーがマイクロポストをWeb経由で破棄できるようにします。

従来のRails開発の慣習と異なる箇所が1つあります。Micropostsリソースへのインターフェイスは、主にプロフィールページとHomeページのコントローラを経由して実行されるので、Micropostsコントローラには`new`や`edit`のようなアクションは不要ということになります。つまり、`create`と`destroy`があれば十分です。したがって、Micropostsのリソースは[リスト13.30](/chapters/user_microposts?version=5.1#code-microposts_resource)のようになります。その結果、[リスト13.30](/chapters/user_microposts?version=5.1#code-microposts_resource)のコードは、RESTfulなルーティング ([表2.3](/chapters/toy_app?version=5.1#table-demo_RESTful_microposts)) のサブセット ([表13.2](/chapters/user_microposts?version=5.1#table-RESTful_microposts)) になります。もちろん、シンプルになったということは完成度が_さらに_高まったということの証しであり、退化したわけではありません。[第2章](/chapters/toy_app?version=5.1#cha-a_toy_app)でscaffoldに頼りきりだった頃からここに至るまでは長い道のりでしたが、今ではscaffoldが生成するような複雑なコードはほとんど不要になりました。

リスト 13.30: マイクロポストリソースのルーティング `config/routes.rb`
```ruby
Rails.application.routes.draw do
  root   'static_pages#home'
  get    '/help',    to: 'static_pages#help'
  get    '/about',   to: 'static_pages#about'
  get    '/contact', to: 'static_pages#contact'
  get    '/signup',  to: 'users#new'
  get    '/login',   to: 'sessions#new'
  post   '/login',   to: 'sessions#create'
  delete '/logout',  to: 'sessions#destroy'
  resources :users
  resources :account_activations, only: [:edit]
  resources :password_resets,     only: [:new, :create, :edit, :update]
  resources :microposts,          only: [:create, :destroy]
end
```

|HTTPリクエスト|URL|アクション|名前付きルート|
|--|--|--|--|
|POST|/microposts|create|microposts_path|
|DELETE|/microposts/1|destroy|micropost_path(micropost)|

表 13.2: Micropostsリソースが提供する[リスト13.30](/chapters/user_microposts?version=5.1#code-microposts_resource)のRESTfulルート

### [13.3.1 マイクロポストのアクセス制御](/chapters/user_microposts?version=5.1#sec-micropost_access_control)

Micropostsリソースの開発では、Micropostsコントローラ内のアクセス制御から始めることにしましょう。関連付けられたユーザーを通してマイクロポストにアクセスするので、`create`アクションや`destroy`アクションを利用するユーザーは、ログイン済みでなければなりません。

ログイン済みかどうかを確かめるテストでは、Usersコントローラ用のテストがそのまま役に立ちます ([リスト10.20](/chapters/updating_and_deleting_users?version=5.1#code-edit_update_redirect_tests)、[リスト10.61](/chapters/updating_and_deleting_users?version=5.1#code-action_tests_admin))。つまり、正しいリクエストを各アクションに向けて発行し、マイクロポストの数が変化していないかどうか、また、リダイレクトされるかどうかを確かめればよいのです ([リスト13.31](/chapters/user_microposts?version=5.1#code-create_destroy_micropost_tests))。

リスト 13.31: Micropostsコントローラの認可テスト **red** `test/controllers/microposts_controller_test.rb`
```ruby
require 'test_helper'

class MicropostsControllerTest < ActionDispatch::IntegrationTest

  def setup
    @micropost = microposts(:orange)
  end

  test "should redirect create when not logged in" do
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: "Lorem ipsum" } }
    end
    assert_redirected_to login_url
  end

  test "should redirect destroy when not logged in" do
    assert_no_difference 'Micropost.count' do
      delete micropost_path(@micropost)
    end
    assert_redirected_to login_url
  end
end
```

[リスト13.31](/chapters/user_microposts?version=5.1#code-create_destroy_micropost_tests)のテストにパスするコードを書くためには、少しアプリケーション側のコードをリファクタリングしておく必要があります。というのも、[10.2.1](/chapters/updating_and_deleting_users?version=5.1#sec-requiring_logged_in_users)では、beforeフィルターの`logged_in_user`メソッドを使って、ログインを要求したことについて思い出してください ([リスト10.15](/chapters/updating_and_deleting_users?version=5.1#code-authorize_before_filter))。あのときはUsersコントローラ内にこのメソッドがあったので、beforeフィルターで指定していましたが、このメソッドはMicropostsコントローラでも必要です。そこで、各コントローラが継承するApplicationコントローラに ([4.4.4](/chapters/rails_flavored_ruby?version=5.1#sec-a_controller_class))、このメソッドを移してしまいましょう。[10](#cha-13_footnote-10) 作成したコードを[リスト13.32](/chapters/user_microposts?version=5.1#code-sessions_helper_authenticate)に示します。

リスト 13.32: `logged_in_user`メソッドをApplicationコントローラに移す **red** `app/controllers/application_controller.rb`
```ruby
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper

  private

    # ユーザーのログインを確認する
    def logged_in_user
      unless logged_in?
        store_location
        flash[:danger] = "Please log in."
        redirect_to login_url
      end
    end
end
```

コードが重複しないよう、このときUsersコントローラからも`logged_in_user`を削除しておきましょう ([リスト13.33](/chapters/user_microposts?version=5.1#code-users_controller_remove_logged_in_filter))。

リスト 13.33: Usersコントローラ内の`logged_in_user`フィルターを削除する **red** `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController
  before_action :logged_in_user, only: [:index, :edit, :update, :destroy]
  .
  .
  .
  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end

    # beforeフィルター

    # 正しいユーザーかどうかを確認
    def correct_user
      @user = User.find(params[:id])
      redirect_to(root_url) unless current_user?(@user)
    end

    # 管理者かどうかを確認
    def admin_user
      redirect_to(root_url) unless current_user.admin?
    end
end
```

[リスト13.32](/chapters/user_microposts?version=5.1#code-sessions_helper_authenticate)のコードによって、Micropostsコントローラからも`logged_in_user`メソッドを呼び出せるようになりました。これにより、`create`アクションや`destroy`アクションに対するアクセス制限が、beforeフィルターで簡単に実装できるようになります ([リスト13.34](/chapters/user_microposts?version=5.1#code-microposts_controller_access_control))。

リスト 13.34: Micropostsコントローラの各アクションに認可を追加する **green** `app/controllers/microposts_controller.rb`
```ruby

class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create, :destroy]

  def create
  end

  def destroy
  end
end
```

これでテストは **green**になるはずです。

リスト 13.35: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_access_control)

1.  なぜUsersコントローラ内にある`logged_in_user`フィルターを残したままにするとマズイのでしょうか? 考えてみてください。

### [13.3.2 マイクロポストを作成する](/chapters/user_microposts?version=5.1#sec-creating_microposts)

[第7章](/chapters/sign_up?version=5.1#cha-sign_up)では、HTTP `POST`リクエストをUsersコントローラの`create`アクションに発行するHTMLフォームを作成することで、ユーザーのサインアップを実装しました。マイクロポスト作成の実装もこれと似ています。主な違いは、別の micropost/new ページを使う代わりに、ホーム画面 (つまりルートパス) にフォームを置くという点です。[図13.10](/chapters/user_microposts?version=5.1#fig-home_page_with_micropost_form_mockup)のモックアップを見てください。

図 13.10: マイクロポスト作成フォームのあるホーム画面のモックアップ

最後にホーム画面を実装したときは ([図5.8](/chapters/filling_in_the_layout?version=5.1#fig-sample_app_logo))、[Sign up now!] ボタンが中央にありました。マイクロポスト作成フォームは、ログインしている特定のユーザーのコンテキストでのみ機能するので、この節の一つの目標は、ユーザーのログイン状態に応じて、ホーム画面の表示を変更することです。これについては、[リスト13.37](/chapters/user_microposts?version=5.1#code-microposts_home_page)で実装します。

次に、マイクロポストの`create`アクションを作り始めましょう。このアクションも、[リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)のユーザー用アクションと似ています。違いは、新しいマイクロポストを`build`するためにUser/Micropost関連付けを使っている点です ([リスト13.36](/chapters/user_microposts?version=5.1#code-microposts_create_action))。`micropost_params`でStrong Parametersを使っていることにより、マイクロポストの`content`属性だけがWeb経由で変更可能になっている点に注目してください。

リスト 13.36: Micropostsコントローラの`create`アクション `app/controllers/microposts_controller.rb`
```ruby

class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create, :destroy]

  def create
    @micropost = current_user.microposts.build(micropost_params)
    if @micropost.save
      flash[:success] = "Micropost created!"
      redirect_to root_url
    else
      render 'static_pages/home'
    end
  end

  def destroy
  end

  private

    def micropost_params
      params.require(:micropost).permit(:content)
    end
end
```

マイクロポスト作成フォームを構築するために、サイト訪問者がログインしているかどうかに応じて異なるHTMLを提供するコードを使います ([リスト13.37](/chapters/user_microposts?version=5.1#code-microposts_home_page))。

リスト 13.37: Homeページ (/) にマイクロポストの投稿フォームを追加する `app/views/static_pages/home.html.erb`
```erb
<% if logged_in? %>
  <div class="row">
    <aside class="col-md-4">
      <section class="user_info">
        <%= render 'shared/user_info' %>
      </section>
      <section class="micropost_form">
        <%= render 'shared/micropost_form' %>
      </section>
    </aside>
  </div>
<% else %>
  <div class="center jumbotron">
    <h1>Welcome to the Sample App</h1>

    <h2>
      This is the home page for the
      <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
      sample application.
    </h2>

    <%= link_to "Sign up now!", signup_path, class: "btn btn-lg btn-primary" %>
  </div>

  <%= link_to image_tag("rails.png", alt: "Rails logo"),
              'http://rubyonrails.org/' %>
<% end %>
```
`if`-`else`文の分岐でコードを書き分けている点が少し汚いですが、このコードのリファクタリングは演習に回すことにします ([13.3.2.1](/chapters/user_microposts?version=5.1#sec-exercises_creating_microposts))。

[リスト13.37](/chapters/user_microposts?version=5.1#code-microposts_home_page)のコードを動かすためには、いくつかのパーシャルを作る必要があります。まずはHomeページの新しいサイドバーからです。次の[リスト13.38](/chapters/user_microposts?version=5.1#code-user_info)のようになります。

リスト 13.38: サイドバーで表示するユーザー情報のパーシャル `app/views/shared/_user_info.html.erb`
```
<%= link_to gravatar_for(current_user, size: 50), current_user %>
<h1><%= current_user.name %></h1>
<span><%= link_to "view my profile", current_user %></span>
<span><%= pluralize(current_user.microposts.count, "micropost") %></span>
```
プロフィールサイドバー ([リスト13.24](/chapters/user_microposts?version=5.1#code-user_show_microposts)) のときと同様、[リスト13.38](/chapters/user_microposts?version=5.1#code-user_info)のユーザー情報にも、そのユーザーが投稿したマイクロポストの総数が表示されていることに注目してください。ただし少し表示に違いがあります。プロフィールサイドバーでは、 “Microposts” をラベルとし、「Microposts (1)」と表示することは問題ありません。しかし、今回のように “1 microposts” と表示してしまうと英語の文法上誤りになってしまいます。そこで、[7.3.3](/chapters/sign_up?version=5.1#sec-signup_error_messages)で紹介した`pluralize`メソッドを使って “1 micropost” や “2 microposts” と表示するように調整しています。

次はマイクロポスト作成フォームを定義します ([リスト13.39](/chapters/user_microposts?version=5.1#code-micropost_form))。これはユーザー登録フォームに似ています ([リスト7.15](/chapters/sign_up?version=5.1#code-signup_form))。

リスト 13.39: マイクロポスト投稿フォームのパーシャル `app/views/shared/_micropost_form.html.erb`
```erb
<%= form_for(@micropost) do |f| %>
  <%= render 'shared/error_messages', object: f.object %>
  <div class="field">
    <%= f.text_area :content, placeholder: "Compose new micropost..." %>
  </div>
  <%= f.submit "Post", class: "btn btn-primary" %>
<% end %>
```
[リスト13.39](/chapters/user_microposts?version=5.1#code-micropost_form)のフォームが動くようにするためには、2箇所の変更が必要です。1つは、(以前と同様) 関連付けを使って次のように`@micropost`を定義することです。

@micropost = current_user.microposts.build

作成したコードを[リスト13.40](/chapters/user_microposts?version=5.1#code-micropost_instance_variable)に示します。

リスト 13.40: `home`アクションにマイクロポストのインスタンス変数を追加する `app/controllers/static_pages_controller.rb`
```ruby
class StaticPagesController < ApplicationController

  def home
    @micropost = current_user.microposts.build if logged_in?
  end

  def help
  end

  def about
  end

  def contact
  end
end
```

もちろん、`current_user`メソッドはユーザーがログインしているときしか使えません。したがって、`@micropost`変数もログインしているときのみ定義されるようになります。

[リスト13.39](/chapters/user_microposts?version=5.1#code-micropost_form)を動かすためのもう1つの変更は、エラーメッセージのパーシャルを再定義することです。でなければ、[リスト13.39](/chapters/user_microposts?version=5.1#code-micropost_form)の次のコードが動きません。

``
[リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages)ではエラーメッセージパーシャルが`@user`変数を直接参照していたことを思い出してください。今回は代わりに`@micropost`変数を使う必要があります。これらのケースをまとめると、フォーム変数`f`を`f.object`とすることによって、関連付けられたオブジェクトにアクセスすることができます。したがって、

`form_for(@user) do |f|`

上のように`f.object`が`@user`となる場合と、

`form_for(@micropost) do |f|`

上のように`f.object`が`@micropost`になる場合などがあります。

パーシャルにオブジェクトを渡すために、値がオブジェクトで、キーがパーシャルでの変数名と同じハッシュを利用します。これで、[リスト13.39](/chapters/user_microposts?version=5.1#code-micropost_form)の2行目のコードが完成します。言い換えると、`object: f.object`は`error_messages`パーシャルの中で`object`という変数名を作成してくれるので、この変数を使ってエラーメッセージを更新すればよいということです ([リスト13.41](/chapters/user_microposts?version=5.1#code-updated_error_messages_partial))。

リスト 13.41: Userオブジェクト以外でも動作するようにerror_messagesパーシャルを更新する **red** `app/views/shared/_error_messages.html.erb`
```erb
<% if object.errors.any? %>
  <div id="error_explanation">
    <div class="alert alert-danger">
      The form contains <%= pluralize(object.errors.count, "error") %>.
    </div>
    <ul>
    <% object.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```
この時点でテストを走らせてみてください。テストが **red**のままになっています。

リスト 13.42: **red**
```sh
$ rails test
```
なぜ失敗しているのでしょうか。ヒントは`error_messages`パーシャルの他の出現場所です。このパーシャルは他の場所でも使われていたため、ユーザー登録 ([リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages))、パスワード再設定 ([リスト12.14](/chapters/password_reset?version=5.1#code-password_reset_form))、そしてユーザー編集 ([リスト10.2](/chapters/updating_and_deleting_users?version=5.1#code-user_edit_view)) のそれぞれのビューを更新する必要があったのです。各ビューを更新した結果を、[リスト13.43](/chapters/user_microposts?version=5.1#code-signup_errors_updated)、[リスト13.45](/chapters/user_microposts?version=5.1#code-password_reset_updated)、[リスト13.44](/chapters/user_microposts?version=5.1#code-edit_errors_updated)に示します。

リスト 13.43: ユーザー登録時のエラー表示を更新する `app/views/users/new.html.erb`
```erb
<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
      <%= render 'shared/error_messages', object: f.object %>
      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
```
リスト 13.44: ユーザー編集時のエラー表示を更新する `app/views/users/edit.html.erb`
```erb
<% provide(:title, "Edit user") %>
<h1>Update your profile</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
      <%= render 'shared/error_messages', object: f.object %>

      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Save changes", class: "btn btn-primary" %>
    <% end %>

    <div class="gravatar_edit">
      <%= gravatar_for @user %>
      <a href="http://gravatar.com/emails">change</a>
    </div>
  </div>
</div>
```
リスト 13.45: パスワード再設定時のエラー表示を更新する `app/views/password_resets/edit.html.erb`
```erb
<% provide(:title, 'Reset password') %>
<h1>Password reset</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user, url: password_reset_path(params[:id])) do |f| %>
      <%= render 'shared/error_messages', object: f.object %>

      <%= hidden_field_tag :email, @user.email %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Update password", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
```
これで、すべてのテストが **green**になるはずです。
```sh
$ rails test
```
さらに、この章で作成したすべてのHTMLが適切に表示されるようになったはずです。最終的なフォームを[図13.11](/chapters/user_microposts?version=5.1#fig-home_with_form)に、投稿エラーが表示されたフォームを[図13.12](/chapters/user_microposts?version=5.1#fig-home_form_errors)に示します。

図 13.11: 新しいマイクロポストフォームのあるHomeページ

図 13.12: エラーが表示されたHomeページ

#### [演習](#sec-exercises_creating_microposts)

1.  Homeページをリファクタリングして、`if`-`else`文の分岐のそれぞれに対してパーシャルを作ってみましょう。

### [13.3.3 フィードの原型](/chapters/user_microposts?version=5.1#sec-a_proto_feed)

マイクロポスト投稿フォームが動くようになりましたが、今の段階では投稿した内容をすぐに見ることができません。というのも、Homeページにまだマイクロポストを表示する部分が実装されていないからです。

[図13.11](/chapters/user_microposts?version=5.1#fig-home_with_form)のフォームが正しく動作しているかどうかを確認したい場合、正しいエントリーを投稿した後、プロフィールページに移動してポストを表示すればよいのですが、これはかなり面倒な作業です。[図13.13](/chapters/user_microposts?version=5.1#fig-proto_feed_mockup)のモックアップで示したような、ユーザー自身のポストを含むマイクロポストのフィードがないと不便です ([第14章](/chapters/following_users?version=5.1#cha-following_users)ではフィードを汎用化し、_フォロー_しているユーザーのマイクロポストもフィードに表示する予定です)。

図 13.13: 試作フィードがあるHomeページのモックアップ

すべてのユーザーがフィードを持つので、`feed`メソッドはUserモデルで作るのが自然です。フィードの原型では、まずは現在ログインしているユーザーのマイクロポストをすべて取得してきます。なお、次章で完全なフィードを実装するため、今回は[11.3.3.1](/chapters/account_activation?version=5.1#sec-exercises_activation_test_and_refactoring)で紹介した`where`メソッドでこれを実現します。`User`モデルに変更を加えた結果を、[リスト13.46](/chapters/user_microposts?version=5.1#code-proto_status_feed)に示します[11](#cha-13_footnote-11) 。

リスト 13.46: マイクロポストのステータスフィードを実装するための準備 `app/models/user.rb`
```ruby

class User < ApplicationRecord
  .
  .
  .
  # 試作feedの定義
  # 完全な実装は次章の「ユーザーをフォローする」を参照
  def feed
    Micropost.where("user_id = ?", id)
  end

    private
    .
    .
    .
end
```

次のコードで使われている疑問符は、セキュリティ上重要な役割を果たしています。

`Micropost.where("user_id = ?", id)`

上の疑問符があることで、SQLクエリに代入する前に`id`が_エスケープ_されるため、[_SQLインジェクション (SQL Injection)_](https://ja.wikipedia.org/wiki/SQL%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3) と呼ばれる深刻なセキュリティホールを避けることができます。この場合の`id`属性は単なる整数 (すなわち`self.id`はユーザーのid) であるため危険はありませんが、SQL文に変数を代入する場合は_常に_エスケープする習慣をぜひ身につけてください。

注意深い読者は、[リスト13.46](/chapters/user_microposts?version=5.1#code-proto_status_feed)のコードは本質的に次のコードと同等であることに気付くかもしれません。
```ruby
def feed
  microposts
end
```
上のコードを使わずにあえて[リスト13.46](/chapters/user_microposts?version=5.1#code-proto_status_feed)のコードを使ったのは、[第14章](/chapters/following_users?version=5.1#cha-following_users)で必要になる完全なステータスフィードで応用が効くためです。

サンプルアプリケーションにフィード機能を導入するため、ログインユーザーのフィード用にインスタンス変数`@feed_items`を追加し ([リスト13.47](/chapters/user_microposts?version=5.1#code-feed_instance_variable))、Homeページにはフィード用のパーシャルを追加します ([リスト13.48](/chapters/user_microposts?version=5.1#code-feed_partial))。Homeページに変更を加えた結果は[リスト13.49](/chapters/user_microposts?version=5.1#code-home_with_feed)になります。このとき、ユーザーがログインしているかどうかを調べる後置if文が変化している点に注目してください。すなわち、[リスト13.47](/chapters/user_microposts?version=5.1#code-feed_instance_variable)では、

@micropost = current_user.microposts.build if logged_in?

上の[リスト13.40](/chapters/user_microposts?version=5.1#code-micropost_instance_variable)のコードが、次のような前置if文に変わっています。
```ruby
if logged_in?
  @micropost  = current_user.microposts.build
  @feed_items = current_user.feed.paginate(page: params[:page])
end
```
(訳注: 1行のときは後置if文、2行以上のときは前置if文を使うのがRubyの慣習です。)

リスト 13.47: `home`アクションにフィードのインスタンス変数を追加する `app/controllers/static_pages_controller.rb`
```ruby

class StaticPagesController < ApplicationController

  def home
    if logged_in?
      @micropost  = current_user.microposts.build
      @feed_items = current_user.feed.paginate(page: params[:page])
    end
  end

  def help
  end

  def about
  end

  def contact
  end
end
```

リスト 13.48: ステータスフィードのパーシャル `app/views/shared/_feed.html.erb`
```erb
<% if @feed_items.any? %>
  <ol class="microposts">
    <%= render @feed_items %>
  </ol>
  <%= will_paginate @feed_items %>
<% end %>
```
ステータスフィードのパーシャルは、Micropostのパーシャル ([リスト13.22](/chapters/user_microposts?version=5.1#code-micropost_partial)) とは異なっている点に注目してください。

<%= render @feed_items %>

このとき、`@feed_items`の各要素が`Micropost`クラスを持っていたため、RailsはMicropostのパーシャルを呼び出すことができました。このように、Railsは対応する名前のパーシャルを、渡されたリソースのディレクトリ内から探しにいくことができます。

app/views/microposts/_micropost.html.erb

後は、いつものようにフィードパーシャルを表示すればHomeページにフィードを追加できます ([リスト13.49](/chapters/user_microposts?version=5.1#code-home_with_feed))。この結果はHomeページのフィードとして表示されます ([図13.14](/chapters/user_microposts?version=5.1#fig-home_with_proto_feed))。

リスト 13.49: Homeページにステータスフィードを追加する `app/views/static_pages/home.html.erb`
```erb
<% if logged_in? %>
  <div class="row">
    <aside class="col-md-4">
      <section class="user_info">
        <%= render 'shared/user_info' %>
      </section>
      <section class="micropost_form">
        <%= render 'shared/micropost_form' %>
      </section>
    </aside>
    <div class="col-md-8">
      <h3>Micropost Feed</h3>
      <%= render 'shared/feed' %>
    </div>
  </div>
<% else %>
  .
  .
  .
<% end %>
```
図 13.14: 試作フィードのあるHomeページ

現時点では、新しいマイクロポストの作成は[図13.15](/chapters/user_microposts?version=5.1#fig-micropost_created)で示したように期待どおりに動作しています。ただしささいなことではありますが、マイクロポストの投稿が_失敗する_と、 Homeページは`@feed_items`インスタンス変数を期待しているため、現状では壊れてしまいます。最も簡単な解決方法は、[リスト13.50](/chapters/user_microposts?version=5.1#code-microposts_create_action_with_feed)のように空の配列を渡しておくことです。残念ですが、この場合はページ分割されたフィードを返してもうまく動きません。動かない理由を確認したい方は、実際に実装してページネーションのリンクをクリックしてみてください。

図 13.15: 新しいマイクロポストを作成した直後のHomeページ

リスト 13.50: `create`アクションに空の`@feed_items`インスタンス変数を追加する `app/controllers/microposts_controller.rb`
```ruby

class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create, :destroy]

  def create
    @micropost = current_user.microposts.build(micropost_params)
    if @micropost.save
      flash[:success] = "Micropost created!"
      redirect_to root_url
    else
      @feed_items = []
      render 'static_pages/home'
    end
  end

  def destroy
  end

  private

    def micropost_params
      params.require(:micropost).permit(:content)
    end
end
```

#### [演習](#sec-exercises_a_proto_feed)

1.  新しく実装したマイクロポストの投稿フォームを使って、実際にマイクロポストを投稿してみましょう。Railsサーバーのログ内にある`INSERT`文では、どういった内容をデータベースに送っているでしょうか? 確認してみてください。
2.  コンソールを開き、`user`変数にデータベース上の最初のユーザーを代入してみましょう。その後、`Micropost.where("user_id = ?", user.id)`と`user.microposts`、そして`user.feed`をそれぞれ実行してみて、実行結果がすべて同じであることを確認してみてください。_ヒント_: `==`で比較すると結果が同じかどうか簡単に判別できます。

### [13.3.4 マイクロポストを削除する](/chapters/user_microposts?version=5.1#sec-destroying_microposts)

最後の機能として、マイクロポストリソースにポストを削除する機能を追加します。これはユーザー削除と同様に([10.4.2](/chapters/updating_and_deleting_users?version=5.1#sec-the_destroy_action))、"delete" リンクで実現します ([図13.16](/chapters/user_microposts?version=5.1#fig-micropost_delete_links_mockup))。ユーザーの削除は管理者ユーザーのみが行えるように制限されていたのに対し、今回は自分が投稿したマイクロポストに対してのみ削除リンクが動作するようにします。

図 13.16: マイクロポストの削除リンクと試作フィードのモックアップ

最初のステップとして、マイクロポストのパーシャル ([リスト13.22](/chapters/user_microposts?version=5.1#code-micropost_partial)) に削除リンクを追加します。作成したコードを[リスト13.51](/chapters/user_microposts?version=5.1#code-micropost_partial_with_delete)に示します。

リスト 13.51: マイクロポストのパーシャルに削除リンクを追加する `app/views/microposts/_micropost.html.erb`
```erb
<li id="micropost-<%= micropost.id %>">
  <%= link_to gravatar_for(micropost.user, size: 50), micropost.user %>
  <span class="user"><%= link_to micropost.user.name, micropost.user %></span>
  <span class="content"><%= micropost.content %></span>
  <span class="timestamp">
    Posted <%= time_ago_in_words(micropost.created_at) %> ago.
    <% if current_user?(micropost.user) %>
      <%= link_to "delete", micropost, method: :delete,
                                       data: { confirm: "You sure?" } %>
    <% end %>
  </span>
</li>
```
次に、Micropostsコントローラの`destroy`アクションを定義しましょう。これも、ユーザーにおける実装 ([リスト10.59](/chapters/updating_and_deleting_users?version=5.1#code-admin_destroy_before_filter)) とだいたい同じです。大きな違いは、`admin_user`フィルターで`@user`変数を使うのではなく、関連付けを使ってマイクロポストを見つけるようにしている点です。これにより、あるユーザーが他のユーザーのマイクロポストを削除しようとすると、自動的に失敗するようになります。具体的には、`correct_user`フィルター内で`find`メソッドを呼び出すことで、現在のユーザーが削除対象のマイクロポストを保有しているかどうかを確認します。作成したコードを[リスト13.52](/chapters/user_microposts?version=5.1#code-microposts_destroy_action)に示します。

リスト 13.52: Micropostsコントローラの`destroy`アクション `app/controllers/microposts_controller.rb`
```ruby

class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create, :destroy]
  before_action :correct_user,   only: :destroy
  .
  .
  .
  def destroy
    @micropost.destroy
    flash[:success] = "Micropost deleted"
    redirect_to request.referrer || root_url
  end

  private

    def micropost_params
      params.require(:micropost).permit(:content)
    end

    def correct_user
      @micropost = current_user.microposts.find_by(id: params[:id])
      redirect_to root_url if @micropost.nil?
    end
end
```

このとき、 [リスト13.52](/chapters/user_microposts?version=5.1#code-microposts_destroy_action)の`destroy`メソッドではリダイレクトを使っている点に注目してください。

request.referrer || root_url

ここでは`request.referrer`というメソッドを使っています[12](#cha-13_footnote-12) 。このメソッドはフレンドリーフォワーディングの`request.url`変数 ([10.2.3](/chapters/updating_and_deleting_users?version=5.1#sec-friendly_forwarding)) と似ていて、一つ前のURLを返します (今回の場合、Homeページになります)[13](#cha-13_footnote-13) 。このため、マイクロポストがHomeページから削除された場合でもプロフィールページから削除された場合でも、`request.referrer`を使うことでDELETEリクエストが発行されたページに戻すことができるので、非常に便利です。ちなみに、元に戻すURLが見つからなかった場合でも (例えばテストでは`nil`が返ってくることもあります)、[リスト13.52](/chapters/user_microposts?version=5.1#code-microposts_destroy_action)の`||`演算子で`root_url`をデフォルトに設定しているため、大丈夫です。([リスト9.24](/chapters/advanced_login?version=5.1#code-test_helper_log_in)で定義したデフォルトオプションと比較してみてください。)

これらのコードにより、上から2番目のマイクロポストを削除すると、[図 13.17](/chapters/user_microposts?version=5.1#fig-home_post_delete)のようにうまく動くはずです。

図 13.17: 2番目に新しいマイクロポストを削除した後のユーザーHomeページ

#### [演習](#sec-exercises_destroying_microposts)

1.  マイクロポストを作成し、その後、作成したマイクロポストを削除してみましょう。次に、Railsサーバーのログを見てみて、`DELETE`文の内容を確認してみてください。
2.  `redirect_to request.referrer || root_url`の行を`redirect_back(fallback_location: root_url)`と置き換えてもうまく動くことを、ブラウザを使って確認してみましょう (このメソッドはRails5から新たに導入されました)。

### [13.3.5 フィード画面のマイクロポストをテストする](/chapters/user_microposts?version=5.1#sec-micropost_tests)

[13.3.4](/chapters/user_microposts?version=5.1#sec-destroying_microposts)のコードで、Micropostモデルとそのインターフェースが完成しました。 残っている箇所は、Micropostsコントローラの認可をチェックする短いテストと、それらをまとめる統合テストを書くことです。

まずはマイクロポスト用のfixtureに、別々のユーザーに紐付けられたマイクロポストを追加していきます ([リスト13.53](/chapters/user_microposts?version=5.1#code-add_micropost_different_owner))。(今はこのうちの1つしか使いませんが、あとで他のマイクロポストも利用していきます。)

リスト 13.53: 別のユーザーに所属しているマイクロポストを追加する `test/fixtures/microposts.yml`
```yml
.
.
.
ants:
  content: "Oh, is that what you want? Because that's how you get ants!"
  created_at: <%= 2.years.ago %>
  user: archer

zone:
  content: "Danger zone!"
  created_at: <%= 3.days.ago %>
  user: archer

tone:
  content: "I'm sorry. Your words made sense, but your sarcastic tone did not."
  created_at: <%= 10.minutes.ago %>
  user: lana

van:
  content: "Dude, this van's, like, rolling probable cause."
  created_at: <%= 4.hours.ago %>
  user: lana
```
次に、自分以外のユーザーのマイクロポストは削除をしようとすると、適切にリダイレクトされることをテストで確認します ([リスト13.54](/chapters/user_microposts?version=5.1#code-micropost_user_mismatch_test))。

リスト 13.54: 間違ったユーザーによるマイクロポスト削除に対してテストする **green** `test/controllers/microposts_controller_test.rb`
```ruby
require 'test_helper'

class MicropostsControllerTest < ActionDispatch::IntegrationTest

  def setup
    @micropost = microposts(:orange)
  end

  test "should redirect create when not logged in" do
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: "Lorem ipsum" } }
    end
    assert_redirected_to login_url
  end

  test "should redirect destroy when not logged in" do
    assert_no_difference 'Micropost.count' do
      delete micropost_path(@micropost)
    end
    assert_redirected_to login_url
  end

  test "should redirect destroy for wrong micropost" do
    log_in_as(users(:michael))
    micropost = microposts(:ants)
    assert_no_difference 'Micropost.count' do
      delete micropost_path(micropost)
    end
    assert_redirected_to root_url
  end
end
```

最後に、統合テストを書きます。今回の統合テストでは、ログイン、マイクロポストのページ分割の確認、無効なマイクロポストを投稿、有効なマイクロポストを投稿、マイクロポストの削除、そして他のユーザーのマイクロポストには [delete] リンクが表示されないことを確認、といった順でテストしていきます。いつものように、統合テストを生成するところから始めましょう。
```sh
$ rails generate integration_test microposts_interface
```
     invoke  test_unit
      create    test/integration/microposts_interface_test.rb

先ほどの順で書いた統合テストは、[リスト13.55](/chapters/user_microposts?version=5.1#code-microposts_interface_test)のようになります。[リスト13.12](/chapters/user_microposts?version=5.1#code-micropost_validity_test_idiomatic)で書いたコードと、先ほどのステップが結合されている点に注意してください。

リスト 13.55: マイクロポストのUIに対する統合テスト **green** `test/integration/microposts_interface_test.rb`
```ruby
require 'test_helper'

class MicropostsInterfaceTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end

  test "micropost interface" do
    log_in_as(@user)
    get root_path
    assert_select 'div.pagination'
    # 無効な送信
    assert_no_difference 'Micropost.count' do
      post microposts_path, params: { micropost: { content: "" } }
    end
    assert_select 'div#error_explanation'
    # 有効な送信
    content = "This micropost really ties the room together"
    assert_difference 'Micropost.count', 1 do
      post microposts_path, params: { micropost: { content: content } }
    end
    assert_redirected_to root_url
    follow_redirect!
    assert_match content, response.body
    # 投稿を削除する
    assert_select 'a', text: 'delete'
    first_micropost = @user.microposts.paginate(page: 1).first
    assert_difference 'Micropost.count', -1 do
      delete micropost_path(first_micropost)
    end
    # 違うユーザーのプロフィールにアクセス (削除リンクがないことを確認)
    get user_path(users(:archer))
    assert_select 'a', text: 'delete', count: 0
  end
end
```

既にアプリケーション側のコードは実装してあるので、このテストは **green**になるはずです。

リスト 13.56: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_micropost_tests)

1.  [リスト13.55](/chapters/user_microposts?version=5.1#code-microposts_interface_test)で示した４つのコメント (「無効な送信」など) のそれぞれに対して、テストが正しく動いているか確認してみましょう。具体的には、対応するアプリケーション側のコードをコメントアウトし、テストが **red**になることを確認し、元に戻すと **green**になることを確認してみましょう。
2.  サイドバーにあるマイクロポストの合計投稿数をテストしてみましょう。このとき、単数形 (micropost) と複数形 (microposts) が正しく表示されているかどうかもテストしてください。_ヒント_: [リスト13.57](/chapters/user_microposts?version=5.1#code-sidebar_micropost_count)を参考にしてみてください。

リスト 13.57: サイドバーでマイクロポストの投稿数をテストするためのテンプレート `test/integration/microposts_interface_test.rb`
```ruby

require 'test_helper'

class MicropostInterfaceTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end
  .
  .
  .
  test "micropost sidebar count" do
    log_in_as(@user)
    get root_path
    assert_match "#{FILL_IN} microposts", response.body
    # まだマイクロポストを投稿していないユーザー
    other_user = users(:malory)
    log_in_as(other_user)
    get root_path
    assert_match "0 microposts", response.body
    other_user.microposts.create!(content: "A micropost")
    get root_path
    assert_match FILL_IN, response.body
  end
end
```

[13.4 マイクロポストの画像投稿](/chapters/user_microposts?version=5.1#sec-micropost_images)
-------------------------------------------------------------------------------

ここまででマイクロポストに関する基本的な操作はすべて実装できました。この節では、応用編として画像付きマイクロポストを投稿できるようにしてみます。手順としては、まずは開発環境用のβ版を実装し、その後、いくつかの改善をとおして本番環境用の完成版を実装します。

画像アップロード機能を追加するためには、2つの視覚的な要素が必要です。1つは画像をアップロードするためのフォーム、もう1つは投稿された画像そのものです。[Upload image] ボタンと画像付きマイクロポストのモックアップを[図13.18](/chapters/user_microposts?version=5.1#fig-micropost_image_mockup)に示します[14](#cha-13_footnote-14) 。

図 13.18: 画像付きマイクロポストを投稿したときのモックアップ

### [13.4.1 基本的な画像アップロード](/chapters/user_microposts?version=5.1#sec-basic_image_upload)

投稿した画像を扱ったり、その画像をMicropostモデルと関連付けするために、今回は[CarrierWave](https://github.com/carrierwaveuploader/carrierwave)という画像アップローダーを使います。まずは`carrierwave` gemを`Gemfile`に追加しましょう ([リスト13.58](/chapters/user_microposts?version=5.1#code-gemfile_carrierwave))[15](#cha-13_footnote-15) 。このとき、[リスト13.58](/chapters/user_microposts?version=5.1#code-gemfile_carrierwave)では`mini_magick` gemと`fog` gemsも含めている点に注目してください。これらのgemは画像をリサイズしたり ([13.4.3](/chapters/user_microposts?version=5.1#sec-image_resizing))、本番環境で画像をアップロードする ([13.4.4](/chapters/user_microposts?version=5.1#sec-image_upload_in_production)) ために使います。

[Rails 5.2](https://railsguides.jp/5_2_release_notes.html)から標準となった[Active Storage](https://railsguides.jp/active_storage_overview.html#active-storage%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)で投稿する方法については『[第6版](https://railstutorial.jp/webtext?utm_source=tutorial&utm_medium=text&utm_campaign=text_in_pr_60)』をご覧ください。

リスト 13.58: `Gemfile`にCarrierWaveを追加する
```Gemfile
source 'https://rubygems.org'

gem 'rails',                   '5.1.6'
gem 'bcrypt',                  '3.1.12'
gem 'faker',                   '1.7.3'
gem 'carrierwave',             '1.2.2'
gem 'mini_magick',             '4.7.0'
gem 'will_paginate',           '3.1.5'
gem 'bootstrap-will_paginate', '1.0.0'
.
.
.
group :production do
  gem 'pg',  '0.20.0'
  gem 'fog', '1.42'
  end
.
.
.
```
次に、いつものように`bundle install`を実行します。
```sh
$ bundle install
```
CarrierWaveを導入すると、Railsのジェネレーターで画像アップローダーが生成できるようになります。早速、次のコマンドを実行してみましょう (画像のことをimageとすると一般的過ぎるので、今回は`picture`と呼ぶことにします)[16](#cha-13_footnote-16) 。
```sh
$ rails generate uploader Picture
```
CarrierWaveでアップロードされた画像は、Active Recordモデルの属性と関連付けされているべきです。関連付けされる属性には画像のファイル名が格納されるため、String型にしておきます。拡張したマイクロポストのデータモデルを、[図13.19](/chapters/user_microposts?version=5.1#fig-micropost_model_picture)に示します。

図 13.19: `picture`属性を追加したマイクロポストのデータモデル

必要となる`picture`属性をMicropostモデルに追加するために、マイグレーションファイルを生成し、開発環境のデータベースに適用します。
```sh
$ rails generate migration add_picture_to_microposts picture:strin
$ rails db:migrate
```
CarrierWaveに画像と関連付けたモデルを伝えるためには、`mount_uploader`というメソッドを使います。このメソッドは、引数に属性名のシンボルと生成されたアップローダーのクラス名を取ります。

mount_uploader :picture, PictureUploader

(`picture_uploader.rb`というファイルで`PictureUploader`クラスが定義されています。[13.4.2](/chapters/user_microposts?version=5.1#sec-image_validation)で修正しますが、今はデフォルトのままで大丈夫です。) Micropostモデルにアップローダーを追加した結果を[リスト13.59](/chapters/user_microposts?version=5.1#code-micropost_model_picture)に示します。

リスト 13.59: Micropostモデルに画像を追加する `app/models/micropost.rb`
```ruby
class Micropost < ApplicationRecord
  belongs_to :user
  default_scope -> { order(created_at: :desc) }
  mount_uploader :picture, PictureUploader
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
end
```

システムによっては、ここで一旦Railsサーバーを再起動させる必要があります。再起動させたらテストスイートを走らせてみてください。 **green**になるはずです。(ただし、[3.6.2](/chapters/static_pages?version=5.1#sec-guard)で説明したGuardを使っている場合は、再起動させるだけではうまく動かないかもしれません。その場合はターミナルから一旦抜けて、新しいターミナルでGuardを再実行してみてください。)

[図 13.18](/chapters/user_microposts?version=5.1#fig-micropost_image_mockup)のようにHomeページにアップローダーを追加するためには、マイクロポストのフォームに`file_field`タグを含める必要があります ([リスト13.60](/chapters/user_microposts?version=5.1#code-micropost_create_image_upload))。[17](#cha-13_footnote-17)

リスト 13.60: マイクロポスト投稿フォームに画像アップローダーを追加する `app/views/shared/_micropost_form.html.erb`
```erb
<%= form_for(@micropost) do |f| %>
  <%= render 'shared/error_messages', object: f.object %>
  <div class="field">
    <%= f.text_area :content, placeholder: "Compose new micropost..." %>
  </div>
  <%= f.submit "Post", class: "btn btn-primary" %>
  <span class="picture">
    <%= f.file_field :picture %>
  </span>
<% end %>
```
最後に、Webから更新できる許可リストに`picture`属性を追加しましょう。追加すると、`micropost_params`メソッドは[リスト13.61](/chapters/user_microposts?version=5.1#code-micropost_params_picture)のようになります。

リスト 13.61: `picture`を許可された属性のリストに追加する `app/controllers/microposts_controller.rb`
```ruby
class MicropostsController < ApplicationController
  before_action :logged_in_user, only: [:create, :destroy]
  before_action :correct_user,   only: :destroy
  .
  .
  .
  private

    def micropost_params
      params.require(:micropost).permit(:content, :picture)
    end

    def correct_user
      @micropost = current_user.microposts.find_by(id: params[:id])
      redirect_to root_url if @micropost.nil?
    end
end
```

一度画像がアップロードされれば、Micropostパーシャルの`image_tag`ヘルパーでその画像を描画できるようになります ([リスト13.62](/chapters/user_microposts?version=5.1#code-micropost_partial_image_display))。また、画像の無い (テキストのみの) マイクロポストでは画像を表示させないようにするために、`picture?`という論理値を返すメソッドを使っている点に注目してください。このメソッドは、画像用の属性名に応じて、CarrierWaveが自動的に生成してくれるメソッドです。手動で画像付きの投稿をしてみると、[図13.20](/chapters/user_microposts?version=5.1#fig-micropost_with_image)のようになります。なお、画像アップロードに対するテストは、演習に回すことにします ([13.4.1.1](/chapters/user_microposts?version=5.1#sec-exercises_basic_image_upload))。

リスト 13.62: マイクロポストの画像表示を追加する `app/views/microposts/_micropost.html.erb`
```erb
<li id="micropost-<%= micropost.id %>">
  <%= link_to gravatar_for(micropost.user, size: 50), micropost.user %>
  <span class="user"><%= link_to micropost.user.name, micropost.user %></span>
  <span class="content">
    <%= micropost.content %>
    <%= image_tag micropost.picture.url if micropost.picture? %>
  </span>
  <span class="timestamp">
    Posted <%= time_ago_in_words(micropost.created_at) %> ago.
    <% if current_user?(micropost.user) %>
      <%= link_to "delete", micropost, method: :delete,
                                       data: { confirm: "You sure?" } %>
    <% end %>
  </span>
</li>
```
図 13.20: 画像付きマイクロポストを投稿した結果

#### [演習](#sec-exercises_basic_image_upload)

1.  画像付きのマイクロポストを投稿してみましょう。もしかして、大きすぎる画像が表示されてしまいましたか? (心配しないでください、次の[13.4.3](/chapters/user_microposts?version=5.1#sec-image_resizing)でこの問題を直します)。
2.  [リスト13.63](/chapters/user_microposts?version=5.1#code-image_upload_test)に示すテンプレートを参考に、[13.4](/chapters/user_microposts?version=5.1#sec-micropost_images)で実装した画像アップローダーをテストしてください。テストの準備として、まずはサンプル画像をfixtureディレクトリに追加してください (コマンド例: `cp app/assets/images/rails.png` `test/fixtures/`)。[リスト13.63](/chapters/user_microposts?version=5.1#code-image_upload_test)で追加したテストでは、Homeページにあるファイルアップロードと、投稿に成功した時に画像が表示されているかどうかをチェックしています。なお、テスト内にある`fixture_file_upload`というメソッドは、fixtureで定義されたファイルをアップロードする特別なメソッドです[18](#cha-13_footnote-18) 。_ヒント_: `picture`属性が有効かどうかを確かめるときは、[11.3.3](/chapters/account_activation?version=5.1#sec-activation_test_and_refactoring)で紹介した`assigns`メソッドを使ってください。このメソッドを使うと、投稿に成功した後に`create`アクション内のマイクロポストにアクセスするようになります。

リスト 13.63: 画像アップロードをテストするためのテンプレート `test/integration/microposts_interface_test.rb`
```ruby

require 'test_helper'

class MicropostInterfaceTest < ActionDispatch::IntegrationTest

  def setup
    @user = users(:michael)
  end

  test "micropost interface" do
    log_in_as(@user)
    get root_path
    assert_select 'div.pagination'
    assert_select 'input[type=FILL_IN]'
    # 無効な送信
    post microposts_path, params: { micropost: { content: "" } }
    assert_select 'div#error_explanation'
    # 有効な送信
    content = "This micropost really ties the room together"
    picture = fixture_file_upload('test/fixtures/rails.png', 'image/png')
    assert_difference 'Micropost.count', 1 do
      post microposts_path, params: { micropost:
                                      { content: content,
                                        picture: FILL_IN } }
    end
    assert FILL_IN.picture?
    follow_redirect!
    assert_match content, response.body
    # 投稿を削除する
    assert_select 'a', 'delete'
    first_micropost = @user.microposts.paginate(page: 1).first
    assert_difference 'Micropost.count', -1 do
      delete micropost_path(first_micropost)
    end
    # 違うユーザーのプロフィールにアクセスする
    get user_path(users(:archer))
    assert_select 'a', { text: 'delete', count: 0 }
  end
  .
  .
  .
end
```

### [13.4.2 画像の検証](/chapters/user_microposts?version=5.1#sec-image_validation)

[13.4.1](/chapters/user_microposts?version=5.1#sec-basic_image_upload)のアップローダーも悪くはありませんが、いくつかの目立つ欠点があります。例えば、アップロードされた画像に対する制限がないため、もしユーザーが巨大なファイルを上げたり、無効なファイルを上げると問題が発生してしまいます。この欠点を直すために、画像サイズやフォーマットに対するバリデーションを実装し、サーバー用とクライアント (ブラウザ) 用の両方に追加しましょう。

最初のバリデーションでは、有効な画像の種類を制限していきますが、これはCarrierWaveのアップローダーの中に既にヒントがあります。生成されたアップローダーの中にコメントアウトされたコードがありますが、ここのコメントアウトを取り消すことで、画像のファイル名から有効な拡張子 (PNG/GIF/JPEGなど) を検証することができます ([リスト13.64](/chapters/user_microposts?version=5.1#code-validate_picture_format))。

リスト 13.64: 画像フォーマットのバリデーション `app/uploaders/picture_uploader.rb`
```ruby

class PictureUploader < CarrierWave::Uploader::Base
  storage :file

  # アップロードファイルの保存先ディレクトリは上書き可能
  # 下記はデフォルトの保存先
  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  # アップロード可能な拡張子のリスト
  def extension_whitelist
    %w(jpg jpeg gif png)
  end
end
```

2つ目のバリデーションでは、画像のサイズを制御します。これは`Micropost`モデルに書き足していきます。先ほどのバリデーションとは異なり、ファイルサイズに対するバリデーションはRailsの既存のオプション (`presence`や`length`など) にはありません。したがって、今回は手動で`picture_size`という独自のバリデーションを定義します。結果は[リスト13.65](/chapters/user_microposts?version=5.1#code-micropost_model_image_validation)のとおりです。独自のバリデーションを定義するために、今まで使っていた`validates`メソッドではなく、`validate`メソッドを使っている点に注目してください。

リスト 13.65: 画像に対するバリデーションを追加する `app/models/micropost.rb`
```ruby

class Micropost < ApplicationRecord
  belongs_to :user
  default_scope -> { order(created_at: :desc) }
  mount_uploader :picture, PictureUploader
  validates :user_id, presence: true
  validates :content, presence: true, length: { maximum: 140 }
  validate  :picture_size

  private

    # アップロードされた画像のサイズをバリデーションする
    def picture_size
      if picture.size > 5.megabytes
        errors.add(:picture, "should be less than 5MB")
      end
    end
end
```

この`validate`メソッドでは、引数にシンボル (`:picture_size`) を取り、そのシンボル名に対応したメソッドを呼び出します。また、呼び出された`picture_size`メソッドでは、5MBを上限とし (文法は[コラム9.1](/chapters/advanced_login?version=5.1#aside-time_helpers)を参照)、それを超えた場合はカスタマイズしたエラーメッセージを`errors`コレクションに追加しています (`errors`については[6.2.2](/chapters/modeling_users?version=5.1#sec-presence_validation)で紹介しました)。

[リスト13.64](/chapters/user_microposts?version=5.1#code-validate_picture_format)や[リスト13.65](/chapters/user_microposts?version=5.1#code-micropost_model_image_validation)で定義した画像のバリデーションをビューに組み込むために、クライアント側に2つの処理を追加しましょう。まずはフォーマットのバリデーションを反映するためには、`file_field`タグに`accept`パラメータを付与して使います。

`<%= f.file_field :picture, accept: 'image/jpeg,image/gif,image/png' %>`

このときacceptパラメータでは、[リスト13.64](/chapters/user_microposts?version=5.1#code-validate_picture_format)で許可したファイル形式を、[MIMEタイプ](https://ja.wikipedia.org/wiki/Multipurpose_Internet_Mail_Extensions#Content-Type)で指定するようにします。

次に、大きすぎるファイルサイズに対して警告を出すために、ちょっとしたJavaScript (正確には[jQuery](http://jquery.com/)) を書き加えます。こうすることで、長すぎるアップロード時間を防いだり、サーバーへの負荷を抑えたりすることに繋がります。
```sh
$('#micropost_picture').bind('change', function() {
```
 var size_in_megabytes = this.files[0].size/1024/1024;
  if (size_in_megabytes > 5) {
    alert('Maximum file size is 5MB. Please choose a smaller file.');
  }
});

jQueryは本書のトピックではないので詳細な解説はしませんが、上のコードでは (ハッシュマーク`#`から分かるように) CSSidの`micropost_picture`を含んだ要素を見つけ出し、この要素を監視しています。そしてこのidを持った要素とは、[リスト13.60](/chapters/user_microposts?version=5.1#code-micropost_create_image_upload)にあるマイクロポストのフォームを指します (なお、ブラウザ上で画面を右クリックし、インスペクターで要素を調べることで確認できます)。つまり、このCSS idを持つ要素が変化したとき、このjQueryの関数が動き出します。そして、もしファイルサイズが大きすぎた場合、`alert`メソッドで警告を出すといった仕組みです[19](#cha-13_footnote-19) 。

これらの追加的なチェック機能をまとめると、[リスト13.66](/chapters/user_microposts?version=5.1#code-jquery_file_test)のようになります[20](#cha-13_footnote-20) 。

リスト 13.66: ファイルサイズをjQueryでチェックする `app/views/shared/_micropost_form.html.erb`
```erb
<%= form_for(@micropost) do |f| %>
  <%= render 'shared/error_messages', object: f.object %>
  <div class="field">
    <%= f.text_area :content, placeholder: "Compose new micropost..." %>
  </div>
  <%= f.submit "Post", class: "btn btn-primary" %>
  <span class="picture">
    <%= f.file_field :picture, accept: 'image/jpeg,image/gif,image/png' %>
  </span>
<% end %>

<script type="text/javascript">
  $('#micropost_picture').bind('change', function() {
    var size_in_megabytes = this.files[0].size/1024/1024;
    if (size_in_megabytes > 5) {
      alert('Maximum file size is 5MB. Please choose a smaller file.');
    }
  });
</script>
```
既にお気づきの読者もいるかもしれませんが、[リスト13.66](/chapters/user_microposts?version=5.1#code-jquery_file_test)のようなコードでは大きすぎるファイルのアップロードを完全には阻止できません。例えば、ユーザーはアラートを無視してアップロードを強行する、といったことが可能です。もし本書がjQueryチュートリアルであれば、この問題点と解決策を丁寧に説明しているところですが、本書はRailsチュートリアルなので、今回は「[リスト13.66](/chapters/user_microposts?version=5.1#code-jquery_file_test)のようなコードでは実装はまだ不完全である」という点だけ覚えておけば十分です。また、仮に送信フォームを使った投稿をうまく制限できても、ブラウザのインスペクタ機能でJavaScriptをいじったり、`curl`などを使って直接`POST`リクエストを送信する場合には対応しきれません。こういった場合にも対応できるようにするため、[リスト13.65](/chapters/user_microposts?version=5.1#code-micropost_model_image_validation)で実装したサーバー側のバリデーションが重要なのです。

#### [演習](#sec-exercises_image_validation)

1.  5MB以上の画像ファイルを送信しようとした場合、どうなりますか?
2.  無効な拡張子のファイルを送信しようとした場合、どうなりますか?

### [13.4.3 画像のリサイズ](/chapters/user_microposts?version=5.1#sec-image_resizing)

ファイルサイズに対するバリデーション ([13.4.2](/chapters/user_microposts?version=5.1#sec-image_validation)) はうまくいきましたが、画像サイズ (縦横の長さ) に対する制限はないので、大きすぎる画像サイズがアップロードされると[図13.21](/chapters/user_microposts?version=5.1#fig-large_uploaded_image)のようにレイアウトが壊れてしまいます。とはいえ、ユーザーに手元で画像サイズを変更させるのは不便です。なので、画像を表示させる前にサイズを変更する (リサイズする) ようにしてみましょう[21](#cha-13_footnote-21) 。

図 13.21: 恐ろしく大きなアップロード画像

画像をリサイズするためには、画像を操作するプログラムが必要になります。今回は[ImageMagick](http://www.imagemagick.org/)というプログラムを使うので、これを開発環境にインストールします ([13.4.4](/chapters/user_microposts?version=5.1#sec-image_upload_in_production)でも説明しますが、本番環境がHerokuであれば、既に本番環境でImageMagickが使えるようになっています)。クラウドIDEでは、次のコマンドでこのプログラムをインストールできます[22](#cha-13_footnote-22) 。
```sh
$ sudo yum install -y ImageMagick
```
(もしローカル環境で開発している場合、それぞれの環境に応じてImagiMagickをインストールする手順が異なります。例えばMacの場合であれば、[Homebrew](http://brew.sh/)を導入し、`brew install imagemagick`コマンドを使ってインストールします。もしインストールで躓いたら、[コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication)の考え方を参考にしてみてください。)

次に、[MiniMagick](https://github.com/minimagick/minimagick)というImageMagickとRubyを繋ぐgemを使って、画像をリサイズしてみましょう。[MiniMagickのドキュメント](http://www.rdoc.info/github/jnicklas/carrierwave/CarrierWave/MiniMagick) (英語) を見ると様々な方法でリサイズできることがわかりますが、今回は`resize_to_limit: [400, 400]`という方法を使います。これは、縦横どちらかが400pxを超えていた場合、適切なサイズに縮小するオプションです (ただし小さい画像であっても拡大はしません)。ちなみに[CarrierWaveのMiniMagickの項目](https://github.com/carrierwaveuploader/carrierwave#using-minimagick)を見ると、 小さすぎる画像を_引き延ばす_こともできるようですが、今回は使いません。したがって、最終的なコードは[リスト13.67](/chapters/user_microposts?version=5.1#code-image_uploader_resizing)のようになります。これにより、大きな画像サイズでも適切にリサイズされるようになります ([図13.22](/chapters/user_microposts?version=5.1#fig-resized_image))。

リスト 13.67: 画像をリサイズするために画像アップローダーを修正する `app/uploaders/picture_uploader.rb`
```ruby

class PictureUploader < CarrierWave::Uploader::Base
  include CarrierWave::MiniMagick
  process resize_to_limit: [400, 400]

  storage :file

  # アップロードファイルの保存先ディレクトリは上書き可能
  # 下記はデフォルトの保存先
  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  # アップロード可能な拡張子のリスト
  def extension_whitelist
    %w(jpg jpeg gif png)
  end
end
```

図 13.22: いい感じにリサイズされた画像

#### [演習](#sec-exercises_image_resizing)

1.  解像度の高い画像をアップロードし、リサイズされているかどうか確認してみましょう。画像が長方形だった場合、リサイズはうまく行われているでしょうか?
2.  既に[リスト13.63](/chapters/user_microposts?version=5.1#code-image_upload_test)のテストを追加していた場合、この時点でテストスイートを走らせると紛らわしいエラーメッセージが表示されることがあります。このエラーを取り除いてみましょう。_ヒント_: [リスト13.68](/chapters/user_microposts?version=5.1#code-skip_resize_initializer)にある設定ファイルを修正し、テスト時はCarrierWaveに画像のリサイズをさせないようにしてみましょう。

リスト 13.68: テスト時は画像のリサイズをさせない設定 `config/initializers/skip_image_resizing.rb`
```ruby

if Rails.env.test?
  CarrierWave.configure do |config|
    config.enable_processing = false
  end
end
```

### [13.4.4 本番環境での画像アップロード](/chapters/user_microposts?version=5.1#sec-image_upload_in_production)

(訳注: この項はスキップできます。もしうまくいかなければスキップしても問題ありません)

[13.4.3](/chapters/user_microposts?version=5.1#sec-image_resizing)で実装した画像アップローダーは、開発環境で動かす分には問題ないのですが、本番環境には適していません。これは[リスト13.67](/chapters/user_microposts?version=5.1#code-image_uploader_resizing)の`storage :file`という行によって、ローカルのファイルシステムに画像を保存するようになっているからです[23](#cha-13_footnote-23) 。本番環境では、ファイルシステムではなくクラウドストレージサービスに画像を保存するようにしてみましょう[24](#cha-13_footnote-24) 。

本番環境でクラウドストレージに保存するためには、[リスト13.69](/chapters/user_microposts?version=5.1#code-image_uploader_production)のように`fog` gemを使うと簡単です。

リスト 13.69: 本番環境での画像アップロードを調整する `app/uploaders/picture_uploader.rb`
```ruby

class PictureUploader < CarrierWave::Uploader::Base
  include CarrierWave::MiniMagick
  process resize_to_limit: [400, 400]

  if Rails.env.production?
    storage :fog
  else
    storage :file
  end

  # アップロードファイルの保存先ディレクトリは上書き可能
  # 下記はデフォルトの保存先
  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  # アップロード可能な拡張子のリスト
  def extension_whitelist
    %w(jpg jpeg gif png)
  end
end
```

[リスト13.69](/chapters/user_microposts?version=5.1#code-image_uploader_production)では`production?`という論理値を返すメソッドを使っています。このメソッドは[コラム7.1](/chapters/sign_up?version=5.1#aside-rails_environments)でも紹介しましたが、これを使うと環境毎に保存先を切り替えることができます。
```ruby
if Rails.env.production?
  storage :fog
else
  storage :file
end
```
世の中には多くのクラウドストレージサービスがありますが、今回は有名で信頼性も高いアマゾンの「[Simple Storage Service (S3)](http://aws.amazon.com/s3/)[25](#cha-13_footnote-25) 」を使います。セットアップの手順は次のとおりです。

1.  ([1.2.1](/chapters/beginning?version=5.1#sec-development_environment)でAWSアカウントを作成していない場合) [Amazon Web Services](http://aws.amazon.com/)アカウントにサインアップする
2.  [AWS Identity and Access Management (IAM)](http://aws.amazon.com/iam/)でユーザーを作成し、AccessキーとSecretキーをメモする
3.  [AWS Console](https://console.aws.amazon.com/s3)からS3 bucketを作成し (bucketの名前はなんでも大丈夫です)、2.で作成したユーザーに対してRead権限とWrite権限を付与する

(S3のセットアップはやや高度です。[コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication)の考え方をうまく活用してみてください。)

より詳細について知りたい場合は、[S3のドキュメント](http://aws.amazon.com/documentation/s3/) (英語)[26](#cha-13_footnote-26) を読んだり、GoogleやStack Overflowで検索してみたりしてください。

S3アカウントの作成と設定が終わったら、CarrierWaveの設定ファイルを次の[リスト13.70](/chapters/user_microposts?version=5.1#code-carrier_wave_configuration)のように修正してください。

_訳注_: fogでリージョンを指定する場合は `:region => ENV['S3_REGION']` といったパラメータを渡し、`heroku config:set S3_REGION="リージョン名"` といったコマンドを実行することで設定できます。なお、東京のリージョン名は "ap-northeast-1" です。詳細は[Amazon Web Serviceのリージョンとエンドポイント](http://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#s3_region)を参照してください。

リスト 13.70: CarrierWaveを通してS3を使うように修正する `config/initializers/carrier_wave.rb`
```ruby
if Rails.env.production?
  CarrierWave.configure do |config|
    config.fog_credentials = {
      # Amazon S3用の設定
      :provider              => 'AWS',
      :region                => ENV['S3_REGION'],     # 例: 'ap-northeast-1'
      :aws_access_key_id     => ENV['S3_ACCESS_KEY'],
      :aws_secret_access_key => ENV['S3_SECRET_KEY']
    }
    config.fog_directory     =  ENV['S3_BUCKET']
  end
end
```

本番環境のメール設定 ([リスト11.41](/chapters/account_activation?version=5.1#code-sendgrid_config)) と同様に、[リスト13.70](/chapters/user_microposts?version=5.1#code-carrier_wave_configuration)ではHerokuの環境変数 `ENV` を使って、機密情報が漏洩しないようにしています。[11.4](/chapters/account_activation?version=5.1#sec-activation_email_in_production)や[12.4](/chapters/password_reset?version=5.1#sec-reset_email_in_production)では、SendGridのアドオンがこれらの環境変数を自動的に設定してくれましたが、今回は手動で設定する必要があります。`heroku config:set`コマンドを使って、次のようにHeroku上の環境変数を設定してください。

```sh
$ heroku config:set S3_ACCESS_KEY="ココに先ほどメモしたAccessキーを入力"
$ heroku config:set S3_SECRET_KEY="同様に、Secretキーを入力"
$ heroku config:set S3_BUCKET="Bucketの名前を入力
```sh
$ heroku config:set S3_REGION="Regionの名前を入力"
```
設定が無事に終わったら、これまでの変更をコミットしたりデプロイする準備が整いました。ただし、その前に`.gitignore`ファイルを[リスト13.71](/chapters/user_microposts?version=5.1#code-gitignore_uploads)のように更新しおきましょう。これにより、画像を保存するディレクトリがGitへの保存対象から除かれるので、アプリケーションと関係の無い画像ファイルなどが無視できるようになります。

リスト 13.71: `.gitignore`ファイルにアップロード用ディレクトリを追加する

.
.
.
# アップロードされたテスト画像を無視する
/public/uploads

それでは、これまでの変更をトピックブランチにコミットし、masterブランチにマージしていきましょう。

```sh
$ rails test
$ git add -A
$ git commit -m "Add user microposts"
$ git checkout master
$ git merge user-micropost
$ git push
```
次に、Herokuへのデプロイ、データベースのリセット、サンプルデータの生成を順に実行していきます。

```sh
$ git push heroku
$ heroku pg:reset DATABASE
$ heroku run rails db:migrat
$ heroku run rails db:seed
```
Herokuには既にImageMagickがインストールされているので、(設定がうまくいっていれば) 画像リサイズや本番での画像アップロードも成功します。次の[図13.23](/chapters/user_microposts?version=5.1#fig-image_upload_production)のようになっていれば成功です。

図 13.23: 本番環境での画像アップロード

#### [演習](#sec-exercises_image_upload_in_production)

1.  本番環境で解像度の高い画像をアップロードし、適切にリサイズされているか確認してみましょう。長方形の画像であっても、適切にリサイズされていますか?

[13.5 最後に](/chapters/user_microposts?version=5.1#sec-user_microposts_conclusion)
--------------------------------------------------------------------------------

Micropostsリソースの追加によって、サンプルアプリケーションはほぼ完成に近づきました。残すところは、ユーザーをお互いにフォローするソーシャルな仕組みのみとなります。[第14章](/chapters/following_users?version=5.1#cha-following_users)では、そのようなユーザー同士の関係 (リレーションシップ) をモデリングする方法を学び、それがマイクロポストのフィードにどのように関連するかを学びます。

もし[13.4.4](/chapters/user_microposts?version=5.1#sec-image_upload_in_production)をスキップしていたら、ここで今までの変更のコミットとマージを済ませてください。

```sh
$ rails test
$ git add -A
$ git commit -m "Add user microposts"
$ git checkout master
$ git merge user-micropost
$ git push
```
準備ができたら、本番環境へデプロイしてみましょう。

```sh
$ git push heroku
$ heroku pg:reset DATABASE
$ heroku run rails db:migrat
$ heroku run rails db:seed
```
なお、必要なgemのインストールはこれで終わりです。今後、新たなgemを追加することはありません。参考までに、最終状態の`Gemfile`を[リスト13.72](/chapters/user_microposts?version=5.1#code-final_gemfile)に示します[27](#cha-13_footnote-27) 。

リスト 13.72: サンプルアプリケーションの`Gemfile` (完成) `Gemfile`
```yml
source 'https://rubygems.org'

gem 'rails',                   '5.1.6'
gem 'bcrypt',                  '3.1.12'
gem 'faker',                   '1.7.3'
gem 'carrierwave',             '1.2.2'
gem 'mini_magick',             '4.7.0'
gem 'will_paginate',           '3.1.6'
gem 'bootstrap-will_paginate', '1.0.0'
gem 'bootstrap-sass',          '3.3.7'
gem 'puma',                    '3.9.1'
gem 'sass-rails',              '5.0.6'
gem 'uglifier',                '3.2.0'
gem 'coffee-rails',            '4.2.2'
gem 'jquery-rails',            '4.3.1'
gem 'turbolinks',              '5.0.1'
gem 'jbuilder',                '2.7.0'

group :development, :test do
  gem 'sqlite3', '1.3.13'
  gem 'byebug',  '9.0.6', platform: :mri
end

group :development do
  gem 'web-console',           '3.5.1'
  gem 'listen',                '3.1.5'
  gem 'spring',                '2.0.2'
  gem 'spring-watcher-listen', '2.0.1'
end

group :test do
  gem 'rails-controller-testing', '1.0.2'
  gem 'minitest',                 '5.10.3'
  gem 'minitest-reporters',       '1.1.14'
  gem 'guard',                    '2.14.1'
  gem 'guard-minitest',           '2.4.6'
end

group :production do
  gem 'pg',   '0.20.0'
  gem 'fog',  '1.42'
end
```
# Windows環境ではtzinfo-dataというgemを含める必要があります
`gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]`

### [13.5.1 本章のまとめ](/chapters/user_microposts?version=5.1#sec-user_microposts_what_we_learned_in_this_chapter)

*   Active Recordモデルの力によって、マイクロポストも (ユーザーと同じで) リソースとして扱える
*   Railsは複数のキーインデックスをサポートしている
*   Userは複数のMicropostsを持っていて (`has_many`)、Micropostは1人のUserに依存している (`belongs_to`) といった関係性をモデル化した
*   `has_many`や`belongs_to`を利用することで、関連付けを通して多くのメソッドが使えるようになった
*   `user.microposts.build(...)`というコードは、引数で与えたユーザーに関連付けされたマイクロポストを返す
*   `default_scope`を使うとデフォルトの順序を変更できる
*   `default_scope`は引数に無名関数 (->) を取る
*   `dependent: :destroy`オプションを使うと、関連付けされたオブジェクトと自分自身を同時に削除する
*   paginateメソッドやcountメソッドは、どちらも関連付けを通して実行され、効率的にデータベースに問い合わせしている
*   fixtureは、関連付けを使ったオブジェクトの作成もサポートしている
*   パーシャルを呼び出すときに、一緒に変数を渡すことができる
*   `where`メソッドを使うと、Active Recordを通して選択 (部分集合を取り出すこと) ができる
*   依存しているオブジェクトを作成/削除するときは、常に関連付けを通すようにすることで、よりセキュアな操作が実現できる
*   CarrierWaveを使うと画像アップロードや画像リサイズができる


[^1.]: この名前はTwitterの_マイクロブログ_という説明文から着想を得ました。ブログにはポストがあるので、マイクロブログがあればマイクロポストもある、といった具合です。
[^2.]: www.postgresql.org/docs/9.1/static/datatype-character.html
[^3.]: 外部キー参照は、データベースレベルでの制約です。これによって、`microposts`テーブルの`user_id`は、`Users`テーブルのidカラムを参照するようになります。本チュートリアルでこの詳細が重要になることはありません。また、この外部キーによる制約は、すべてのデータベースで使えるわけではありません (例えばHerokuのPostgreSQLではサポートされていますが、開発用のSQLiteではサポートされていません)。外部キーの詳細は[14.1.2](/chapters/following_users?version=5.1#sec-relationship_user_associations)で学びます。
[^4.]: ユーザー一覧を実装するときも ([10.5](/chapters/updating_and_deleting_users?version=5.1#sec-updating_and_deleting_users_conclusion))、似たような問題にぶつかりました。
[^5.]: SQLは大文字小文字を区別しませんが、慣習的にSQLのキーワード ( `DESC`など) は大文字で書くことになっています。
[^6.]: `Faker::Lorem.sentence`は、_lorem ipsum_と呼ばれるダミーのテキストを返します。ちなみに[第6章](/chapters/modeling_users?version=5.1#cha-modeling_users)でも触れましたが、_lorem ipsum_には面白い[裏話](http://www.straightdope.com/columns/read/2290/what-does-the-filler-text-lorem-ipsum-mean)があります。
[^7.]: Faker gemの_lorem ipsum_サンプルテキストはランダムに生成される仕様になっているため、サンプルマイクロポストの内容はこの図と違っているはずです。
[^8.]: 便宜上、[リスト13.26](/chapters/user_microposts?version=5.1#code-micropost_css)はこの章で必要なCSSを_すべて_含んでいます。
[^9.]: もし`full_title`ヘルパーを使って他のテストもリファクタリングしたくなったら (例えば[リスト3.30](/chapters/static_pages?version=5.1#code-base_title_test)など)、`test_helper.rb`からApplicationヘルパーを読み込んでください。
[^10.]: JavaやC++といった言語の挙動とは異なり、RubyのPrivateメソッドは継承クラスからも[呼び出すことができる](http://stackoverflow.com/questions/3534449/why-does-ruby-have-both-private-and-protected-methods/3534581#3534581)点に注意してください。この違いを指摘をしてくれたVishal Antonyに感謝します。
[^11.]: `where`メソッドや他の関連するメソッドの詳細については、Railsガイドの[Active Record クエリインターフェイス](http://railsguides.jp/active_record_querying.html)を読んでください。
[^12.]: これは、HTTPの仕様として定義されている`HTTP_REFERER`と対応しています。ちなみに「referer」は誤字ではありません。HTTPの仕様では、確かにこの間違ったスペルを使っているのです。一方、Railsは「referrer」という正しいスペルで使っています。
[^13.]: 私もRailsがどうやってこのURLを取得しているのか、パッと思い出すことはできませんでした。そこで、Googleで「rails request previous url」と検索し、[Stack Overflowのスレッド](http://stackoverflow.com/questions/4652084/ruby-on-rails-how-do-you-get-the-previous-url)を見つけ、この答えに至りました。
[^14.]: 画像の引用元: https://www.flickr.com/photos/grungepunk/14026922186, 2014-09-19. Copyright © 2014 by Jussie D.Brito. ( [Creative Commons Attribution-ShareAlike 2.0 Generic](https://creativecommons.org/licenses/by-sa/2.0/) ライセンス)
[^15.]: これまでと同様に、Gemfileで指定した各gemのバージョンは[gemfiles-4th-ed.railstutorial.org](http://gemfiles-4th-ed.railstutorial.org/)と一致している必要があります。もしうまく次に進めない場合はチェックしてみてください。
[^16.]: 最初は`image`という属性名を使っていたのですが、この名前だと一般的すぎて、逆に混乱を招いてしまいました。
[^17.]: [8.1.2](/chapters/basic_login?version=5.1#sec-login_form)で少し触れましたが、`form_tag`を使ってファイルをアップロードさせたい場合は`html: { multipart: true }`オプションを渡す必要があります。一方、`form_for`を使う場合、必要となる[マルチパートに渡すオプション](http://stackoverflow.com/questions/4526273/what-does-enctype-multipart-form-data-mean)は、Railsが[自動的に追加](http://stackoverflow.com/a/26320725)してくれます。この点について指摘してくれたAlan Cruzに感謝します。
[^18.]: クラウドIDEで開発してれば大丈夫ですが、Windows上で開発している場合は、次のように`:binary`パラメーターを追加してください。`fixture_file_upload(file, type, :binary)`.
[^19.]: この手のトピックを学ぶには「Googleで「javascript maximum file size」といった関連するキーワードで検索し、Stack Overflowが見つかるまで (検索ワードを調整しながら) 繰り返す」、これが一番です。
[^20.]: jQueryに熟達した開発者であれば、JavaScriptだけでサイズをチェックするかもしれません。しかし、本書はJavaScriptチュートリアルではないので、[リスト13.66](/chapters/user_microposts?version=5.1#code-jquery_file_test)のようなコードで十分と考えました。
[^21.]: 他の解決策としてCSSで_表示_サイズを調整する方法もありますが、これだとファイルサイズが変わりません。結果として、ファイルサイズの大きな画像によって、読み込み時間が長くなるといった問題が発生します。例えば "小さい" 画像を表示するだけなのに、やたらに読み込み時間が長いウェブサイトに訪れたことはありませんか。これがその原因です。
[^22.]: もしクラウドIDEやLinuxライクなシステム以外で開発しているのであれば、Googleで「imagemagick <あなたのプラットフォーム名>」と検索してください。macOSの場合は、[Homebrew](http://brew.sh/)を導入後、`brew install imagemagick`と実行してインストールしてください。
[^23.]: 特に、Herokuのファイルストレージは一時的なので、デプロイする度にアップロードした画像が削除される仕様になっています。
[^24.]: この節の内容は必須ではありませんので、スキップしても問題ありません。
[^25.]: S3は課金サービスですが、Railsチュートリアルのサンプルアプリケーションをセットアップしたりテストするだけであれば、毎月1円ほどしか課金されません。
[^26.]: aws.amazon.com/documentation/s3/
[^27.]: これまでと同様に、Gemfileで指定した各gemのバージョンは[gemfiles-4th-ed.railstutorial.org](http://gemfiles-4th-ed.railstutorial.org/)と一致している必要があります。もしうまく次に進めない場合はチェックしてみてください。
