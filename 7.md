[第7章ユーザー登録](/chapters/sign_up?version=5.1#cha-sign_up)
======================================================

Userモデルができあがったので、いよいよユーザー登録機能を追加しましょう。[7.2](/chapters/sign_up?version=5.1#sec-signup_form)ではHTML _フォーム_を使ってWebアプリケーションに登録情報を送信します。続いて[7.4](/chapters/sign_up?version=5.1#sec-successful_signups)ではユーザーを新規作成して情報をデータベースに保存します。ユーザー登録手続きの最後には、作成されたユーザーの新しいプロフィールを表示できるようにするために、ユーザーを_表示する_ためのページを作成し、ユーザー用のRESTアーキテクチャを実装する第一歩を踏み出します ([2.2.2](/chapters/toy_app?version=5.1#sec-mvc_in_action))。それに伴い、[5.3.4](/chapters/filling_in_the_layout?version=5.1#sec-layout_link_tests)で実装した簡明かつ表現豊かな統合テストに対して、 いくつかのテストを追加していきます。

本章では、[第6章](/chapters/modeling_users?version=5.1#cha-modeling_users)で作成したUserモデルのバリデーションを信頼し、有効なメールアドレスを持っている (可能性のある) 新規ユーザーを増やしていきます。[第11章](/chapters/account_activation?version=5.1#cha-account_activation)では、 メールアドレスが_本当に_有効であることを確かめるために、_アカウントを有効化する_機能をサインアップの手順に追加します。

本チュートリアルはプロレベルの内容を扱いながらも、できるだけシンプルになるように努めていますが、それでもWeb開発というのが複雑かつ難しいトピックであることには変わりません。実際、この[第7章](/chapters/sign_up?version=5.1#cha-sign_up)からは難易度が少しずつ上がっていきます。このため本章からは、これまで以上にじっくりと時間をかけて読み進め、また、必要であれば復習もやっていくことをオススメします (一部の読者は各章を2回ずつ読んでいますが、これも１つの良いアプローチだと思います)。あるいは、もしRailsチュートリアルを読み進めていくには基礎知識が足りないと感じた場合には、[Railsチュートリアル前提知識シリーズ『開発基礎編』](https://railstutorial.jp/dev_basics)を購読したり、_Learn Enough Ruby to Be Dangerous_などのチュートリアルを読んでみても良いかもしれません。

[7.1 ユーザーを表示する](/chapters/sign_up?version=5.1#sec-showing_users)
----------------------------------------------------------------

この節では、まずユーザーの名前とプロフィール写真を表示するためのページを作成します。モックアップを[図7.1](/chapters/sign_up?version=5.1#fig-profile_mockup_profile_name)に示しました[1](#cha-7_footnote-1) 。ユーザープロフィールページの最終的な目標は、[図7.2](/chapters/sign_up?version=5.1#fig-profile_mockup)のようにユーザーのプロフィール写真と基本ユーザーデータ、そしてマイクロポストの一覧を表示することです[2](#cha-7_footnote-2) ([図7.2](/chapters/sign_up?version=5.1#fig-profile_mockup)では、有名な_lorem ipsum_ダミーテキストを使っています。このテキストの成り立ちには[面白いエピソード](http://www.straightdope.com/columns/read/2290/what-does-the-filler-text-lorem-ipsum-mean)があるので機会がありましたらどうぞ)。このページを作成したら、[第14章](/chapters/following_users?version=5.1#cha-following_users)のサンプルアプリケーションで使う予定です。

バージョン管理を使っている場合は、いつもと同じようにトピックブランチを作成します。
```sh
$ git checkout -b sign-up
```
図 7.1: この節で作成するユーザープロフィールのモックアップ

図 7.2: 理想とする最終的なプロフィールページのモックアップ

### [7.1.1 デバッグとRails環境](/chapters/sign_up?version=5.1#sec-rails_environments)

この節で作成するプロフィールは、このアプリケーションにおける初めての真に動的なページになります。ビューそのものは1ページのコードですが、アプリケーションのデータベースから取り出した情報を使って各プロフィールの表示をカスタマイズします。サンプルアプリケーションに動的なページを追加する準備として、ここでWebサイトのレイアウトにデバッグ情報を追加しましょう ([リスト7.1](/chapters/sign_up?version=5.1#code-rails_debug))。これにより、ビルトインの`debug`メソッドと`params`変数を使って、各プロフィールページにデバッグ用の情報が表示されるようになります (詳細については[7.1.2](/chapters/sign_up?version=5.1#sec-a_users_resource)で解説します)。

リスト 7.1: サイトのレイアウトにデバッグ情報を追加する `app/views/layouts/application.html.erb`
```erb
<!DOCTYPE html>
<html>
  .
  .
  .
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
      <%= debug(params) if Rails.env.development? %>
    </div>
  </body>
</html>
```
本番環境に展開したアプリケーションではデバッグ情報を表示したくないので、[リスト7.1](/chapters/sign_up?version=5.1#code-rails_debug)には次のコードを記述してあります。
```ruby
if Rails.env.development?
```

こうしておくと、デバッグ情報はRailsの3つのデフォルト環境のうち、_開発環境 (development)_ だけで表示されるようになります ([コラム7.1](/chapters/sign_up?version=5.1#aside-rails_environments))[3](#cha-7_footnote-3) 。特に、`Rails.env.development?`が`true`になるのは開発環境に限られるため、次の埋め込みRubyは
```erb
<%= debug(params) if Rails.env.development? %>
```
本番アプリケーションやテストで挿入されることはありません。(テスト環境でデバッグ情報が表示されても直接問題になることはありませんが、よいことではありません。デバッグ情報は開発環境以外で表示させないべきです。)

コラム 7.1. Railsの3つの環境

Railsにはテスト環境 (`test`)、開発環境 (`development`)、そして本番環境 (`production`) の3つの環境がデフォルトで装備されています。Rails consoleのデフォルトの環境は`development`です。
```ruby
  $ rails console
  Loading development environment
  >> Rails.env
  => "development"
  >> Rails.env.development?
  => true
  >> Rails.env.test?
  => false
```
上のように、Railsには`Rails`というオブジェクトがあり、それには環境の論理値 (boolean) を取る`env`という属性があります。例えば、`Rails.env.test?`はテスト環境では`true`を返し、それ以外の環境では`false`を返します。

テスト環境のデバッグなど、他の環境でconsoleを実行する必要が生じた場合は、環境をパラメータとして`console`スクリプトに渡すことができます。
```ruby
  $ rails console test
  Loading test environment
  >> Rails.env
  => "test"
  >> Rails.env.test?
  => true
```
同様にしてRailsサーバーもデフォルトでは`development`が使われますが、次のように他の環境を明示的に実行することもできます。
```ruby
  $ rails server --environment production
```
アプリケーションを本番環境で実行する場合、本番のデータベースが利用できないとアプリケーションを実行できません。そのため、`rails db:migrate`を本番環境で実行して本番データベースを作成します。
```ruby
  $ rails db:migrate RAILS_ENV=production
```
(注: console、server、migrateの3つのコマンドでは、デフォルト以外の環境を指定する方法がそれぞれ異なっており、混乱を招く可能性があります。このため、3つの場合のすべてを本コラムで説明しました。なお、この`RAILS_ENV=<env>`は先頭に持ってきても問題ありません。例えば `RAILS_ENV=production rails server` といった風に実行してもうまく動きます。)

ところで、サンプルアプリケーションを既にHeroku上にデプロイしている場合は、`heroku run rails console`というコマンドを打つことで、本番環境を確認することができます。
```ruby
  $ heroku run rails console
  >> Rails.env
  => "production"
  >> Rails.env.production?
  => true
```
当然ながら、Herokuは本番サイト用のプラットフォームなので、実行されるアプリケーションはすべて本番環境となります。

デバッグ出力をきれいに整形するために、[第5章](/chapters/filling_in_the_layout?version=5.1#cha-filling_in_the_layout)で作成したカスタムスタイルシートを[リスト7.2](/chapters/sign_up?version=5.1#code-mixin_and_debug)のように追加します。

リスト 7.2: デバッグ表示を整形するための追加と、Sassのミックスイン. `app/assets/stylesheets/custom.scss`
```scss
@import "bootstrap-sprockets";
@import "bootstrap";

/* mixins, variables, etc. */

$gray-medium-light: #eaeaea;

@mixin box_sizing {
  -moz-box-sizing:    border-box;
  -webkit-box-sizing: border-box;
  box-sizing:         border-box;
}
.
.
.
/* miscellaneous */

.debug_dump {
  clear: both;
  float: left;
  width: 100%;
  margin-top: 45px;
  @include box_sizing;
}
```
ここでSassの_ミックスイン_機能 (ここでは`box_sizing`) を使っています。ミックスイン機能を使うことで、CSSルールのグループをパッケージ化して複数の要素に適用することができます。例えば次のようなコードは、
```scss
.debug_dump {
  .
  .
  .
  @include box_sizing;
}
```

このように変換されます。
```csss
.debug_dump {
  .
  .
  .
  -moz-box-sizing:    border-box;
  -webkit-box-sizing: border-box;
  box-sizing:         border-box;
}
```
ミックスインは[7.2.1](/chapters/sign_up?version=5.1#sec-using_form_for)でも使います。今回の場合、デバッグ出力は[図7.3](/chapters/sign_up?version=5.1#fig-home_page_with_debug)のようになります[4](#cha-7_footnote-4) 。

図 7.3: サンプルアプリケーションのHomeページにデバッグ情報を表示する

[図7.3](/chapters/sign_up?version=5.1#fig-home_page_with_debug)のデバッグ出力には、描画されるページの状態を把握するのに役立つ情報が含まれます。
```ruby
---
controller: static_pages
action: home
```
これは`params`に含まれている内容で、YAML[5](#cha-7_footnote-5) という形式で書かれています。YAMLは基本的にハッシュであり、コントローラとページのアクションを一意に指定します。なお[7.1.2](/chapters/sign_up?version=5.1#sec-a_users_resource)では、別の形式の例も紹介していきます。

#### [演習](#sec-exercises_rails_environments)

1.  ブラウザから /about にアクセスし、デバッグ情報が表示されていることを確認してください。このページを表示するとき、どのコントローラとアクションが使われていたでしょうか? `params`の内容から確認してみましょう。
2.  Railsコンソールを開き、データベースから最初のユーザー情報を取得し、変数`user`に格納してください。その後、`puts user.attributes.to_yaml`を実行すると何が表示されますか? ここで表示された結果と、`y`メソッドを使った`y user.attributes`の実行結果を比較してみましょう。

### [7.1.2 Usersリソース](/chapters/sign_up?version=5.1#sec-a_users_resource)

ユーザープロフィールページを作成するには、その前にデータベースにユーザーが登録されている必要があります。これはいわゆる「卵が先か鶏が先か」問題です。このWebサイトでは、登録ページがない状態でどうやってユーザーを登録しておけばよいでしょうか。幸い、この問題は既に解決されています。[6.3.4](/chapters/modeling_users?version=5.1#sec-creating_and_authenticating_a_user)でRailsコンソールを使ってユーザーレコードを登録してありました。したがって、データベースの中に一人のユーザーがいるはずです。
```ruby
$ rails console
>> User.count
=> 1
>> User.first
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com", created_at: "2016-05-23 20:36:46", updated_at: "2016-05-23 20:36:46", password_digest: "$2a$10$xxucoRlMp06RLJSfWpZ8hO8Dt9AZX...">
```
(もしまだデータベース上に一人もユーザーがいない場合は、[6.3.4](/chapters/modeling_users?version=5.1#sec-creating_and_authenticating_a_user)に戻ってユーザーを追加してください。) 先ほど、コンソールの出力結果からユーザーのIDが `1` であることを確認しました。次の目標は、このようなユーザー情報をWebアプリケーション上に表示することです。ここでは、Railsアプリケーションで好まれているRESTアーキテクチャ ([コラム2.2](/chapters/toy_app?version=5.1#aside-REST)) の習慣に従うことにしましょう。つまり、データの作成、表示、更新、削除を_リソース (Resources)_ として扱うということです。[HTTP標準](https://ja.wikipedia.org/wiki/Hypertext_Transfer_Protocol)には、これらに対応する４つの基本操作 (`POST`、`GET`、`PATCH`、`DELETE`) が定義されているので、これらの基本操作を各アクションに割り当てていきます ([コラム3.2](/chapters/static_pages?version=5.1#aside-get_etc)) 。

RESTの原則に従う場合、リソースへの参照はリソース名とユニークなIDを使うのが普通です。ユーザーを_リソース_とみなす場合、id=`1`のユーザーを参照するということは、/users/1というURLに対して`GET`リクエストを発行するということを意味します。ここで`show`というアクションの種類は、_暗黙_のリクエストになります。RailsのREST機能が有効になっていると、`GET`リクエストは自動的に`show`アクションとして扱われます。

[2.2.1](/chapters/toy_app?version=5.1#sec-a_user_tour)で説明したとおり、id=`1`のユーザーにアクセスするためのページのURIは/users/1となります。ただし、現時点ではこのURLを使ってもエラーになります ([図7.4](/chapters/sign_up?version=5.1#fig-profile_routing_error))。

図 7.4: /users/1にアクセスした時のエラーログ

/users/1 のURLを有効にするために、routesファイル (`config/routes.rb`)に次の1行を追加します。
```ruby
resources :users
```
作成したコードを[リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)に示します。

リスト 7.3: Usersリソースをroutesファイルに追加する `config/routes.rb`
```ruby
Rails.application.routes.draw do
  root 'static_pages#home'
  get  '/help',    to: 'static_pages#help'
  get  '/about',   to: 'static_pages#about'
  get  '/contact', to: 'static_pages#contact'
  get  '/signup',  to: 'users#new'
  resources :users
end
```

今の短期的な目的はWebページ上にユーザーを表示することではありますが、`resources :users`という行は、ユーザー情報を表示するURL (/users/1) を追加するためだけのものではありません。サンプルアプリケーションにこの１行を追加すると、ユーザーのURLを生成するための多数の名前付きルート ([5.3.3](/chapters/filling_in_the_layout?version=5.1#sec-named_routes)) と共に、RESTfulなUsersリソースで必要となるすべてのアクションが利用できるようになるのです[6](#cha-7_footnote-6) 。この行に対応するURLやアクション、名前付きルートは[表7.1](/chapters/sign_up?version=5.1#table-RESTful_users)のようになります ([表2.2](/chapters/toy_app?version=5.1#table-demo_RESTful_users)との違いを比較してみてください)。次の3つの章に渡って、[表7.1](/chapters/sign_up?version=5.1#table-RESTful_users)の他の項目も利用して、Usersリソースを完全にRESTfulなリソースにするために必要なアクションをすべて作成する予定です。

<table><tbody><tr><td><strong>HTTPリクエスト</strong></td><td><strong>URL</strong></td><td><strong>アクション</strong></td><td><strong>名前付きルート</strong></td><td><strong>用途</strong></td></tr><tr><td><code>GET</code></td><td>/users</td><td><code>index</code></td><td><code>users_path</code></td><td>すべてのユーザーを一覧するページ</td></tr><tr><td><code>GET</code></td><td>/users/1</td><td><code>show</code></td><td><code>user_path(user)</code></td><td>特定のユーザーを表示するページ</td></tr><tr><td><code>GET</code></td><td>/users/new</td><td><code>new</code></td><td><code>new_user_path</code></td><td>ユーザーを新規作成するページ (ユーザー登録)</td></tr><tr><td><code>POST</code></td><td>/users</td><td><code>create</code></td><td><code>users_path</code></td><td>ユーザーを作成するアクション</td></tr><tr><td><code>GET</code></td><td>/users/1/edit</td><td><code>edit</code></td><td><code>edit_user_path(user)</code></td><td>id=<code>1</code>のユーザーを編集するページ</td></tr><tr><td><code>PATCH</code></td><td>/users/1</td><td><code>update</code></td><td><code>user_path(user)</code></td><td>ユーザーを更新するアクション</td></tr><tr><td><code>DELETE</code></td><td>/users/1</td><td><code>destroy</code></td><td><code>user_path(user)</code></td><td>ユーザーを削除するアクション</td></tr></tbody></table>

表 7.1: [リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)のUsersリソースが提供するRESTfulなルート

[リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)のコードを使うことで、ルーティングが有効になります。ただし、ルーティング先のページはまだありません ([図7.5](/chapters/sign_up?version=5.1#fig-user_show_unknown_action))。この問題を解決するために、[7.1.4](/chapters/sign_up?version=5.1#sec-a_gravatar_image)で最小限のプロフィールページを作成する予定です。

図 7.5: /users/1 のルーティングは有効だがページがない状態

ユーザーを表示するために、標準的なRailsの場所を使うことにします。Railsにおける標準的な場所とは、`app/views/users/show.html.erb`を指します。ただし、[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)でジェネレータを使ったときとは異なり (`new.html.erb`ビューを作成したときと異なり)、今回はジェネレータを使っていないので、この`show.html.erb`ファイルは手動で作成する必要があります。したがって、`app/views/users/show.html.erb`ファイルを手動で作成し[7](#cha-7_footnote-7) 、[リスト7.4](/chapters/sign_up?version=5.1#code-stub_user_view)の内容を貼り付けてください。

リスト 7.4: ユーザー情報を表示するための仮のビュー `app/views/users/show.html.erb`
```erb
<%= @user.name %>, <%= @user.email %>
```
このビューでは埋め込みRubyを使ってユーザー名とメールアドレスを表示しています。インスタンス変数`@user`があることを前提としています。もちろん、ユーザー表示ページの最終的な状態はこれとは大きく異なりますし、このメールアドレスがこのまま一般に公開されるようなこともありません。

ユーザー表示ビューが正常に動作するためには、Usersコントローラ内の`show`アクションに対応する`@user`変数を定義する必要があります。ご想像のとおり、ここではUserモデルの`find`メソッド ([6.1.4](/chapters/modeling_users?version=5.1#sec-finding_user_objects)) を使ってデータベースからユーザーを取り出します。[リスト7.5](/chapters/sign_up?version=5.1#code-user_show_action)のように書き換えてください。

リスト 7.5: Usersコントローラの`show`アクション `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

  def new
  end
end
```

ユーザーのid読み出しには`params`を使いました。Usersコントローラにリクエストが正常に送信されると、`params[:id]`の部分はユーザーidの`1`に置き換わります。つまり、この箇所は[6.1.4](/chapters/modeling_users?version=5.1#sec-finding_user_objects)で学んだ`find`メソッドの `User.find(1)`と同じになります。(技術的な補足: `params[:id]`は文字列型の `"1"` ですが、`find`メソッドでは自動的に整数型に変換されます)。

ユーザーのビューとアクションが定義されたので、/users/1 は完全に動作するようになりました ([図7.6](/chapters/sign_up?version=5.1#fig-user_show_rails))。このとき、もしbcrypt gemを追加してからまだ一度もRailsサーバーを再起動させていない場合は、ここで再起動してみてください ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。動作したら /users/1 にアクセスし、デバッグ情報から`params[:id]`の値を確認できることを確認してください ([図7.6](/chapters/sign_up?version=5.1#fig-user_show_rails))。
```ruby
---
action: show
controller: users
id: '1'
```

この`id: '1'`は /users/`:id` から取得した値です。この値を使って
```ruby
User.find(params[:id])
```
上のコードでid=`1`のユーザーを検索できる、といった仕組みになっているのです ([リスト7.5](/chapters/sign_up?version=5.1#code-user_show_action))。

図 7.6: Usersリソース追加後のユーザー表示ページ

#### [演習](#sec-exercises_a_users_resource)

1.  埋め込みRubyを使って、マジックカラム (`created_at`と`updated_at`) の値をshowページに表示してみましょう ([リスト7.4](/chapters/sign_up?version=5.1#code-stub_user_view))。
2.  埋め込みRubyを使って、`Time.now`の結果をshowページに表示してみましょう。ページを更新すると、その結果はどう変わっていますか? 確認してみてください。

### [7.1.3 debuggerメソッド](/chapters/sign_up?version=5.1#sec-debugger)

[7.1.2](/chapters/sign_up?version=5.1#sec-a_users_resource)、アプリケーションの振る舞いを理解するために`debug`メソッドが役に立つことを学びました。しかし、もっと直接的にデバッグする方法もあります。それが`byebug` gemによる`debugger`メソッドです ([リスト3.2](/chapters/static_pages?version=5.1#code-gemfile_sample_app))。どういう風にデバッグできるようになるのか、`debugger`メソッドを実際にアプリケーションに差し込んで確かめてみましょう ([リスト7.6](/chapters/sign_up?version=5.1#code-debugger))。

リスト 7.6: `debugger`をUsersコントローラに差し込む `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
    debugger
  end

  def new
  end
end
```

`debugger`メソッドを差し込んだら、ブラウザから /users/1 にアクセスし、Railsサーバーを立ち上げたターミナルを見てみましょう。`byebug`プロンプトが表示されているはずです。
```
(byebug)
```
このプロンプトではRailsコンソールのようにコマンドを呼び出すことができて、アプリケーションの`debugger`が呼び出された瞬間の状態を確認することができます。
```sh
(byebug) @user.name
"Example User"
(byebug) @user.email
"example@railstutorial.org"
(byebug) params[:id]
"1"
```
なお、Ctrl-Dを押すとプロンプトから抜け出すことができます。また、デバッグが終わったら`show`アクション内の`debugger`の行を削除してしまいましょう ([リスト7.7](/chapters/sign_up?version=5.1#code-debugger_removed))。

リスト 7.7: `debugger`をUsersコントローラーから取り外す `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

  def new
  end
end
```

今後Railsアプリケーションの中でよく分からない挙動があったら、上のように`debugger`を差し込んで調べてみましょう。トラブルが起こっていそうなコードの近くに差し込むのがコツです。`byebug` gemを使ってシステムの状態を調査することは、アプリケーション内のエラーを追跡したりデバッグするときに非常に強力なツールになります。

#### [演習](#sec-exercises_debugger)

1.  `show`アクションの中に`debugger`を差し込み ([リスト7.6](/chapters/sign_up?version=5.1#code-debugger))、ブラウザから /users/1 にアクセスしてみましょう。その後コンソールに移り、`puts`メソッドを使って`params`ハッシュの中身を_YAML形式で_表示してみましょう。_ヒント_: [7.1.1.1](/chapters/sign_up?version=5.1#sec-exercises_rails_environments)の演習を参考にしてください。その演習では`debug`メソッドで表示したデバッグ情報を、どのようにしてYAML形式で表示していたでしょうか?
2.  `new`アクションの中に`debugger`を差し込み、/users/new にアクセスしてみましょう。`@user`の内容はどのようになっているでしょうか? 確認してみてください。

### [7.1.4 Gravatar画像とサイドバー](/chapters/sign_up?version=5.1#sec-a_gravatar_image)

前節で基本的なユーザーページの定義は終わりましたので、今度は各ユーザーのプロフィール写真のあたりをもう少し肉付けし、サイドバーも作り始めましょう。ここでは[Gravatar (Globally Recognized AVATAR)](http://gravatar.com/) をプロフィールに導入してみましょう[8](#cha-7_footnote-8) (訳注: Gravatarアカウントを作成する必要はありません)。Gravatarは無料のサービスで、プロフィール写真をアップロードして、指定したメールアドレスと関連付けることができます。その結果、 Gravatarはプロフィール写真をアップロードするときの面倒な作業や写真が欠けるトラブル、また、画像の置き場所の悩みを解決します。というのも、ユーザーのメールアドレスを組み込んだGravatar専用の画像パスを構成するだけで、対応するGravatarの画像が自動的に表示されるからです (カスタム画像を扱う方法については[13.4](/chapters/user_microposts?version=5.1#sec-micropost_images)で扱います)。

ここでは[リスト7.8](/chapters/sign_up?version=5.1#code-user_show_view_with_gravatar)のように、`gravatar_for`ヘルパーメソッドを使ってGravatarの画像を利用できるようにします。

リスト 7.8: ユーザー表示ビューに名前とGravatarを表示する `app/views/users/show.html.erb`
```erb
<% provide(:title, @user.name) %>
<h1>
  <%= gravatar_for @user %>
  <%= @user.name %>
</h1>
```
デフォルトでは、ヘルパーファイルで定義されているメソッドは自動的にすべてのビューで利用できます。ここでは、利便性を考えて`gravatar_for`をUsersコントローラに関連付けられているヘルパーファイルに置くことにしましょう。[Gravatarのホームページ](http://ja.gravatar.com/site/implement/hash/)にも書かれているように、GravatarのURLはユーザーのメールアドレスを[MD5](https://ja.wikipedia.org/wiki/MD5)という仕組みでハッシュ化しています。Rubyでは、`Digest`ライブラリの`hexdigest`メソッドを使うと、MD5のハッシュ化が実現できます。
```ruby
>> email = "MHARTL@example.COM"
>> Digest::MD5::hexdigest(email.downcase)
=> "1fda4469bcbec3badf5418269ffc5968"
```
メールアドレスは大文字と小文字を区別しませんが ([6.2.4](/chapters/modeling_users?version=5.1#sec-format_validation))、MD5ハッシュでは大文字と小文字が区別されるので、Rubyの`downcase`メソッドを使って`hexdigest`の引数を小文字に変換しています。(本チュートリアルでは、[リスト6.32](/chapters/modeling_users?version=5.1#code-email_downcase)のコールバック処理で小文字変換されたメールアドレスを利用しているため、ここで小文字変換を入れなくても結果は同じです。ただし、将来`gravatar_for`メソッドが別の場所から呼びだされる可能性を考えると、ここで小文字変換を入れることには意義があります。) `gravatar_for`ヘルパーを組み込んだ結果を[リスト7.9](/chapters/sign_up?version=5.1#code-gravatar_for_helper)に示しました。

リスト 7.9: `gravatar_for`ヘルパーメソッドを定義する `app/helpers/users_helper.rb`
```ruby
module UsersHelper

  # 引数で与えられたユーザーのGravatar画像を返す
  def gravatar_for(user)
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"
    image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end
end
```

[リスト7.9](/chapters/sign_up?version=5.1#code-gravatar_for_helper)のコードは、Gravatarの画像タグに`gravatar`クラスとユーザー名のaltテキストを追加したものを返します (altテキストを追加しておくと、視覚障害のあるユーザーがスクリーンリーダーを使うときにも役に立ちます)。

プロフィールページは[図7.7](/chapters/sign_up?version=5.1#fig-profile_with_gravatar)のようになります。ここにはデフォルトのGravatar画像が表示されていますが、これはデフォルトのメールアドレス`user@example.com`が本当のメールアドレスではないためです。(ちなみに[example.com](http://www.example.com/)というドメイン名は、例題として使うために用意された特別なドメインとなっています)

図 7.7: ユーザー表示ページにGravatarのデフォルト画像が表示されている

アプリケーションでGravatarを利用できるようにするために、まずは`update_attributes` ([6.1.5](/chapters/modeling_users?version=5.1#sec-updating_user_objects)) を使ってデータベース上のユーザー情報 (メールアドレス) を更新してみます。
```ruby
$ rails console
>> user = User.first
>> user.update_attributes(name: "Example User",
>>                        email: "example@railstutorial.org",
>>                        password: "foobar",
>>                        password_confirmation: "foobar")
=> true
```
ここではユーザーのメールアドレスに `example@railstutorial.org` を使いました。Gravatar上でこのメールアドレスとRailsチュートリアルのロゴを既に紐付けてあるので、上のように更新すると次の[図7.8](/chapters/sign_up?version=5.1#fig-profile_custom_gravatar)のようになります。

図 7.8: ユーザー表示ページにGravatarのカスタム画像が表示されている

[図7.1](/chapters/sign_up?version=5.1#fig-profile_mockup_profile_name)のモックアップに近づけるために、ユーザーのサイドバーの最初のバージョンを作りましょう。ここでは`aside`タグを使って実装します。このタグはサイドバーなどの補完コンテンツの表示に使われますが、単独で表示することもできます。`row`クラスと`col-md-4`クラスも追加しておきます。これらのクラスはBootstrapの一部です。ユーザー表示ページを変更した結果を[リスト7.10](/chapters/sign_up?version=5.1#code-user_show_with_sidebar)に示します。

リスト 7.10: ユーザーの`show`ビューにサイドバーを追加する `app/views/users/show.html.erb`
```erb
<% provide(:title, @user.name) %>
<div class="row">
  <aside class="col-md-4">
    <section class="user_info">
      <h1>
        <%= gravatar_for @user %>
        <%= @user.name %>
      </h1>
    </section>
  </aside>
</div>
```
HTML要素とCSSクラスを配置したことにより、プロフィールページ (とサイドバーとGravatar) にSCSSで[リスト7.11](/chapters/sign_up?version=5.1#code-sidebar_css)のようにスタイルを与えることができるようになりました[9](#cha-7_footnote-9) (テーブルCSSのルールが入れ子になっていますが、これができるのはAsset PipelineでSassエンジンが使われている場合に限られます) 。ページの変更の結果を[図7.9](/chapters/sign_up?version=5.1#fig-user_show_sidebar_css)に示します。

リスト 7.11: SCSSを使ってサイドバーなどのユーザー表示ページにスタイルを与える `app/assets/stylesheets/custom.scss`
```scss
.
.
.
/* sidebar */

aside {
  section.user_info {
    margin-top: 20px;
  }
  section {
    padding: 10px 0;
    margin-top: 20px;
    &:first-child {
      border: 0;
      padding-top: 0;
    }
    span {
      display: block;
      margin-bottom: 3px;
      line-height: 1;
    }
    h1 {
      font-size: 1.4em;
      text-align: left;
      letter-spacing: -1px;
      margin-bottom: 3px;
      margin-top: 0px;
    }
  }
}

.gravatar {
  float: left;
  margin-right: 10px;
}

.gravatar_edit {
  margin-top: 15px;
}
```
図 7.9: showページにサイドバーとCSSを追加する

#### [演習](#sec-exercises_a_gravatar_image)

1.  (任意) Gravatar上にアカウントを作成し、あなたのメールアドレスと適当な画像を紐付けてみてください。メールアドレスをMD5ハッシュ化して、紐付けた画像がちゃんと表示されるかどうか試してみましょう。
2.  [7.1.4](/chapters/sign_up?version=5.1#sec-a_gravatar_image)で定義した`gravatar_for`ヘルパーを[リスト7.12](/chapters/sign_up?version=5.1#code-gravatar_option)のように変更して、`size`をオプション引数として受け取れるようにしてみましょう。うまく変更できると、`gravatar_for user, size: 50`といった呼び出し方ができるようになります。_重要_: この改善したヘルパーは[10.3.1](/chapters/updating_and_deleting_users?version=5.1#sec-users_index)で実際に使います。忘れずに実装しておきましょう。
3.  オプション引数は今でもRubyコミュニティで一般的に使われていますが、Ruby 2.0から導入された新機能「_キーワード引数 (Keyword Arguments)_」でも実現することができます。先ほど変更した[リスト7.12](/chapters/sign_up?version=5.1#code-gravatar_option)を、[リスト7.13](/chapters/sign_up?version=5.1#code-gravatar_keyword)のように置き換えてもうまく動くことを確認してみましょう。この２つの実装方法はどういった違いがあるのでしょうか? 考えてみてください。

リスト 7.12: `gravatar_for`ヘルパーにオプション引数を追加する `app/helpers/users_helper.rb`
```ruby
module UsersHelper

  # 引数で与えられたユーザーのGravatar画像を返す
  def gravatar_for(user, options = { size: 80 })
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
    size = options[:size]
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}"
    image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end
end
```

リスト 7.13: `gravatar_for`ヘルパーにキーワード引数を追加する `app/helpers/users_helper.rb`
```ruby
module UsersHelper

  # 引数で与えられたユーザーのGravatar画像を返す
  def gravatar_for(user, size: 80)
    gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
    gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}?s=#{size}"
    image_tag(gravatar_url, alt: user.name, class: "gravatar")
  end
end
```

[7.2 ユーザー登録フォーム](/chapters/sign_up?version=5.1#sec-signup_form)
---------------------------------------------------------------

ここまででユーザープロフィールページがひとまず動作するようになりましたので、今度はユーザー登録フォームを作成しましょう。[図5.11](/chapters/filling_in_the_layout?version=5.1#fig-new_signup_page) ([図7.10](/chapters/sign_up?version=5.1#fig-blank_signup_page_recap)にも再録) に示したとおり、ユーザー登録ページはまだ空白のままなので、このままではユーザー登録できません。この節の目標は、このみっともないページを改造して[図7.11](/chapters/sign_up?version=5.1#fig-signup_mockup)のモックアップのようなページに変えることです。

図 7.10: 現状のユーザー登録ページ /signup

図 7.11: ユーザー登録ページのモックアップ

### [7.2.1 `form_for`を使用する](/chapters/sign_up?version=5.1#sec-using_form_for)

ユーザー登録ページで重要な点は、ユーザー登録に欠かせない情報を入力するための_form_です。Railsで`form_for`ヘルパーメソッドを使います。このメソッドはActive Recordのオブジェクトを取り込み、そのオブジェクトの属性を使ってフォームを構築します。

[Rails 5.1](https://railsguides.jp/5_1_release_notes.html)から推奨されている`form_with`メソッドを使って学びたい方は『[第6版](https://railstutorial.jp/webtext?utm_source=tutorial&utm_medium=text&utm_campaign=text_in_pr_60)』をご覧ください。

ユーザー登録ページ /signup のルーティングは、Usersコントローラーの`new`アクションに既に紐付けられていることを思い出してください ([リスト5.43](/chapters/filling_in_the_layout?version=5.1#code-signup_route))。したがって、次のステップは、 `form_for`の引数で必要となるUserオブジェクトを作成することになります。必要となる`@user`変数の定義は、次の[リスト7.14](/chapters/sign_up?version=5.1#code-new_action_with_user)のようになります。

リスト 7.14: `new`アクションに`@user`変数を追加する `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

  def new
    @user = User.new
  end
end
```

フォームそのものは[リスト7.15](/chapters/sign_up?version=5.1#code-signup_form)で示します。[7.2.2](/chapters/sign_up?version=5.1#sec-the_form_html)で詳しく触れますが、まずは[リスト7.16](/chapters/sign_up?version=5.1#code-form_css)のSCSSで見栄えを整えてみましょう。`box_sizing`ミックスインを[リスト7.2](/chapters/sign_up?version=5.1#code-mixin_and_debug)から再利用していることに注目してください。これらのCSSルールが一度適用されると、ユーザー登録ページは[図7.12](/chapters/sign_up?version=5.1#fig-signup_form)のようになります。

リスト 7.15: 新規ユーザーのためのユーザー登録フォーム `app/views/users/new.html.erb`
```erb
<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
      <%= f.label :name %>
      <%= f.text_field :name %>

      <%= f.label :email %>
      <%= f.email_field :email %>

      <%= f.label :password %>
      <%= f.password_field :password %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation %>

      <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
```
リスト 7.16: ユーザー登録フォームのCSS `app/assets/stylesheets/custom.scss`
```scss
.
.
.
/* forms */

input, textarea, select, .uneditable-input {
  border: 1px solid #bbb;
  width: 100%;
  margin-bottom: 15px;
  @include box_sizing;
}

input {
  height: auto !important;
}
```
図 7.12: ユーザー登録フォーム

#### [演習](#sec-exercises_using_form_for)

1.  試しに、[リスト7.15](/chapters/sign_up?version=5.1#code-signup_form)にある`:name`を`:nome`に置き換えてみましょう。どんなエラーメッセージが表示されるようになりますか?
2.  試しに、ブロックの変数`f`をすべて`foobar`に置き換えてみて、結果が変わらないことを確認してみてください。確かに結果は変わりませんが、変数名を`foobar`とするのはあまり良い変更ではなさそうですね。その理由について考えてみてください。

### [7.2.2 フォームHTML](/chapters/sign_up?version=5.1#sec-the_form_html)

[リスト7.15](/chapters/sign_up?version=5.1#code-signup_form)で定義したフォームを理解するために、小さなコードに分けて考えてみましょう。まずは、埋め込みRubyが使われている`form_for`から`end`までの外側の構造を読み解いていきます。
```erb
<%= form_for(@user) do |f| %>
  .
  .
  .
<% end %>
```
`do`キーワードは、 `form_for`が1つの変数を持つブロックを取ることを表します。この変数`f`は “form” のfです。

通常、Railsヘルパーを使っている場合、実装の詳細について知っておく必要はありません。ただし_f_というオブジェクトが`何をするのかは知っておく`必要があります。この_f_オブジェクトは、[HTMLフォーム要素](http://www.w3schools.com/html/html_forms.asp) (テキストフィールド、ラジオボタン、パスワードフィールドなど) に対応するメソッドが呼び出されると、_@user_の属性を設定するために特別に設計されたHTMLを返します。つまり、次のコードを実行すると、
```erb
<%= f.label :name %>
<%= f.text_field :name %>
```
Userモデルの`name`属性を設定する、ラベル付きテキストフィールド要素を作成するのに必要なHTMLを作成します。

生成されたフォームのHTMLを見たい場合は、ブラウザ上で表示画面を右クリックし、出てきたポップアップ項目の中から [ソースを表示] といった項目をクリックしてください。WebページのHTMLソースは[リスト7.17](/chapters/sign_up?version=5.1#code-signup_form_html)のようになります。HTMLソースの中の、フォームを形成するHTML構造に注目してみましょう。

リスト 7.17: [図7.12](/chapters/sign_up?version=5.1#fig-signup_form)のフォームのHTMLソース
```html
<form accept-charset="UTF-8" action="/users" class="new_user"
      id="new_user" method="post">
  <input name="utf8" type="hidden" value="&#x2713;" />
  <input name="authenticity_token" type="hidden"
         value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" />
  <label for="user_name">Name</label>
  <input id="user_name" name="user[name]" type="text" />

  <label for="user_email">Email</label>
  <input id="user_email" name="user[email]" type="email" />

  <label for="user_password">Password</label>
  <input id="user_password" name="user[password]"
         type="password" />

  <label for="user_password_confirmation">Confirmation</label>
  <input id="user_password_confirmation"
         name="user[password_confirmation]" type="password" />

  <input class="btn btn-primary" name="commit" type="submit"
         value="Create my account" />
</form>
```
まずはこのHTMLソースの内部構造について説明します。[リスト7.15](/chapters/sign_up?version=5.1#code-signup_form)と[リスト7.17](/chapters/sign_up?version=5.1#code-signup_form_html)をじっくり見比べてみると、次の埋め込みRubyは、
```erb
<%= f.label :name %>
<%= f.text_field :name %>
```
このようなHTMLを生成していることがわかります。
```html
<label for="user_name">Name</label>
<input id="user_name" name="user[name]" type="text" />
```
また、次の埋め込みRubyは
```erb
<%= f.label :email %>
<%= f.email_field :email %>
```
このようなHTMLを生成していることもわかります。
```html
<label for="user_email">Email</label>
<input id="user_email" name="user[email]" type="email" />
```
同様にして次のコードは、
```erb
<%= f.label :password %>
<%= f.password_field :password %>
```

こういったHTMLを生成しています。
```html
<label for="user_password">Password</label>
<input id="user_password" name="user[password]" type="password" />
```
次の[図7.13](/chapters/sign_up?version=5.1#fig-filled_in_form)に示すように、テキストフィールド (`type="text"`と`type="email"`) では内容をそのまま表示していますが、パスワードフィールド (`type="password"`) ではセキュリティ上の目的のために文字が隠蔽されています ([図7.13](/chapters/sign_up?version=5.1#fig-filled_in_form))。(emailフィールドとtextフィールドは同じように見えますが、細かな点が違います。例えば`type="email"`となっている場合、モバイル端末から入力フォームをタップすると、メールアドレスに最適化された特別なキーボードが表示されるようになります。)

図 7.13: `text`フィールドと`password`フィールドに文字を入力した状態

[7.4](/chapters/sign_up?version=5.1#sec-successful_signups)でも説明しますが、ユーザーの作成で重要なのは`input`ごとにある特殊な`name`属性です。

<input id="user_name" name="user[name]" - - - />
.
.
.
<input id="user_password" name="user[password]" - - - />

Railsは`name`の値を使って、初期化したハッシュを (`params`変数経由で) 構成します。このハッシュは、入力された値に基づいてユーザーを作成するときに使われます (詳しくは[7.3](/chapters/sign_up?version=5.1#sec-unsuccessful_signups)で説明)。

次に重要な要素は、`form`タグ自身です。Railsは`form`タグを作成するときに`@user`オブジェクトを使います。すべてのRubyオブジェクトは自分のクラスを知っている ([4.4.1](/chapters/rails_flavored_ruby?version=5.1#sec-constructors)) ので、Railsは`@user`のクラスがUserであることを認識します。また、`@user`は_新しい_ユーザーなので、 Railsは`post`メソッドを使ってフォームを構築すべきだと判断します。なお、新しいオブジェクトを作成するために必要なHTTPリクエストはPOSTなので、このメソッドはRESTfulアーキテクチャとして正しいリクエストになります ([コラム3.2](/chapters/static_pages?version=5.1#aside-get_etc))。

<form action="/users" class="new_user" id="new_user" method="post">

このとき、上の`class`と`id`属性はアーキテクチャとしては基本的に無関係です。ここで重要な属性は、`action="/users"`と`method="post"`の２つだけです。この2つの属性では、/users に対してHTTPの`POST`リクエスト送信する、といった指示をしています

ところで、`form`タグの内側で次のようなHTMLが生成されていたことにもお気付きでしょうか。

<input name="utf8" type="hidden" value="&#x2713;" />
<input name="authenticity_token" type="hidden"
       value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" />

このコードはブラウザ上では何も表示しませんが、Railsの内部で使われる特別なコードです。したがって、どういった意図で生成されたのかは、現時点ではまだ理解しなくても大丈夫です ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。簡潔にまとめると、Unicode文字の「`&#x2713;` (チェックマーク ✓)」を使ってブラウザが正しい文字コードを送信できるようにしたり、 _Cross-Site Request Forgery (CSRF)_ と呼ばれる攻撃を阻止するために信頼できるトークンを含めたりしています[10](#cha-7_footnote-10) 。

#### [演習](#sec-exercises_the_form_html)

1.  _Learn Enough HTML to Be Dangerous_ではHTMLをすべて手動で書き起こしていますが、なぜ`form`タグを使わなかったのでしょうか? 理由を考えてみてください。

[7.3 ユーザー登録失敗](/chapters/sign_up?version=5.1#sec-unsuccessful_signups)
----------------------------------------------------------------------

[図7.12](/chapters/sign_up?version=5.1#fig-signup_form)ではフォームのHTMLがどうなっているかを簡単に説明しました ([リスト7.17](/chapters/sign_up?version=5.1#code-signup_form_html)参照) が、フォームを理解するには_ユーザー登録の失敗のとき_が最も参考になります。この節では、無効なデータ送信を受け付けるユーザー登録フォームを作成し、ユーザー登録フォームを更新してエラーの一覧を表示します。このモックアップを[図7.14](/chapters/sign_up?version=5.1#fig-signup_failure_mockup)に示します。

図 7.14: ユーザー登録が失敗したときのモックアップ。

### [7.3.1 正しいフォーム](/chapters/sign_up?version=5.1#sec-a_working_form)

[7.1.2](/chapters/sign_up?version=5.1#sec-a_users_resource)で、`resources :users`を`routes.rb`ファイルに追加すると ([リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)) 自動的にRailsアプリケーションが[表7.1](/chapters/sign_up?version=5.1#table-RESTful_users)のRESTful URI に応答するようになったことを思い出してください。特に、/usersへの`POST`リクエストは`create`アクションに送られます。私たちはここで、`create`アクションでフォーム送信を受け取り、`User.new`を使って新しいユーザーオブジェクトを作成し、ユーザーを保存 (または保存に失敗) し、再度の送信用のユーザー登録ページを表示するという方法で機能を実装しようと思います。まずはユーザー登録フォームのコードを見直してみましょう。

<form action="/users" class="new_user" id="new_user" method="post">

[7.2.2](/chapters/sign_up?version=5.1#sec-the_form_html)で説明したように、このHTMLは`POST`リクエストを/usersというURLに送信します。

ユーザー登録フォームを動かすために、まず[リスト7.18](/chapters/sign_up?version=5.1#code-first_create_action)のようにコードを追加するところから始めます。このリストでは、[5.1.3](/chapters/filling_in_the_layout?version=5.1#sec-partials)の「パーシャル」のところでも使った`render` メソッドを再度使いまわしています。`render` はコントローラのアクションの中でも正常に動作します。ここで、以前に説明した`if`-`else`分岐構造を思い出してください。この文を使って、保存が成功したかどうかに応じて`@user.save`の値が`true`または`false` ([6.1.3](/chapters/modeling_users?version=5.1#sec-creating_user_objects)) になるときに、それぞれ成功時の処理と失敗時の処理を場合分けすることができます。

リスト 7.18: ユーザー登録の失敗に対応できる`create`アクション `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])    # 実装は終わっていないことに注意!
    if @user.save
      # 保存の成功をここで扱う。
    else
      render 'new'
    end
  end
end
```

コメントにもあるように、上のコードはまだ実装が完了していませんので注意してください。しかし実装の出発点としてはこれで十分です。なお、最終的な実装は[7.3.2](/chapters/sign_up?version=5.1#sec-strong_parameters)で完了します。

[リスト7.18](/chapters/sign_up?version=5.1#code-first_create_action)のコードの動作を理解するもっともよい方法は、実際に無効なユーザー登録データを_送信 (submit)_してみることです。送信してみると、結果は[図7.15](/chapters/sign_up?version=5.1#fig-signup_failure)のようになります。なお、そのときのデバッグ情報は[図7.16](/chapters/sign_up?version=5.1#fig-signup_failure_rails_debug)のとおりです。

図 7.15: ユーザー登録失敗

図 7.16: ユーザー登録失敗時のデバッグ情報

Railsが送信を扱う方法をより深く理解するために、デバッグ情報のうちパラメーターハッシュの`user`の部分を詳しく見てみましょう ([図7.16](/chapters/sign_up?version=5.1#fig-signup_failure_rails_debug))。
```ruby
"user" => { "name" => "Foo Bar",
            "email" => "foo@invalid",
            "password" => "[FILTERED]",
            "password_confirmation" => "[FILTERED]"
          }
```
このハッシュはUsersコントローラに`params`として渡されます。[7.1.2](/chapters/sign_up?version=5.1#sec-a_users_resource)で説明したとおり、この`params`ハッシュには各リクエストの情報が含まれています。ユーザー登録情報の送信の場合、`params`には複数のハッシュに対するハッシュ (hash-of-hashes: 入れ子になったハッシュ) が含まれます (なお、[4.3.3](/chapters/rails_flavored_ruby?version=5.1#sec-hashes_and_symbols)ではhash-of-hashesの説明とともに、コンソールセッションで使うためにあえて`params`という名前の変数を導入しました)。上のデバッグ情報では、フォーム送信の結果が、送信された値に対応する属性とともに`user`ハッシュに保存されています。このハッシュのキーが、`input`タグにあった`name`属性の値になります ([リスト7.17](/chapters/sign_up?version=5.1#code-signup_form_html))。例えば次のように、
```html
<input id="user_email" name="user[email]" type="email" />
```
`"user[email]"`という値は、`user`ハッシュの`:email`キーの値と一致します。

ハッシュのキーはデバッグ情報では文字列となっていますが、Railsは文字列ではなく、`params[:user]`のように「シンボル」としてUsersコントローラに渡している点に注意してください。この性質により、[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)や[リスト7.18](/chapters/sign_up?version=5.1#code-first_create_action)などで見てきたように、このハッシュは`User.new`の引数で必要となるデータと完全に一致します。つまり、これまで見てきた次のようなコード _(マスアサインメントと呼びます)_ は、
```ruby
@user = User.new(params[:user])
```
実際にはこのようなコードとほぼ同じである、ということです。
```ruby
@user = User.new(name: "Foo Bar", email: "foo@invalid",
                 password: "foo", password_confirmation: "bar")
```
ただし、昔のバージョンのRailsでは、次のコードでも動きましたが、
```ruby
@user = User.new(params[:user])
```
実は、悪意のあるユーザーによってアプリケーションのデータベースが書き換えられないように慎重な対策をとる必要があり、しかも、その対策が別のエラーを引き起こす危険性 (マスアサインメント脆弱性) もありました。そこでRails 4.0以降では、上のコードをエラー (上の[図7.15](/chapters/sign_up?version=5.1#fig-signup_failure)および[図7.16](/chapters/sign_up?version=5.1#fig-signup_failure_rails_debug)を参照) とすることでセキュリティを高め、また、_Strong Parameters_ と呼ばれるテクニックで対策することを標準としました。

### [7.3.2 Strong Parameters](/chapters/sign_up?version=5.1#sec-strong_parameters)

[4.4.5](/chapters/rails_flavored_ruby?version=5.1#sec-a_user_class)で、_マスアサインメント_について簡単に説明しました。これは、次のように値のハッシュを使ってRubyの変数を初期化するものです。
```ruby
@user = User.new(params[:user])    # 実装は終わっていないことに注意!
```
[リスト7.18](/chapters/sign_up?version=5.1#code-first_create_action)のコメントと、上の再録コメントでも重ねて指摘しているように、この実装は最終形ではありません。その理由は、`params`ハッシュ全体を初期化するという行為はセキュリティ上、_極めて_危険だからです。これは、ユーザーが送信したデータを_まるごと_`User.new`に渡していることになります。ここで、Userモデルに`admin`属性というものがあるとしましょう。この属性は、Webサイトの管理者であるかどうかを示します (この属性を実装するのは[10.4.1](/chapters/updating_and_deleting_users?version=5.1#sec-administrative_users)になってからです)。`admin=’1’`という値を`params[:user]`の一部に紛れ込ませて渡してしまえば、この属性を`true`にすることができます。これは`curl`などのコマンドを使えば簡単に実現できます。`params`ハッシュがまるごと`User.new`に渡されてしまうと、どのユーザーでも`admin=’1’`をWebリクエストに紛れ込ませるだけでWebサイトの管理者権限を奪い取ることができてしまいます。

以前のバージョンのRailsでは、`モデル`層で_attr_accessible_メソッドを使うことで上のような危険を防止していましたが、Rails 4.0ではコントローラ層で_Strong Parameters_というテクニックを使うことが推奨されています。Strong Parametersを使うことで、_必須_のパラメータと_許可された_パラメータを指定することができます。さらに、上のように`params`ハッシュをまるごと渡すとエラーが発生するので、Railsはデフォルトでマスアサインメントの脆弱性から守られるようになりました。

この場合、`params`ハッシュでは`:user`属性を必須とし、名前、メールアドレス、パスワード、パスワードの確認の属性をそれぞれ許可し、それ以外を許可しないようにしたいと考えています。これを行うには、次のように記述します。
```ruby
params.require(:user).permit(:name, :email, :password, :password_confirmation)
```
このコードの戻り値は、許可された属性のみが含まれた`params`のハッシュです (`:user`属性がない場合はエラーになります)。

これらのパラメータを使いやすくするために、`user_params`という外部メソッドを使うのが慣習になっています。このメソッドは適切に初期化したハッシュを返し、`params[:user]`の代わりとして使われます。
```ruby
@user = User.new(user_params)
```
この`user_params`メソッドはUsersコントローラの内部でのみ実行され、Web経由で外部ユーザーにさらされる必要はないため、[リスト7.19](/chapters/sign_up?version=5.1#code-create_action_strong_parameters)に示すようにRubyの`private`キーワードを使って`外部から使えない`ようにします (`private`キーワードの詳細については[11.1.2](/chapters/account_activation?version=5.1#sec-account_activation_data_model)で説明します)。

リスト 7.19: `create`アクションでStrong Parametersを使う `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController
  .
  .
  .
  def create
    @user = User.new(user_params)
    if @user.save
      # 保存の成功をここで扱う。
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
end
```

ちなみに、`private`キーワード以降のコードを強調するために、`user_params`のインデントを1段深くしてあります。(経験的にはこれは賢い慣習だと思います。というのも、クラス内に多数のメソッドがある場合、privateメソッドの場所が簡単に見つかるからです。これにより、インデントが無い場合と比べて、どこからprivateになるのか困惑することがなくなります。)

この時点で、(送信ボタンを押してもエラーが出ないという意味で) ユーザー登録フォームは動くようになります。ただし[図7.17](/chapters/sign_up?version=5.1#fig-invalid_submission_no_feedback)が示すように、(開発者用のデバッグ領域を除いて) 間違った送信をしても何もフィードバックが返ってきていません。これはユーザーが困惑する原因となります。また、有効なユーザー情報を送信しても新しいユーザーが実際に作成されることもありません。前者の問題を[7.3.3](/chapters/sign_up?version=5.1#sec-signup_error_messages)で、後者の問題を[7.4](/chapters/sign_up?version=5.1#sec-successful_signups)でそれぞれ解決していきます。

図 7.17: 無効な情報をユーザー登録フォームで送信した結果

#### [演習](#sec-exercises_a_working_form)

1.  /signup?admin=1 にアクセスし、`params`の中に`admin`属性が含まれていることをデバッグ情報から確認してみましょう。

### [7.3.3 エラーメッセージ](/chapters/sign_up?version=5.1#sec-signup_error_messages)

ユーザー登録に失敗した場合の最後の手順として、問題が生じたためにユーザー登録が行われなかったということをユーザーにわかりやすく伝えるエラーメッセージを追加しましょう。Railsは、このようなメッセージをUserモデルの検証時に自動的に生成してくれます。例えばユーザー情報のメールアドレスが無効で、パスワードが短すぎる状態で保存しようとしたとします。
```ruby
$ rails console
>> user = User.new(name: "Foo Bar", email: "foo@invalid",
>>                 password: "dude", password_confirmation: "dude")
>> user.save
=> false
>> user.errors.full_messages
=> ["Email is invalid", "Password is too short (minimum is 6 characters)"]
```
[6.2.2](/chapters/modeling_users?version=5.1#sec-presence_validation)で少し触れた `errors.full_messages`オブジェクトは、 エラーメッセージの配列を持っています。

上のコンソールセッションに示されているように、[リスト7.18](/chapters/sign_up?version=5.1#code-first_create_action)で保存に失敗すると、`@user`オブジェクトに関連付けられたエラーメッセージの一覧が生成されます。このメッセージをブラウザで表示するには、ユーザーの`new`ページでエラーメッセージのパーシャル (partial) を出力します。このとき、`form-control`というCSSクラスも一緒に追加することで、Bootstrapがうまく取り扱ってくれるようになります。変更の結果を[リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages)に示します。ここで使っているエラーメッセージのパーシャルは、あくまで試作品である点に注意してください。最終版は[13.3.2](/chapters/user_microposts?version=5.1#sec-creating_microposts)を参照してください。

リスト 7.20: ユーザー登録失敗時にエラーメッセージが表示されるようにする `app/views/users/new.html.erb`
```erb
<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
      <%= render 'shared/error_messages' %>

      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
```
ここでは、`'shared/error_messages'`というパーシャルを`render` (描画) している点に注目してください。Rails全般の慣習として、複数のビューで使われるパーシャルは専用のディレクトリ「`shared`」によく置かれます (実際このパーシャルは[10.1.1](/chapters/updating_and_deleting_users?version=5.1#sec-edit_form)でも使います)。ただし、今はまだ`app/views/shared`といったディレクトリは作っていないので、[表1.1](/chapters/beginning?version=5.1#table-unix_commands)で紹介した`mkdir`コマンドを使い、新しくディレクトリを作成する必要があります。
```sh
$ mkdir app/views/shared
```
また、いつものようにテキストエディタを使ってパーシャル (`_error_messages.html.erb` ) も作成します。パーシャルの内容は[リスト7.21](/chapters/sign_up?version=5.1#code-errors_partial)のようになります。

リスト 7.21: フォーム送信時にエラーメッセージを表示するためのパーシャル `app/views/shared/_error_messages.html.erb`
```erb
<% if @user.errors.any? %>
  <div id="error_explanation">
    <div class="alert alert-danger">
      The form contains <%= pluralize(@user.errors.count, "error") %>.
    </div>
    <ul>
    <% @user.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```
パーシャルによって、RailsとRubyには、Railsエラーオブジェクト用の2つのメソッドを含む多くの成果物が導入されました。最初は`count`メソッドを紹介します。これはエラーの数を返します。
```ruby
>> user.errors.count
=> 2
```
もう1つは`any?`メソッドです。これは`empty?`メソッドと互いに補完します。
```ruby
>> user.errors.empty?
=> false
>> user.errors.any?
=> true
```
[4.2.3](/chapters/rails_flavored_ruby?version=5.1#sec-objects_and_message_passing)では文字列に対して`empty?`メソッドを使いましたが、Railsのエラーオブジェクトに対しても使えます。オブジェクトが空の場合は`true`、 それ以外の場合は `false`を返します。`any?`メソッドはちょうど`empty?`と逆の動作で、要素が1つでもある場合は`true`、ない場合は`false`を返します。(なお、これらの`count`、`empty?`、`any?`メソッドは、Rubyの配列に対してもそのまま使えます。これは[13.2](/chapters/user_microposts?version=5.1#sec-showing_microposts)で応用する予定です。)

さらに、`pluralize`という英語専用のテキストヘルパーが新たに登場しています。これは`helper`オブジェクトを通して、Railsコンソールからも試してみることができます。
```ruby
>> helper.pluralize(1, "error")
=> "1 error"
>> helper.pluralize(5, "error")
=> "5 errors"
```
`pluralize`の最初の引数に整数が与えられると、それに基づいて2番目の引数の英単語を複数形に変更したものを返します。このメソッドの背後には強力な_インフレクター (活用形生成)_ があり、不規則活用を含むさまざまな単語を複数形にすることができます。
```ruby
>> helper.pluralize(2, "woman")
=> "2 women"
>> helper.pluralize(3, "erratum")
=> "3 errata"
```
`pluralize`を使うことで、コードは次のようになります。
```erb
<%= pluralize(@user.errors.count, "error") %>
```
このコードは、例えば `"0 errors"`、`"1 error"`、`"2 errors"` などのように、エラーの数に応じて活用された単語を返します。これにより、`"1 errors"` のような英語の文法に合わない文字列を避けることができます (これはWeb上でどうしようもないほどよく見かけるエラーです)。

[リスト7.21](/chapters/sign_up?version=5.1#code-errors_partial)には、エラーメッセージにスタイルを与えるためのCSS id `error_explanation`も含まれていることに注目してください ([5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)のCSSでスタイルidに「`#`」記号を使ったことを思い出してください)。さらにRailsは、無効な内容の送信によって元のページに戻されると、CSSクラス`field_with_errors`を持った`div`タグでエラー箇所を自動的に囲んでくれます。このラベルを使うことで、[リスト7.22](/chapters/sign_up?version=5.1#code-error_messages_css)のようにエラーメッセージをSCSSで整形することができます。ここでは、Sassの`@extend`関数を使ってBootstrapの`has-error`というCSSクラスを適用してみます。

リスト 7.22: エラーメッセージにスタイルを与えるためのCSS `app/assets/stylesheets/custom.scss`
```scss
.
.
.
/* forms */
.
.
.
#error_explanation {
  color: red;
  ul {
    color: red;
    margin: 0 0 30px 0;
  }
}

.field_with_errors {
  @extend .has-error;
  .form-control {
    color: $state-danger-text;
  }
}
```
[リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages)と[リスト7.21](/chapters/sign_up?version=5.1#code-errors_partial)のコードと、SCSSの[リスト7.22](/chapters/sign_up?version=5.1#code-error_messages_css)を組み合わせることで、無効なユーザー登録情報を送信したときのエラーメッセージが分かりやすくなります ([図7.18](/chapters/sign_up?version=5.1#fig-signup_error_messages))。これらのメッセージはモデルの検証時に生成されるので、メールアドレスのスタイルやパスワードの最小文字列などを変更すると、メッセージも自動的に変更されます。

このとき、`presence: true`によるバリデーションも、`has_secure_password`によるバリデーションも_空の_パスワード (`nil`) を検知してしまうため、ユーザー登録フォームで空のパスワードを入力すると2つの同じエラーメッセージが表示されてしまいます。もちろんこういった冗長なエラーメッセージを直接修正することも可能ですが、幸運にも今回の場合は、後ほど追加する `allow_nil: true` というオプションでこの問題は簡単に解決できます。

図 7.18: ユーザー登録失敗時のエラーメッセージ

#### [演習](#sec-exercises_signup_error_messages)

1.  最小文字数を`5`に変更すると、エラーメッセージも自動的に更新されることを確かめてみましょう。
2.  未送信のユーザー登録フォーム ([図7.12](/chapters/sign_up?version=5.1#fig-signup_form)) のURLと、送信済みのユーザー登録フォーム ([図7.18](/chapters/sign_up?version=5.1#fig-signup_error_messages)) のURLを比べてみましょう。なぜURLは違っているのでしょうか? 考えてみてください。

### [7.3.4 失敗時のテスト](/chapters/sign_up?version=5.1#sec-a_test_for_invalid_submission)

テスト機能を備えた強力なWebフレームワークがなかった時代では、開発者はフォームのテストを毎回手動で行う必要がありました。例えば、もし仮にユーザー登録ページを手動でテストしなければならないとしたら、ブラウザでそのページを表示し、有効なデータと無効なデータを交互に流しこみ、どちらの場合にもアプリケーションが正常に動作することを確認しなければならないでしょう。さらに、アプリケーションに変更が生じるたびに、まったく同じテストを繰り返さなければなりません。このプロセスは苦痛で、バグも見逃してしまいがちです。

しかし幸運なことに、Railsではフォーム用のテストを書くことができ、こういったプロセスを自動化することができます。本項では、無効な送信をしたときの正しい振る舞いについてテストを書いていきます。[7.4.4](/chapters/sign_up?version=5.1#sec-a_test_for_valid_submission)では同様の方法で、有効な送信をしたときの正しい振る舞いについてテストを書いていきます。

まずは、新規ユーザー登録用の統合テストを生成するところから始めていきます。コントローラーの慣習である「リソース名は複数形」に因んで、統合テストのファイル名は`users_signup`とします。
```sh
$ rails generate integration_test users_signup
```
     invoke  test_unit
      create    test/integration/users_signup_test.rb

([7.4.4](/chapters/sign_up?version=5.1#sec-a_test_for_valid_submission)で書くテストでも、ここで生成したファイルを使います)

このテストでは、ユーザー登録ボタンを押したときに (ユーザー情報が無効であるために) ユーザーが_作成されない_ことを確認します (なお、エラーメッセージに対するテストは[7.3.4.1](/chapters/sign_up?version=5.1#sec-exercises_a_test_for_invalid_submission)の演習に回します)。これを確認するために、ユーザーの数を_カウント (count)_ します。このテストの背後で動作する`count`メソッドは、`User`を含むあらゆるActive Recordクラスで使うことができます。
```ruby
$ rails console
>> User.count
=> 1
```
[6.3.4](/chapters/modeling_users?version=5.1#sec-creating_and_authenticating_a_user)の冒頭でデータベースをリセットしてあるので、現時点では`User.count`は`1`になっています (途中で試しにユーザーの追加や削除をしていたら値が違うかもしれませんが、気にする必要はありません)。[5.3.4](/chapters/filling_in_the_layout?version=5.1#sec-layout_link_tests)のように、 `assert_select`を使って関連ページのHTML要素をテストしていきます。これにより、今後うっかり要素を変更してしまっても気付けるようになります。

まずは`get`メソッドを使ってユーザー登録ページにアクセスします。

get signup_path

フォーム送信をテストするためには、 `users_path`に対して`POST`リクエストを送信する必要があります ([表7.1](/chapters/sign_up?version=5.1#table-RESTful_users))。これは、次のように`post`メソッドを使って実現できます
```ruby
assert_no_difference 'User.count' do
  post users_path, params: { user: { name:  "",
                                     email: "user@invalid",
                                     password:              "foo",
                                     password_confirmation: "bar" } }
end
```
`create`アクションの`User.new` ([リスト7.29](/chapters/sign_up?version=5.1#code-signup_flash))で期待されているデータを、`params[:user]`というハッシュにまとめています。なおRails 4.2以前では、`params`を暗黙的に省略しても (`user`ハッシュのみでも) テストが通りました。Rails5.0からは非推奨になり、`params`ハッシュを明示的に含めることが推奨されています。

また、`assert_no_difference`メソッドのブロック内で`post`を使い、メソッドの引数には`'User.count'`を与えています。これは`assert_no_difference`のブロックを実行する前後で引数の値 (`User.count`) が変わらないことをテストしています。すなわちこのテストは、ユーザ数を覚えた後にデータを投稿してみて、ユーザ数が変わらないかどうかを検証するテストになります。したがって、次のコードと等価になります。
```ruby
before_count = User.count
post users_path, ...
after_count  = User.count
assert_equal before_count, after_count
```
これらのコードは等価ではありますが、`assert_no_difference`を使う方が明瞭で、Rubyの慣習的にも正しいです。

また、上のコードでは`get`メソッドを使っていないことにも注目してください。これは各メソッドに技術的な関連性がなく、ユーザー登録ページにアクセスしなくても、直接`post`メソッドを呼び出してユーザー登録ができることを意味しています。個人的には、コンセプトを明確にする意味とユーザー登録ページをダブルチェックする意味も兼ねて、 (実際の手順に倣って) 両方のメソッドを呼び出す方が好きです。

上記のアイデアをコードに落とし込むと、[リスト7.23](/chapters/sign_up?version=5.1#code-a_test_for_invalid_submission)のようになります。なお、送信に失敗したときに`new`アクションが再描画されるはずなので、`assert_template`を使ったテストも含めていることに注意してください。エラーメッセージが正しく表示されているかどうかについては、演習として残しておきます ([7.3.4.1](/chapters/sign_up?version=5.1#sec-exercises_a_test_for_invalid_submission))。

リスト 7.23: 無効なユーザー登録に対するテスト **green** `test/integration/users_signup_test.rb`
```ruby

require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest

  test "invalid signup information" do
    get signup_path
    assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password:              "foo",
                                         password_confirmation: "bar" } }
    end
    assert_template 'users/new'
  end
end
```

アプリケーションコードは既に実装済みなので、今回の統合テストも含め、全てのテストが **green**になるはずです。

リスト 7.24: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_a_test_for_invalid_submission)

1.  [リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages)で実装したエラーメッセージに対するテストを書いてみてください。どのくらい細かくテストするかはお任せします。[リスト7.25](/chapters/sign_up?version=5.1#code-error_messages_test)にテンプレートを用意しておいたので、参考にしてください。
2.  ユーザー登録フォームのURLは /signup ですが、無効なユーザー登録データを送付するとURLが /users に変わってしまいます。これは[リスト5.43](/chapters/filling_in_the_layout?version=5.1#code-signup_route)で追加した名前付きルート (/signup) と、RESTfulなルーティング ([リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)) のデフォルト設定との差異によって生じた結果です。[リスト7.26](/chapters/sign_up?version=5.1#code-post_signup)と[リスト7.27](/chapters/sign_up?version=5.1#code-post_signup_form)の内容を参考に、この問題を解決してみてください。うまくいけばどちらのURLも /signup になるはずです。あれ、でもテストは **green**のままになっていますね...、なぜでしょうか? (考えてみてください)
3.  [リスト7.25](/chapters/sign_up?version=5.1#code-error_messages_test)の`post`部分を変更して、先ほどの演習課題で作った新しいURL (/signup) に合わせてみましょう。また、テストが **green**のままになっている点も確認してください。
4.  [リスト7.27](/chapters/sign_up?version=5.1#code-post_signup_form)のフォームを以前の状態 ([リスト7.20](/chapters/sign_up?version=5.1#code-f_error_messages)) に戻してみて、テストがやはり **green**になっていることを確認してください。これは問題です! なぜなら、現在postが送信されているURLは正しくないのですから。`assert_select`を使ったテストを[リスト7.25](/chapters/sign_up?version=5.1#code-error_messages_test)に追加し、このバグを検知できるようにしてみましょう (テストを追加して **red**になれば成功です)。その後、変更後のフォーム ([リスト7.27](/chapters/sign_up?version=5.1#code-post_signup_form)) に戻してみて、テストが **green** になることを確認してみましょう。_ヒント_: フォームから送信してテストするのではなく、`'form[action="/signup"]'`という部分が存在するかどうかに着目してテストしてみましょう。

リスト 7.25: エラーメッセージをテストするためのテンプレート `test/integration/users_signup_test.rb`
```ruby
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest

  test "invalid signup information" do
    get signup_path
    assert_no_difference 'User.count' do
      post users_path, params: { user: { name:  "",
                                         email: "user@invalid",
                                         password:              "foo",
                                         password_confirmation: "bar" } }
    end
    assert_template 'users/new'
    assert_select 'div#<CSS id for error explanation>'
    assert_select 'div.<CSS class for field with error>'
  end
  .
  .
  .
end
```

リスト 7.26: ユーザー登録のルーティングに`POST`リクエストを追加する `config/routes.rb`
```ruby

Rails.application.routes.draw do
  root 'static_pages#home'
  get  '/help',    to: 'static_pages#help'
  get  '/about',   to: 'static_pages#about'
  get  '/contact', to: 'static_pages#contact'
  get  '/signup',  to: 'users#new'
  post '/signup',  to: 'users#create'
  resources :users
end
```

リスト 7.27: /signup に対して送信する `app/views/users/new.html.erb`
```erb
<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user, url: signup_path) do |f| %>
      <%= render 'shared/error_messages' %>

      <%= f.label :name %>
      <%= f.text_field :name, class: 'form-control' %>

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.label :password_confirmation, "Confirmation" %>
      <%= f.password_field :password_confirmation, class: 'form-control' %>

      <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
</div>
```
[7.4 ユーザー登録成功](/chapters/sign_up?version=5.1#sec-successful_signups)
--------------------------------------------------------------------

無効なフォームの送信を扱えるようになったので、いよいよ新規ユーザーを実際にデータベースに保存できるようにし (もちろんフォームが有効な場合に)、ユーザー登録フォームを完成させましょう。まずは、ユーザーを保存できるようにします。保存に成功すると、ユーザー情報は自動的にデータベースに登録されます。次にブラウザの表示を_リダイレクト_して、登録されたユーザーのプロフィールを表示します。ついでにウェルカムメッセージも表示しましょう。モックアップを[図7.19](/chapters/sign_up?version=5.1#fig-signup_success_mockup)に示します。保存に失敗した場合は、単に[7.3](/chapters/sign_up?version=5.1#sec-unsuccessful_signups)で開発したとおりの動作が実行されます。

図 7.19: ユーザー登録に成功した画面のモックアップ

### [7.4.1 登録フォームの完成](/chapters/sign_up?version=5.1#sec-the_finished_signup_form)

ユーザー登録フォームを完成させるために、[リスト7.19](/chapters/sign_up?version=5.1#code-create_action_strong_parameters)のコメントアウトされた部分にコードを書き、適切に動作するようにしましょう。現状では、環境によって些細な違いはあるものの、基本的には有効な情報で送信するとエラーが発生してしまいます ([図7.20](/chapters/sign_up?version=5.1#fig-valid_submission_error))。これは、Railsはデフォルトのアクションに対応するビューを表示しようとしますが、`create`アクションに対応するビューのテンプレートがないことが原因です ([図7.21](/chapters/sign_up?version=5.1#fig-no_create_template_error))。

図 7.20: 有効な情報でユーザー登録をしても元の画面に戻される

図 7.21: サーバーのログ情報から`create`テンプレートが原因だと分かる

もちろん、`create`アクションに対応するテンプレートを作成することもできますが、Railsの一般的な慣習に倣って、ユーザー登録に成功した場合はページを描画せずに別のページに_リダイレクト (Redirect)_ するようにしてみましょう。具体的には、新しく作成されたユーザーのプロフィールページにリダイレクトしてみようと思います (場合によってはルートURLにリダイレクトするのも１つの選択肢でしょう)。実際のアプリケーションコードを[リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)に示します (`redirect_to` メソッドに注目してください)。

リスト 7.28: 保存とリダイレクトを行う、userの`create`アクション `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController
  .
  .
  .
  def create
    @user = User.new(user_params)
    if @user.save
      redirect_to @user
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
end
```

ここで、

redirect_to @user

といった行がありますが、これは次のコードと等価になります。

redirect_to user_url(@user)

これは`redirect_to @user`というコードから (Railsエンジニアが) `user_url(@user)`といったコードを実行したいということを、Railsが推察してくれた結果になります。

#### [演習](#sec-exercises_the_finished_signup_form)

1.  有効な情報を送信し、ユーザーが実際に作成されたことを、Railsコンソールを使って確認してみましょう。
2.  [リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)を更新し、`redirect_to user_url(@user)`と`redirect_to @user`が同じ結果になることを確認してみましょう。

### [7.4.2 flash](/chapters/sign_up?version=5.1#sec-the_flash)

[リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)のコードによって、ユーザー登録フォームが実際に動くようになりました。これでブラウザから正しいユーザー情報を登録できるようになりましたが、その前にWebアプリケーションに常識的に備わっている機能を追加してみましょう。登録完了後に表示されるページにメッセージを表示し (この場合は新規ユーザーへのウェルカムメッセージ)、2度目以降にはそのページにメッセージを表示しないようにするというものです。

Railsでこういった情報を表示するためには、_flash_という特殊な変数を使います。この変数はハッシュのように扱います。Railsの一般的な慣習に倣って、`:success`というキーには成功時のメッセージを代入するようにします ([リスト7.29](/chapters/sign_up?version=5.1#code-signup_flash))。

リスト 7.29: ユーザー登録ページにフラッシュメッセージを追加する `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController
  .
  .
  .
  def create
    @user = User.new(user_params)
    if @user.save
      flash[:success] = "Welcome to the Sample App!"
      redirect_to @user
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
end
```

`flash`変数に代入したメッセージは、リダイレクトした直後のページで表示できるようになります。今回は`flash`内に存在するキーがあるかを調べ、もしあればその値 (メッセージ) を全て表示するように、レイアウトを修正します。[4.3.3](/chapters/rails_flavored_ruby?version=5.1#sec-hashes_and_symbols)の時にコンソール上で実行した例を思い出してみてください。そこではあえて`flash`と名付けた変数を使い、ハッシュの値を列挙しました ([リスト7.30](/chapters/sign_up?version=5.1#code-flash_iteration))。

リスト 7.30: コンソールで`flash`ハッシュをイテレート (each do ... end) する
```ruby
$ rails console
>> flash = { success: "It worked!", danger: "It failed." }
=> {:success=>"It worked!", danger: "It failed."}
>> flash.each do |key, value|
>>   puts "#{key}"
>>   puts "#{value}"
>> end
success
It worked!
danger
It failed.
```
上で示したパターンに則って、flash変数の内容をWebサイト全体にわたって表示できるようにすると、次のようなコードになります。
```erb
<% flash.each do |message_type, message| %>
  <div class="alert alert-<%= message_type %>"><%= message %></div>
<% end %>
```
なお、このコードではHTMLとERbが雑に混ざっていますが、これをキレイに整形する作業は演習として残しておきましょう ([7.4.4.1](/chapters/sign_up?version=5.1#sec-exercises_a_test_for_valid_submission))。さて、次の埋め込みRubyでは、
```erb
alert-<%= message_type %>
```
適用するCSSクラスをメッセージの種類によって変更するようにしています。これにより、例えば`:success`キーのメッセージが表示される場合、適用されるCSSクラスは次のようになります。
```ruby
alert-success
```
このとき、`:success`キーはシンボルでしたが、テンプレート内に反映させる際に埋め込みRubyが自動的に`"success"`という文字列に変換している点に注意してください。この性質を利用することで、キーの内容によって異なったCSSクラスを適用させることができ、メッセージの種類によってスタイルを動的に変更させることができます。例えば、[8.1.4](/chapters/basic_login?version=5.1#sec-rendering_with_a_flash_message)では`flash[:danger]`を使ってログインに失敗したことを表すメッセージを表示します[11](#cha-7_footnote-11) (実際、既に`alert-danger`というCSSクラスを使って、[リスト7.21](/chapters/sign_up?version=5.1#code-errors_partial)のエラーメッセージのスタイルをdivタグで指定しています)。Bootstrap CSSは、このようなflashのクラス用に4つのスタイルを持っています (`success`、`info`、`warning`、`danger`)。また、本書のサンプルアプリケーションでは、これらの全てのスタイルを場合に応じて使っていきます (例えば[11.2](/chapters/account_activation?version=5.1#sec-account_activation_emails)では`info`を、[8.1.4](/chapters/basic_login?version=5.1#sec-rendering_with_a_flash_message)では`danger`を使います)。

テンプレート内にflashのメッセージが差し込まれるので、次のようなコードは、
```ruby
flash[:success] = "Welcome to the Sample App!"
```
最終的には次のようなHTMLになります。
```html
<div class="alert alert-success">Welcome to the Sample App!</div>
```
先ほど説明した埋め込みRubyをレイアウトに埋め込んだ結果を、[リスト7.31](/chapters/sign_up?version=5.1#code-layout_flash)に示します。

リスト 7.31: `flash`変数の内容をWebサイトのレイアウトに追加する `app/views/layouts/application.html.erb`
```html
<!DOCTYPE html>
<html>
  .
  .
  .
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <% flash.each do |message_type, message| %>
        <div class="alert alert-<%= message_type %>"><%= message %></div>
      <% end %>
      <%= yield %>
      <%= render 'layouts/footer' %>
      <%= debug(params) if Rails.env.development? %>
    </div>
    .
    .
    .
  </body>
</html>
```
#### [演習](#sec-exercises_the_flash)

1.  コンソールに移り、文字列内の式展開 ([4.2.2](/chapters/rails_flavored_ruby?version=5.1#sec-strings)) でシンボルを呼び出してみましょう。例えば`"#{:success}"`といったコードを実行すると、どんな値が返ってきますか? 確認してみてください。
2.  先ほどの演習で試した結果を参考に、[リスト7.30](/chapters/sign_up?version=5.1#code-flash_iteration)のflashはどのような結果になるか考えてみてください。

### [7.4.3 実際のユーザー登録](/chapters/sign_up?version=5.1#sec-the_first_signup)

ここまでの変更がうまくいったかどうか確認するため、実際にサンプルアプリケーションでユーザー登録を試してみましょう。ただし、[図7.20](/chapters/sign_up?version=5.1#fig-valid_submission_error)のようにこれまでに何度かフォームを使って実験を繰り返しているため、Usersコントローラの`user.save`の行が実行され、ユーザーの数が読者ごとに異なっている可能性があります。そこで、ユーザー登録を試す前に、次のコマンドを実行してデータベースの内容を一旦リセットしてしまいましょう。
```sh
$ rails db:migrate:reset
```
環境によっては、ここでWebサーバーを再起動する必要があります。必要に応じてCtrl-Cなどを使って、再起動しておいてください ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。

準備が整ったところで、早速最初のユーザーを登録してみましょう。今回は名前を「Rails Tutorial」、メールアドレスを「example@railstutorial.org」として登録してみます ([図7.22](/chapters/sign_up?version=5.1#fig-first_signup))。フォームから登録すると、ユーザー登録の成功を示すウェルカムメッセージが、`success`クラスのさわやかな緑色の背景で表示されます ([図7.23](/chapters/sign_up?version=5.1#fig-signup_flash))。このクラスは、[5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)で追加したのBootstrap CSSフレームワークによって準備されたものです。そしてユーザー表示ページを再度読み込むと、今度はフラッシュメッセージは表示されなくなります ([図7.24](/chapters/sign_up?version=5.1#fig-signup_flash_reloaded))。

図 7.22: ユーザー登録に必要な情報を入力する

図 7.23: ユーザー登録が成功し、フラッシュメッセージが表示される

図 7.24: ページを再読み込みすると、フラッシュメッセージが表示されなくなる

#### [演習](#sec-exercises_the_first_signup)

1.  Railsコンソールを使って、新しいユーザーが本当に作成されたのかもう一度チェックしてみましょう。結果は、[リスト7.32](/chapters/sign_up?version=5.1#code-user_created)のようになるはずです。
2.  自分のメールアドレスでユーザー登録を試してみましょう。既にGravatarに登録している場合、適切な画像が表示されているか確認してみてください。

リスト 7.32: データベースから新しく作られたユーザーを検索する
```ruby
$ rails console
> User.find_by(email: "example@railstutorial.org")
=> #<User id: 1, name: "Rails Tutorial", email: "example@railstutorial.
org", created_at: "2016-05-31 17:17:33", updated_at: "2016-05-31 17:17:33",
password_digest: "$2a$10$8MaeHdnOhZvMk3GmFdmpPOeG6a7u7...">
```
### [7.4.4 成功時のテスト](/chapters/sign_up?version=5.1#sec-a_test_for_valid_submission)

次に進む前に、ここで一旦、有効な送信に対するテストを書いてみます。これによって、アプリケーションの振る舞いを検証し、もし今後バグが埋め込まれたらそれを検知できるようになります。[7.3.4](/chapters/sign_up?version=5.1#sec-a_test_for_invalid_submission)で書いた無効な送信に対するテストと同様に、今回の目的はデータベースの中身が正しいかどうか検証することです。すなわち、有効な情報を送信して、ユーザーが_作成された_ことを確認します。[リスト7.23](/chapters/sign_up?version=5.1#code-a_test_for_invalid_submission)のときは次のようにテストを書きましたが、
```ruby
assert_no_difference 'User.count' do
  post users_path, ...
end
```
今回は`assert_difference`というメソッドを使ってテストを書きます。
```ruby
assert_difference 'User.count', 1 do
  post users_path, ...
end
```
`assert_no_difference`と同様に、このメソッドは第一引数に文字列 (`'User.count'`) を取り、`assert_difference`ブロック内の処理を実行する直前と、実行した直後の`User.count`の値を比較します。第二引数はオプションですが、ここには比較した結果の差異 (今回の場合は1) を渡します。

[リスト7.23](/chapters/sign_up?version=5.1#code-a_test_for_invalid_submission)と同じファイルに`assert_difference`を使ったテストを追加すると、[リスト7.33](/chapters/sign_up?version=5.1#code-a_test_for_valid_submission)のようになります。ここで、`users_path`にPOSTリクエストを送信した後に、`follow_redirect!`というメソッドを使っていることに注目してください。このメソッドは、POSTリクエストを送信した結果を見て、指定されたリダイレクト先に移動するメソッドです。したがって、この行の直後では`'users/show'`テンプレートが表示されているはずです。ちなみに、ここでflashのテストも追加しておくとよいでしょう。これは演習として残しておきます ([7.4.4.1](/chapters/sign_up?version=5.1#sec-exercises_a_test_for_valid_submission))。

リスト 7.33: 有効なユーザー登録に対するテスト **green** `test/integration/users_signup_test.rb`
```ruby
require 'test_helper'

class UsersSignupTest < ActionDispatch::IntegrationTest
  .
  .
  .
  test "valid signup information" do
    get signup_path
    assert_difference 'User.count', 1 do
      post users_path, params: { user: { name:  "Example User",
                                         email: "user@example.com",
                                         password:              "password",
                                         password_confirmation: "password" } }
    end
    follow_redirect!
    assert_template 'users/show'
  end
end
```

[リスト7.33](/chapters/sign_up?version=5.1#code-a_test_for_valid_submission)では、ユーザー登録に成功させた後に、どのテンプレートが表示されているのか検証していることにも注目してください。このテストを成功させるためには、Userのルーティング ([リスト7.3](/chapters/sign_up?version=5.1#code-users_resource)) とUserの`show`アクション ([リスト7.5](/chapters/sign_up?version=5.1#code-user_show_action))、そして`show.html.erb`ビュー ([リスト7.8](/chapters/sign_up?version=5.1#code-user_show_view_with_gravatar)) がそれぞれ正しく動いている必要があります。最後に、
```ruby
assert_template 'users/show'
```
上のコードでは、ユーザープロフィールに関するほぼ全て (例えばページにアクセスしたらなんらかの理由でエラーが発生しないかどうかなど) をテストできていることに注目してください。この類のエンドツーエンドテストは、アプリケーションの重要な機能をカバーしてくれています。こういった理由が統合テストが便利だと呼ばれる所以です。

#### [演習](#sec-exercises_a_test_for_valid_submission)

1.  [7.4.2](/chapters/sign_up?version=5.1#sec-the_flash)で実装したflashに対するテストを書いてみてください。どのくらい細かくテストするかはお任せします。[リスト7.34](/chapters/sign_up?version=5.1#code-flash_test)に最小限のテンプレートを用意しておいたので、参考にしてください (`FILL_IN`の部分を適切なコードに置き換えると完成します)。ちなみに、テキストに対するテストは壊れやすいです。文量の少ないflashのキーであっても、それは同じです。筆者の場合、flashが空でないかをテストするだけの場合が多いです。
2.  本文中でも指摘しましたが、flash用のHTML ([リスト7.31](/chapters/sign_up?version=5.1#code-layout_flash)) は読みにくいです。より読みやすくした[リスト7.35](/chapters/sign_up?version=5.1#code-layout_flash_content_tag)のコードに変更してみましょう。変更が終わったらテストスイートを実行し、正常に動作することを確認してください。なお、このコードでは、Railsの`content_tag`というヘルパーを使っています。
3.  [リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)のリダイレクトの行をコメントアウトすると、テストが失敗することを確認してみましょう。
4.  [リスト7.28](/chapters/sign_up?version=5.1#code-user_create_action)で、`@user.save`の部分を`false`に置き換えたとしましょう (バグを埋め込んでしまったと仮定してください)。このとき、`assert_difference`のテストではどのようにしてこのバグを検知するでしょうか? テストコードを追って考えてみてください。

リスト 7.34: flashをテストするためのテンプレート `test/integration/users_signup_test.rb`
```ruby
require 'test_helper'
  .
  .
  .
  test "valid signup information" do
    get signup_path
    assert_difference 'User.count', 1 do
      post users_path, params: { user: { name:  "Example User",
                                         email: "user@example.com",
                                         password:              "password",
                                         password_confirmation: "password" } }
    end
    follow_redirect!
    assert_template 'users/show'
    assert_not flash.FILL_IN
  end
end
```

リスト 7.35: `content_tag`を使ってレイアウトの中に`flash`を埋め込む `app/views/layouts/application.html.erb`
```erb
<!DOCTYPE html>
<html>
      .
      .
      .
      <% flash.each do |message_type, message| %>
        <%= content_tag(:div, message, class: "alert alert-#{message_type}") %>
      <% end %>
      .
      .
      .
</html>
```
[7.5 プロのデプロイ](/chapters/sign_up?version=5.1#sec-professional_grade_deployment)
------------------------------------------------------------------------------

ユーザー登録ページを動かすことができたので、このアプリケーションをデプロイして、本番環境でも動かせるようにしてみましょう。[第3章](/chapters/static_pages?version=5.1#cha-static_pages)からデプロイをして来ましたが、実際にデータを_操作できるようにする_デプロイは初めてです。そこで、この機会にプロレベルのデプロイ方法について説明していきます。具体的には、ユーザー登録をセキュアにするために、本番用のアプリケーションに重要な機能を追加していきます。その後、デフォルトのWebサーバーを実際の世界で使われているWebサーバーに置き換えていきます。

デプロイの下準備として、まずはこの時点までの変更を`master`ブランチにマージしておいてください。

```sh
$ git add -A
$ git commit -m "Finish user signup"
$ git checkout maste
$ git merge sign-up
```
### [7.5.1 本番環境でのSSL](/chapters/sign_up?version=5.1#sec-ssl_in_production)

本章で開発したユーザー登録フォームで送信すると、名前やメールアドレス、パスワードといったデータがネットワーク越しに流されていきます。実は、このようなネットワークに流れるデータは途中で捕捉できるため、扱いには注意が必要です。これはサンプルアプリケーションの本質的なセキュリティ上の欠陥です。そしてこれを修正するために[Secure Sockets Layer (SSL)](https://ja.wikipedia.org/wiki/Transport_Layer_Security)を使います [12](#cha-7_footnote-12) 。これはローカルのサーバーからネットワークに流れる前に、大事な情報を暗号化する技術です。今回はユーザー登録ページのためだけにSSLを導入しますが、これはWebサイト全体で適用できるため、[第8章](/chapters/basic_login?version=5.1#cha-basic_login)で実装するログイン機構をセキュアにしたり、[9.1](/chapters/advanced_login?version=5.1#sec-remember_me).で説明する_セッションハイジャック (Session Hijacking)_ の脆弱性に対しても多くの利点を生み出します。

SSLを有効化するのも簡単です。`production.rb`という本番環境の設定ファイルの1行を修正するだけで済みます。具体的には、`config`に「本番環境ではSSLを使うようにする」という設定をするだけです ([リスト7.36](/chapters/sign_up?version=5.1#code-ssl_in_production))。

ちなみに、Herokuではデフォルトの設定でもSSLを使用できるのですが、SSLの使用をブラウザに強制するわけではありません。このため、ユーザーがhttpsではなくhttpでにアクセスしてしまうと、Webサイトとユーザーとの間のやりとりが安全ではなくなってしまいます (気になる方は、ブラウザのアドレスバーにあるURLをhttpsからhttpに変更してみましょう)。Railsではありがたいことに、本番環境用の設定ファイルである`production.rb`のコードをたった1行変更するだけでSSLを強制し、httpsによる安全な通信を確立できます。具体的には次の[リスト7.36](/chapters/sign_up?version=5.1#code-ssl_in_production)に示すように、`config.force_ssl`を`true`に設定するだけで完了です。

リスト 7.36: 本番環境ではSSLを使うように修正する `config/environments/production.rb`
```ruby
Rails.application.configure do
  .
  .
  .
  # Force all access to the app over SSL, use Strict-Transport-Security,
  # and use secure cookies.
  config.force_ssl = true
  .
  .
  .
end
```

次に、遠隔にあるサーバーのSSLをセットアップします。本番用のWebサイトでSSLを使えるようにするためには、ドメイン毎に_SSL証明書_を購入し、セットアップする必要があります。これには多くの作業が必要となりますが、幸運にもそういった作業をしなくても済む方法があります。それは、Heroku上でサンプルアプリケーションを動かし、HerokuのSSL証明書に便乗する方法です (訳注: ただし、この方法はHerokuのサブドメインでのみ有効です。独自ドメインを使う場合はSSL証明書を購入する必要があります)。結果として、[7.5.2](/chapters/sign_up?version=5.1#sec-production_webserver)でアプリケーションのデプロイが終わると、自動的にSSLが有効化されているはずです。もしwww.example.comなどの独自ドメインでSSLを使いたい場合は、[HerokuのSSLに関するドキュメント](http://devcenter.heroku.com/articles/ssl) (英語) を参照してください。

### [7.5.2 本番環境用のWebサーバー](/chapters/sign_up?version=5.1#sec-production_webserver)

SSLを導入したので、次はアプリケーションの設定をいじって、本番環境に適したWebサーバーを使ってみましょう。Herokuのデフォルトでは、Rubyだけで実装されたWEBrickというWebサーバーを使っています。WEBrickは簡単にセットアップできたり動せることが特長ですが、著しいトラフィックを扱うことには適していません。つまり、WEBrickは[本番環境として適切なWebサーバーではありません](https://devcenter.heroku.com/articles/ruby-default-web-server)。よって、今回は[WEBrickをPumaに置き換えてみます](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server)。Pumaは多数のリクエストを捌くことに適したRuby/Rackアプリケーション用のサーバーです。

新しいアプリケーションサーバーを追加するために、[Heroku内のPumaドキュメント](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server) (英語) に従ってセットアップしていきます。

最初のステップは`puma` gemを`Gemfile`に追加することなのですが、なんとRails5では、Pumaはデフォルトの設定でも使えるようになっています ([リスト3.2](/chapters/static_pages?version=5.1#code-gemfile_sample_app))。したがって、最初のステップはスキップします (ちなみにRails 4.2以前では`config/puma.rb`ファイルを作成し、[リスト7.37](/chapters/sign_up?version=5.1#code-production_webserver_config)のように設定していました)。次のステップは、[HerokuのPumaのドキュメント](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server)に従って、設定を書き込んでいくことです ([リスト7.37](/chapters/sign_up?version=5.1#code-production_webserver_config))[13](#cha-7_footnote-13) 。とはいえ今回はドキュメントのコードをそのまま引用しただけなので、中身は理解しなくても大丈夫です ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。

リスト 7.37: 本番環境のWebサーバー設定ファイル `config/puma.rb`
```ruby
workers Integer(ENV['WEB_CONCURRENCY'] || 2)
threads_count = Integer(ENV['RAILS_MAX_THREADS'] || 5)
threads threads_count, threads_count

preload_app!

rackup      DefaultRackup
port        ENV['PORT']     || 3000
environment ENV['RACK_ENV'] || 'development'

on_worker_boot do
  # Worker specific setup for Rails 4.1+
  # See: https://devcenter.heroku.com/articles/
  # deploying-rails-applications-with-the-puma-web-server#on-worker-boot
  ActiveRecord::Base.establish_connection
end
```

最後に、`Procfile`と呼ばれる、Heroku上でPumaのプロセスを走らせる設定ファイルを作成します ([リスト7.38](/chapters/sign_up?version=5.1#code-procfile))。なお、この`Procfile`はルートディレクトリ (`Gemfile`と同じディレクトリ) に置いておく必要があるので、ファイルの置き場所には注意してください。

リスト 7.38: Pumaが使うように`Procfile`で定義する `./Procfile`
```Procfile
web: bundle exec puma -C config/puma.rb
```
### [7.5.3 本番環境へのデプロイ](/chapters/sign_up?version=5.1#sec-production_deployment)

これで、本番環境用のWebサーバーの設定は完了しました。これらの変更をコミットし、デプロイしてみましょう[14](#cha-7_footnote-14) 。

```sh
$ rails test
$ git add -A
$ git commit -m "Use SSL and the Puma webserver in production"
$ git push
$ git push herok
$ heroku run rails db:migrate
```
ユーザー登録フォームが無事に動いたら成功です。成功すると[図7.25](/chapters/sign_up?version=5.1#fig-signup_in_production)のようになります。このとき、URLが`https://`に変わっていて、アドレスバーに鍵アイコンが表示されていることにも注目してください ([図7.25](/chapters/sign_up?version=5.1#fig-signup_in_production))。これは先ほど設定したSSLがうまく動いていることを示しています。

図 7.25: 本番環境 (Web上) で実際にユーザー登録をしてみる

#### [Rubyのバージョン番号](#sec-ruby_version_number)

ところで、Herokuのデプロイするとき、もしかしたら次のような警告メッセージを目にしたことがあるかもしれません。
```sh
###### WARNING:
       You have not declared a Ruby version in your Gemfile.
       To set your Ruby version add this line to your Gemfile:
       ruby '2.1.5'
```
(これは「Rubyのバージョンを明示的に指定してください」というメッセージですが) 経験的には、本書のようなチュートリアルの段階では明示的に指定しない方がスムーズに進むことが多いので、この警告は現時点では無視してしまった方がよいでしょう。というのも、サンプルアプリケーションでRubyのバージョンを常に最新に保っておくと、多大な不都合に繋がりかねないからです[15](#cha-7_footnote-15) 。また、本書のサンプルアプリケーションにおいては、ローカルで使っているバージョンと本番環境のバージョンが異なっていても、違いが生じることはほぼ無いでしょう。とは言うものの、次の点は頭の片隅に置いておいてください。それは、仕事でHerokuを使ったアプリケーションを動かす場合は`Gemfile`でRubyのバージョンを明示しておいた方が賢明である、という点です。これによって開発環境と本番環境の互換性を最大限に高めることができるので、(バージョンの差異による誤作動やエラーなどが無くなり) オススメです。

#### [演習](#sec-exercises_puma_in_production)

1.  ブラウザから本番環境 (Heroku) にアクセスし、SSLの鍵マークがかかっているか、URLが`https`になっているかどうかを確認してみましょう。
2.  本番環境でユーザーを作成してみましょう。Gravatarの画像は正しく表示されているでしょうか?

[7.6 最後に](/chapters/sign_up?version=5.1#sec-sign_up_conclusion)
---------------------------------------------------------------

ユーザー登録機能の実装は、私たちのサンプルアプリケーションにとって大きなマイルストーンでした。この時点でサンプルアプリケーションはかなり実用的になってきましたが、まだ重要な機能がいくつも残っています。[第8章](/chapters/basic_login?version=5.1#cha-basic_login)と[第9章](/chapters/advanced_login?version=5.1#cha-advanced_login)では、認証 (authentication) システムを導入し、ユーザーがログインとログアウトをできるようにします ([remember me] という発展的な機能も実装します)。続く[第10章](/chapters/updating_and_deleting_users?version=5.1#cha-updating_showing_and_deleting_users)では、どのユーザーも自分のアカウント情報を更新できるようにし、Webサイトの管理者がユーザーを削除できるようにします。それにより、Usersリソースに[表7.1](/chapters/sign_up?version=5.1#table-RESTful_users)のRESTアクションがすべて実装されるようにします。

### [7.6.1 本章のまとめ](/chapters/sign_up?version=5.1#sec-sign_up_what_we_learned_in_this_chapter)

*   `debug`メソッドを使うことで、役立つデバッグ情報を表示できる
*   Sassのmixin機能を使うと、CSSのルールをまとめたり他の場所で再利用できるようになる
*   Railsには標準で3つ環境が備わっており、それぞれ`開発環境 (development)`、`テスト環境 (test)`、`本番環境 (production)`と呼ぶ
*   標準的なRESTfulなURLを通して、ユーザー情報を_リソース_として扱えるようになった
*   Gravatarを使うと、ユーザーのプロフィール画像を簡単に表示できるようになる
*   `form_for`ヘルパーは、Active Recordのオブジェクトに対応したフォームを生成する
*   ユーザー登録に失敗した場合はnewビューを再描画するようにした。その際、Active Recordが自動的に検知したエラーメッセージを表示できるようにした
*   `flash`変数を使うと、一時的なメッセージを表示できるようになる
*   ユーザー登録に成功すると、データベース上にユーザーが追加、プロフィールページにリダイレクト、ウェルカムメッセージの表示といった順で処理が進む
*   統合テストを使うことで送信フォームの振る舞いを検証したり、バグの発生を検知したりできる
*   セキュアな通信と高いパフォーマンスを確保するために、本番環境ではSSLとPumaを導入した

[1.](#cha-7_footnote-ref-1) [Mockingbird](http://gomockingbird.com/)はプロフィール写真のようなカスタム画像はサポートされていません。[図7.1](/chapters/sign_up?version=5.1#fig-profile_mockup_profile_name)では[GIMP](http://www.gimp.org/)を使って手動で画像を置きました。

[2.](#cha-7_footnote-ref-2) 画像の引用元: http://www.flickr.com/photos/43803060@N00/24308857/ kaon 2014-06-16. Copyright © 2002 by Shaun Wallin. [Creative Commons Attribution 2.0 Generic](https://creativecommons.org/licenses/by/2.0/)

[3.](#cha-7_footnote-ref-3) 実は、この3つ以外にもカスタムの環境を作成することができます。詳細については「[環境を追加した場合のRailsCast](http://railscasts.com/episodes/72-adding-an-environment) (英語)」を参照してください。

[4.](#cha-7_footnote-ref-4) 実際に表示される内容はRailsのバージョンごとに微妙に異なります。例えば Rails5 からは、デバッグ情報の中には `permitted` というステータスに関する情報も含まれるようになりました ([7.3.2](/chapters/sign_up?version=5.1#sec-strong_parameters))。こういった些細な差異については熟練の目で見ていきましょう ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication))。

[5.](#cha-7_footnote-ref-5) Railsの`debug`情報は [YAML](http://www.yaml.org/) (一種の[再帰的略語](http://catb.org/jargon/html/R/recursive-acronym.html)であり、“YAML Ain’t Markup Language” の略とされています) 形式で表示されます。YAMLは人間_だけでなく_コンピュータにとっても読みやすい形式です。

[6.](#cha-7_footnote-ref-6) この時点では、_ルーティング_は動作していますが、対応するページが動作しているとは限りません。例えば /users/1/edit がUsersコントローラの`edit`アクションに正常にルーティングされているとしても、`edit`アクションが存在しなければ、このURLにアクセスしたときにエラーになります。

[7.](#cha-7_footnote-ref-7) 例えば、`touch app/views/users/show.html.erb`コマンドを使ってみてください。

[8.](#cha-7_footnote-ref-8) ヒンズー教では、アバターは人間や動物の形をとって神が顕現したものと考えられています。これを拡大解釈して、特にTwitterなどのSNS界隈では_アバター_という用語が、その人物そのものを表現するもの (かつその人の一部でもある) という意味で使われているようです。

[9.](#cha-7_footnote-ref-9) [リスト7.11](/chapters/sign_up?version=5.1#code-sidebar_css)では`.gravatar_edit`というCSSクラスを追加しています。これは[第10章](/chapters/updating_and_deleting_users?version=5.1#cha-updating_showing_and_deleting_users)でも使われます。

[10.](#cha-7_footnote-ref-10) 動作の詳細を知りたい場合は、Stack Overflowの[Rails信頼性トークン関連の書き込み](http://stackoverflow.com/questions/941594/understand-rails-authenticity-token) (英語) を参照してください。

[11.](#cha-7_footnote-ref-11) 実際には、これに非常に近い`flash.now`を使いますが、本当に必要になるまでは使わないようにしようかと思います。

[12.](#cha-7_footnote-ref-12) 正確にはSSLからTLS (Transport Layer Security) と名称が変わりましたが、未だに「SSL」と呼ばれています。

[13.](#cha-7_footnote-ref-13) [リスト7.37](/chapters/sign_up?version=5.1#code-production_webserver_config)では少しだけコードの見栄えを修正しています。これは標準的な1行80文字の制限に合わせるための変更です。

[14.](#cha-7_footnote-ref-14) 本章ではデータモデルに対して変更を加えていなかったので、[6.4](/chapters/modeling_users?version=5.1#sec-modeling_users_conclusion)のステップが済んでいれば、本当はHeroku上でマイグレーションを実行しなくても問題ないはずです。ただし、読者からトラブル報告がいくつか来ていたので、念のため`heroku run rails db:migrate`を実行するようにしています。

[15.](#cha-7_footnote-ref-15) 例えば、 ローカルマシンでRuby 2.1.4がインストールできなくて何時間も過ごしてしまい、なんとか無事にインストールできたと思ったら、先日Ruby 2.1.5がリリースされたことに気付いたときなどです。ちなみにRuby 2.1.5のインストールにも苦戦しました。
