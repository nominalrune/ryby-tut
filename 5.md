[第5章レイアウトを作成する](/chapters/filling_in_the_layout?version=5.1#cha-filling_in_the_layout)
======================================================================================

関連: Progate[「HTML & CSS」コース](https://prog-8.com/languages/html?utm_source=rails_tutorial)

[第4章](/chapters/rails_flavored_ruby?version=5.1#cha-rails_flavored_ruby)の簡単なRubyツアーでは、サンプルアプリケーションにアプリケーションスタイルシートを含める方法を学びました ([4.1](/chapters/rails_flavored_ruby?version=5.1#sec-motivation))。しかし[4.3.4](/chapters/rails_flavored_ruby?version=5.1#sec-css_revisited)で指摘したとおり、このスタイルシートはまだ空のままです。この章では、アプリケーションにBootstrapフレームワークを組み込み、そして、カスタムスタイルを追加します[^1.]。また、これまで作成したページ (HomeやAboutなど) へのリンクをレイアウトに追加します ([5.1](/chapters/filling_in_the_layout?version=5.1#sec-structure))。その途中で、パーシャル、Railsのルーティング、Asset Pipelineについて学び、さらにSassについても紹介します([5.2](/chapters/filling_in_the_layout?version=5.1#sec-sass_and_the_asset_pipeline))。章の最後に、ユーザーをサイトにログインさせるための重要な一歩を踏み出します ([5.4](/chapters/filling_in_the_layout?version=5.1#sec-user_signup))。

本章では、サンプルアプリケーションにレイアウトを追加したり、修正したりといった部分に注力していきます。また、レイアウトについてはテスト駆動開発で進めたり、全くテストを書かない箇所もあります (テストを書くときと書かないときのガイドラインについては[コラム3.3](/chapters/static_pages?version=5.1#aside-when_to_test)で解説します)。このため、本章ではテキストエディタによる修正とブラウザによる確認がほとんどになります。テスト駆動開発で進める唯一の箇所は、[5.3.1](/chapters/filling_in_the_layout?version=5.1#sec-contact_page)のContactページを追加する箇所のみです。最後に、新しいテスト手法「 統合テスト (_Integration Test_)」について紹介します ([5.3.4](/chapters/filling_in_the_layout?version=5.1#sec-layout_link_tests))。統合テストを使って、最終的なレイアウトやリンクが正しいかどうかをチェックします。

[5.1 構造を追加する](/chapters/filling_in_the_layout?version=5.1#sec-structure)
------------------------------------------------------------------------

RailsチュートリアルはWeb開発のための本であり、Webデザインの本ではありませんが、だからといって_何のスタイルもない_寒々しい外観のアプリケーションでいつまでも作業を続けていると憂鬱になってしまいます。そこでこの章では、レイアウトにいくつかの構造とCSSを与えて、最小限のスタイルを追加します。カスタムCSSルールの他に、Twitter社によるオープンソースのWebデザインフレームワークとして公開している[_Bootstrap_](http://getbootstrap.com/)も利用します。また、_コード_そのものにもスタイルを与えます。つまり、散らかり始めたレイアウトのコードを、_パーシャル (Partial)_ 機能を使って整えていくということです。

Webアプリケーションを作成するときに、ユーザーインターフェイスの概要をできるだけ早いうちに把握しておくことがしばしば有用です。そこで本書では、_モックアップ_ (Webの文脈ではよく_ワイヤーフレーム_と呼ばれます) という、実装後のアプリケーションの外観をスケッチして使っていきます[^2.]。また本章では、主に[3.2](/chapters/static_pages?version=5.1#sec-static_pages)で紹介したサイトロゴ、ナビゲーションヘッダー、サイトフッターを含む静的ページを開発します。これらのページの中で最も重要な、Homeページのモックアップを[図5.1](/chapters/filling_in_the_layout?version=5.1#fig-home_page_mockup)に示します。モックアップに基いて作成した最終結果は[図5.9](/chapters/filling_in_the_layout?version=5.1#fig-site_with_footer)で確認することができます。両者を見比べると、細部が若干異なることに気が付くでしょう (例えば、実際には最後にRailsのロゴをページに追加します)。しかしモックアップは正確である必要はありませんので、これで十分です。

図 5.1: サンプルアプリケーションのHomeページのモックアップ

Gitでバージョン管理をしているのであれば、これまでと同様、この時点で新しいブランチを作成するのがよいでしょう。
```sh
$ git checkout -b filling-in-layout
```
### [5.1.1 ナビゲーション](/chapters/filling_in_the_layout?version=5.1#sec-adding_to_the_layout)

第一段階として、サンプルアプリケーションにリンクとスタイルを追加するために、サイトのレイアウトファイル`application.html.erb` ([リスト4.3](/chapters/rails_flavored_ruby?version=5.1#code-application_layout_full_title)) にHTML構造を追加し、レイアウトファイルを更新します。この更新には、領域 (divタグ) の追加、CSSクラスの追加、サイトナビゲーションの起点となる領域の追加も含まれます。完全なファイルを[リスト5.1](/chapters/filling_in_the_layout?version=5.1#code-layout_new_structure)に示します。続いて、これを構成している多くの部品について解説します。表示結果を今すぐ確認したいのであれば、[図5.2](/chapters/filling_in_the_layout?version=5.1#fig-layout_no_logo_or_custom_css)で確認できます (_注:_この時点ではわざわざ見に行くほどの仕上がりではありませんが)。

#### リスト 5.1: 構造を追加したWebサイトのレイアウト `app/views/layouts/application.html.erb`

<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <%= csrf_meta_tags %>
    <%= stylesheet_link_tag    'application', media: 'all',
                               'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application',
                               'data-turbolinks-track': 'reload' %>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js">
      </script>
    <![endif]-->
  </head>
  <body>
    <header class="navbar navbar-fixed-top navbar-inverse">
      <div class="container">
        <%= link_to "sample app", '#', id: "logo" %>
        <nav>
          <ul class="nav navbar-nav navbar-right">
            <li><%= link_to "Home",   '#' %></li>
            <li><%= link_to "Help",   '#' %></li>
            <li><%= link_to "Log in", '#' %></li>
          </ul>
        </nav>
      </div>
    </header>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>

それでは、[リスト5.1](/chapters/filling_in_the_layout?version=5.1#code-layout_new_structure)の新しい要素を上から順に見ていきましょう。[3.4.1](/chapters/static_pages?version=5.1#sec-testing_titles)でも簡単に説明しましたが、RailsはデフォルトでHTML5を使います (`<!DOCTYPE html>`と書いてHTML5であることを宣言します)。ただHTML5は比較的新しく、一部のブラウザ (特に旧式のInternet Explorer) ではHTML5のサポートが不完全である場合があります。そのため、次のようなJavaScriptのコード (通称: [HTML5 shim (or shiv)](https://github.com/aFarkas/html5shiv))[^3.]を使ってこの問題を回避します。

<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js">
  </script>
<![endif]-->

上のコードには、次のような奇妙な構文が含まれています。

<!--[if lt IE 9]>

これは、Microsoft Internet Explorer (IE) のバージョンが9より小さい場合 (`if lt IE 9`) にのみ、囲まれている行を実行します。この風変わりな文法 `[if lt IE 9]` は、Railsの一部_ではありません_。これは実は、[条件付きコメント](https://ja.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88)と呼ばれるもので、今回のような状況のためにInternet Explorerで特別にサポートされています。これにより、Firefox、Chrome、Safariなどの他のブラウザに影響を与えずに、IEのバージョンが9未満の場合に_のみ_HTML5 shimを読み込めるため、非常に好都合です。

それに続くセクションには、サイトのロゴを表示する`header`、(`div`タグによる) いくつかの領域、ナビゲーションリンクのリストがあります。

<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", '#', id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",   '#' %></li>
        <li><%= link_to "Help",   '#' %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>

`header`タグは、ページの上部に来るべき要素を表します。この`header`タグには、`navbar`、`navbar-fixed-top`、`navbar-inverse`という３つの_CSSクラス_がスペース区切りで与えられています[^4.]。

<header class="navbar navbar-fixed-top navbar-inverse">

すべてのHTML要素には、クラスと_id_の両方を指定することができます。これらは単なるラベルで、CSSでスタイルを指定するときに便利です ([5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css))。クラスとidの主な違いは、クラスはページ内で何度でも使えるのに対し、idは一度しか使えない点です。今回の場合、すべてのnavbarクラスには、[5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)でインストールするBootstrapフレームワークによって特別な意味が与えられます。

`header`タグの内側には`div`タグがあります。

<div class="container">

`div`タグは一般的な表示領域を表し、要素を別々のパーツに分けるときに使われます。特に古いスタイルのHTMLでは、`div`タグはサイト内のほぼすべての領域で使われていました。しかしHTML5からはよく使われる領域ごとに細分化できるようになり、具体的には`header`要素、`nav`要素、`section`要素が新たに使えるようになりました。なお、`header`タグのクラスと同様に、`div`タグにもCSSクラス (`container`) が与えていますが、このクラスもBootstrapにおいて特別な意味を持っています。

divに続いて、埋め込みRubyコードが出現します。

<%= link_to "sample app", '#', id: "logo" %>
<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><%= link_to "Home",   '#' %></li>
    <li><%= link_to "Help",   '#' %></li>
    <li><%= link_to "Log in", '#' %></li>
  </ul>
</nav>

ここでは、リンクを生成するために、Railsヘルパーの`link_to`を使います ([3.2.2](/chapters/static_pages?version=5.1#sec-custom_static_pages)で見たアンカータグ`a`が最終的に生成されます)。`link_to`の第1引数はリンクテキスト、第2引数はURLです。このURLは[5.3.3](/chapters/filling_in_the_layout?version=5.1#sec-named_routes)で_名前付きルート (Named Routes)_ に置き換えますが、今はWebデザインで一般に使われるスタブ用の (とりあえずのダミーとして使われる) URL「`'#'`」を置いておきます。第3引数はオプションハッシュで、この場合はサンプルアプリのリンクでCSSid `logo`を指定しています(他の3つのリンクにはオプションハッシュが指定されていませんが、必須ではないので構いません)。Railsヘルパーは、このようにオプションのハッシュを取ることがよくあり、これによりRailsのコードから離れることなく任意のHTMLオプションを柔軟に追加することができます。

divの内側の2番目の要素は、_リストアイテム_タグ`li`と_順不同リスト_タグ`ul`によって作られた、ナビゲーションリンクのリストです。

<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><%= link_to "Home",   '#' %></li>
    <li><%= link_to "Help",   '#' %></li>
    <li><%= link_to "Log in", '#' %></li>
  </ul>
</nav>

正確にはここでは不要なのですが、`nav`タグには「その内側がナビゲーションリンクである」という意図を明示的に伝える役割があります。さらに、`ul`タグに付与されている`nav`や`navbar-nav`、`navbar-right`クラスもBootstrapにおいて特別な意味を持ちます。したがって、[5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)でBootstrapのCSSを追加したときに、これらのスタイルも自動的に適用されます。ブラウザからソースを見ることで確認ができますが、Railsが埋め込みRubyを評価し、レイアウトを描画すると、上のリストは次のように置き換わります[^5.]。

<nav>
  <ul class="nav navbar-nav navbar-right">
    <li><a href="#">Home</a></li>
    <li><a href="#">Help</a></li>
    <li><a href="#">Log in</a></li>
  </ul>
</nav>

これがブラウザに返されるHTMLになります。

レイアウトの最後の部分は、メインコンテンツ用の`div`です。

<div class="container">
  <%= yield %>
</div>

上と同様、`container`クラスもBootstrapにおいて特別な意味を持ちます。[3.4.3](/chapters/static_pages?version=5.1#sec-layouts_and_embedded_ruby)で学んだように、`yield`メソッドはWebサイトのレイアウトにページごとの内容を挿入します。

[5.1.3](/chapters/filling_in_the_layout?version=5.1#sec-partials)で追加するサイトフッターを除いて、これでレイアウトは完成しました。Homeページへアクセスして表示結果を確認することができます。今後のスタイル要素を利用するために、`home.html.erb`ビューに特別な要素をいくつか追加します ([リスト5.2](/chapters/filling_in_the_layout?version=5.1#code-signup_button))。

#### リスト 5.2: サインアップページへのリンクがあるHomeページ `app/views/static_pages/home.html.erb`

<div class="center jumbotron">
  <h1>Welcome to the Sample App</h1>

  <h2>
    This is the home page for the
    <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    sample application.
  </h2>

  <%= link_to "Sign up now!", '#', class: "btn btn-lg btn-primary" %>
</div>

<%= link_to image_tag("rails.png", alt: "Rails logo"),
            'http://rubyonrails.org/' %>

[第7章](/chapters/sign_up?version=5.1#cha-sign_up)でサイトにユーザーを追加するときに備えて、最初の`link_to`で次のような仮のリンクを生成します。

<a href="#" class="btn btn-lg btn-primary">Sign up now!</a>

上で挙げた`div`タグのCSSクラス`jumbotron`や、signupボタンの`btn`クラス、`btn-lg`クラス、`btn-primary`クラスはすべて、Bootstrapにおいて特別な意味を持ちます。

2番目の`link_to`では、引数として画像ファイルのパスと任意のオプションハッシュをとる`image_tag`ヘルパーの能力が示されています。このヘルパーでは、シンボルを使って`alt`属性などを設定できます。一方で画像を表示するためには、`rails.png`というRailsのロゴ画像ファイルを加える必要があります。Ruby on Rails公式ページの [https://railstutorial.jp/rails.png](https://railstutorial.jp/rails.png) から画像をダウンロードして、`app/assets/images/`ディレクトリにおいてください[^6.]。クラウドIDEやUnix系のOS (Max OS Xなど) を使っている場合は、次のように`curl`コマンドで簡単に取得することができます ([リスト5.3](/chapters/filling_in_the_layout?version=5.1#code-curl_rails_png))。(詳細については[『_開発基礎編 コマンドライン_』](https://railstutorial.jp/command_line)の[`curl`](https://railstutorial.jp/command_line/inspecting_files#sec-downloading_a_file)をご覧ください)

#### リスト 5.3: 画像をダウンロードする
$ curl -o app/assets/images/rails.png -OL railstutorial.jp/rails.png
```
[リスト5.2](/chapters/filling_in_the_layout?version=5.1#code-signup_button)で `image_tag`ヘルパーを使っているので、Railsは該当する画像ファイルを、アセットパイプラインを通して`app/assets/images/`ディレクトリの中から探してくれます (アセットパイプラインについては[5.2](/chapters/filling_in_the_layout?version=5.1#sec-sass_and_the_asset_pipeline)で説明します)。

さて、これで準備は完了です。環境によっては、ここで一度Railsサーバーを再起動する必要がある場合もあるので、必要に応じて ([コラム1.1](/chapters/beginning?version=5.1#aside-technical_sophistication)) 再起動を試してみてください。うまく行くと、次の[図5.2](/chapters/filling_in_the_layout?version=5.1#fig-layout_no_logo_or_custom_css)のような結果になるはずです。

図 5.2: カスタムCSSを使っていないHomeページ

`image_tag`の効果を確かめるために、ブラウザから生成されたHTMLを見てみましょう[^7.]。

<img alt="Rails logo" src="/assets/rails-9308b8f92fea4c19a3a0d8385b494526.png" />

ファイル名が重ならないようにするために、`9308b8f92fea4c19a3a0d8385b494526`という文字列 (実際の文字列はシステムごとに異なります) をRailsが追加していることがわかります。これは、例えば画像ファイルを新しい画像に更新したときに、ブラウザ内に保存されたキャッシュに意図的にヒットさせないようにするための仕組みです。また、`src`属性には "`images`" というディレクトリ名が_含まれていない_ことにも注目してください。これは`assets`ディレクトリ内の他のディレクトリ (imagesやjavascripts、stylesheetsなど) も同様です。これは高速化のための仕組みで、Railsは`assets`ディレクトリ直下の画像を`app/assets/images`ディレクトリにある画像と紐付けています。これにより、ブラウザから見るとすべてのファイルが同じディレクトリにあるように見えるようになります。そして、このようなフラットなディレクトリ構成を採っていると、ファイルをより高速にブラウザに渡すことができるようになります。最後に、`alt`属性は、画像がない場合に代わりに表示される文字列です。例えば視覚障害のあるユーザーが使うスクリーンリーダーでは、ここの属性が読み上げられて、そこに画像があることが示されます。

いよいよ、ここまでの苦労の成果を確認する準備ができました ([図5.2](/chapters/filling_in_the_layout?version=5.1#fig-layout_no_logo_or_custom_css))。思っていたよりもみすぼらしいでしょうか。そうかもしれません。しかし、今回HTML要素に理にかなったクラスを付与したおかげで、CSSを使ってスタイルが追加できる素晴らしい状況になりました。

#### [演習](#sec-exercises_adding_to_the_layout)

1.  Webページと言ったらネコ画像、というぐらいにはWebにはネコ画像が溢れていますよね。[リスト5.4](/chapters/filling_in_the_layout?version=5.1#code-downloading_a_cat_pic)のコマンドを使って、[図5.3](/chapters/filling_in_the_layout?version=5.1#fig-kitten)のネコ画像をダウンロードしてきましょう[^8.]。
2.  `mv`コマンドを使って、ダウンロードした`kitten.jpg`ファイルを適切なアセットディレクトリに移動してください (参考: [5.2.1](/chapters/filling_in_the_layout?version=5.1#sec-the_asset_pipeline))。
3.  `image_tag`を使って、`kitten.jpg`画像を表示してみてください ([図5.4](/chapters/filling_in_the_layout?version=5.1#fig-kitten_on_home))。

図 5.3: Webで必須 (?) の子ネコ画像

#### リスト 5.4: ネコ画像をインターネットからダウンロードする
$ curl -OL cdn.learnenough.com/kitten.jpg
```
図 5.4: 子ネコ画像をHomeページに表示させた結果

### [5.1.2 BootstrapとカスタムCSS](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)

[5.1.1](/chapters/filling_in_the_layout?version=5.1#sec-adding_to_the_layout)では、多くのHTML要素にCSSクラスを関連付けました。こうしておくことで、CSSベースでレイアウトを構成する際に高い柔軟性を与えてくれます。[5.1.1](/chapters/filling_in_the_layout?version=5.1#sec-adding_to_the_layout)で述べたように、これらのクラスの多くは、Twitterが作成したフレームワークである[Bootstrap](http://getbootstrap.com/)特有のものです。Bootstrapを使うと、洗練されたWebデザインとユーザーインターフェイス要素を簡単にHTML5アプリケーションに追加することができます。この節では、サンプルアプリケーションにスタイルを追加するために、カスタムCSSルールとBootstrapを組み合わせて使います。注目すべき点は、Bootstrapを使うことでアプリケーションを[_レスポンシブデザイン (Responsive Design)_](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B7%E3%83%96%E3%82%A6%E3%82%A7%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3) にできるということです。これにより、どの端末でアプリケーションを閲覧しても、ある程度見栄えをよくすることができます。

最初に、[リスト5.5](/chapters/filling_in_the_layout?version=5.1#code-bootstrap_sass)で示しているようにBootstrapを追加しましょう。これは、`bootstrap-sass` gemを使ってRailsアプリケーションに導入できます[^9.]。Bootstrapフレームワークでは、動的なスタイルシートを生成するために[LESS CSS](http://lesscss.org/)言語を使っていますが、RailsのAsset Pipelineはデフォルトでは (LESSと非常によく似た) Sass言語をサポートします ([5.2](/chapters/filling_in_the_layout?version=5.1#sec-sass_and_the_asset_pipeline))。そのため、`bootstrap-sass`は、LESSをSassへ変換し、必要なBootstrapファイルを現在のアプリケーションですべて利用できるようにします[10](#cha-5_footnote-10) 。

#### リスト 5.5: `Gemfile`に`bootstrap-sass`を追加する `Gemfile`

source 'https://rubygems.org'

gem 'rails',          '5.1.6'
gem 'bootstrap-sass', '3.3.7'
.
.
.

いつものように`bundle install`を実行して、Bootstrapをインストールします。
```sh
$ bundle install
```
ちなみに、`rails generate`コマンドを実行することでコントローラーごとに分けられたCSSファイルが自動的に生成されますが、これらのファイルを正しい順序で読み込ませるのは至難の技なので、本チュートリアルでは (簡潔のために) すべてのCSSを1つにまとめる方針を採っています。カスタムCSSを動かすための最初の一歩は、カスタムCSSファイルを作ることです。
```sh
$ touch app/assets/stylesheets/custom.scss
```
(ここでは[3.3.3](/chapters/static_pages?version=5.1#sec-green) の途中で紹介した `touch` コマンドを使っていますが、ファイルが作成できるなら [新規ファイル作成] や他のコマンドでも問題ありません。) このディレクトリ名とファイル名は、どちらも重要です。次のディレクトリは、

app/assets/stylesheets/

Asset Pipeline ([5.2](/chapters/filling_in_the_layout?version=5.1#sec-sass_and_the_asset_pipeline))の一部であり、このディレクトリに置かれたスタイルシートは`application.css`の一部としてWebサイトのレイアウトに読み込まれます。さらに、ファイル名の`custom.scss`には`.scss`という拡張子も含まれています。この拡張子は「Sass (Sassy CSS)」と呼ばれるCSSを拡張した言語で、アセットパイプラインはこのファイルの拡張子を見て、Sassを処理できるようにしています (Sassは[5.2.2](/chapters/filling_in_the_layout?version=5.1#sec-sass)まで登場しませんが、`bootstrap-sass` gemが動作するためのおまじないとして必要です)。

カスタムCSS用のファイルを作成したら、[リスト5.6](/chapters/filling_in_the_layout?version=5.1#code-bootstrap_css)のように`@import`を使って、Bootstrap (とそれに関連するSprockets) を読み込みます[11](#cha-5_footnote-11) 。

#### リスト 5.6: Bootstrap CSSを追加する `app/assets/stylesheets/custom.scss`

@import "bootstrap-sprockets";
@import "bootstrap";

[リスト5.6](/chapters/filling_in_the_layout?version=5.1#code-bootstrap_css)の2行では、Bootstrap CSSのフレームワークを導入しています。導入後、Webサーバーを再起動させると、アプリケーションに反映させることができます。([1.3.2](/chapters/beginning?version=5.1#sec-rails_server)で紹介したように、Ctrl-Cを押してWebサーバーを停止させた後、`rails server`コマンドを打ってWebサーバーを起動してください)。うまくいけば[図5.5](/chapters/filling_in_the_layout?version=5.1#fig-sample_app_only_bootstrap)のような結果になります。さて、テキストの配置は今ひとつで、ロゴにはスタイルもありませんが、色使いとsignupボタンはなかなかよい感じになってきました。

図 5.5: Bootstrap CSSとサンプルアプリケーション

次に、[リスト5.7](/chapters/filling_in_the_layout?version=5.1#code-universal_css)に示したように、Webサイト全体にわたってレイアウトと個別のページにスタイルを与えるためのCSSを追加します。テストの結果を[図5.6](/chapters/filling_in_the_layout?version=5.1#fig-sample_app_universal)に示します。[リスト5.7](/chapters/filling_in_the_layout?version=5.1#code-universal_css)には多数の記述ルールがあります。CSSの記述ルールを把握するためには、関心のある箇所をコメントアウトして表示を確認することをお勧めします。CSSでは `/* … */` でコメントアウトできるので、調べてみたいコードをこれで囲い、表示がどのように変わるかを確認してみてください。

#### リスト 5.7: すべてのページに適用される共通のスタイルをCSSに追加する `app/assets/stylesheets/custom.scss`

@import "bootstrap-sprockets";
@import "bootstrap";

/* universal */

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}

図 5.6: スペースや共通スタイルを追加した結果

[リスト5.7](/chapters/filling_in_the_layout?version=5.1#code-universal_css)のCSSの形式は一貫しています。CSSルールでは一般に、クラス、id、HTMLタグ、またはそれらの組み合わせ、のいずれかを指定します。そしてその後ろにスタイリングコマンドのリストを記述します。例えば次のコードでは、

body {
  padding-top: 60px;
}

ページ上部に60ピクセルの余白を追加します。`header`タグに`navbar-fixed-top`クラスが与えられているので、これに従ってBootstrapはナビゲーションバーをページ上部に固定し、ナビゲーションバーの下に余白を置いて主要部分から分離します (デフォルトのnavbarの色がBootstrap 2.0から変更されたため、現在の淡色の代わりにダークな色調にしたい場合は`navbar-inverse`クラスを使う必要があります)。また、このルールにある次のCSSは、

.center {
  text-align: center;
}

`center`クラスに`text-align: center`プロパティを関連付けています。言い換えると、`.center`冒頭のドット`.`は、このルールがクラスに対してスタイルを適用することを示しています。なお、[リスト5.9](/chapters/filling_in_the_layout?version=5.1#code-logo_css)に示したように、冒頭がポンド記号`#`で始まる場合は、そのルールがCSSの_id_に対してスタイルを適用することを示します。今回の場合、`center`クラスに属している (`div`などの) タグの内側にある要素が、すべて中央揃えになることを意味しています ([リスト5.2](/chapters/filling_in_the_layout?version=5.1#code-signup_button)が実際の使用例です)。

Bootstrapには洗練されたタイポグラフィーを利用できるCSSルールがありますが、ここではさらに、[リスト5.8](/chapters/filling_in_the_layout?version=5.1#code-typography_css)のようにカスタムCSSルールを追加し、テキストの見栄えを変えてみましょう。なお、今回追加するルールはHomeページのすべてで適用されるとは限りませんが、サンプルアプリケーションの他の場所でも使われます。[リスト5.8](/chapters/filling_in_the_layout?version=5.1#code-typography_css)を反映した結果を、[図5.7](/chapters/filling_in_the_layout?version=5.1#fig-sample_app_typography)で確認することができます。

#### リスト 5.8: 洗練されたタイポグラフィーを利用するためのCSSを追加する `app/assets/stylesheets/custom.scss`

@import "bootstrap-sprockets";
@import "bootstrap";
.
.
.
/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.2em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: #777;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}

図 5.7: タイポグラフィースタイルを追加する

最後に、いくつかのルールをサイトロゴに追加します。このサイトロゴは「sample app」だけが表示されているシンプルなものです。[リスト5.9](/chapters/filling_in_the_layout?version=5.1#code-logo_css)のCSSは、テキストを大文字に変換し、サイズ、色、配置を変更します (サイトロゴがページ内で一度しか使われないことを前提としてCSS idを使っていますが、代わりにクラスを使うこともできます)。

#### リスト 5.9: サイトロゴにCSSを追加する `app/assets/stylesheets/custom.scss`

@import "bootstrap-sprockets";
@import "bootstrap";
.
.
.
/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}

上のコードの`color: #fff`は、ロゴの色を白に変更します。HTMLの色は、16進数 (基数が16) の3つの数値の組み合わせで表現され、赤、緑、青の三原色に (この順序で) コード化することができます。本来は`#ffffff`と書いて3色すべてを最大にする必要がありますが、上のコードでは`#fff`という`#ffffff`の短縮形を使っています。ちなみにCSS標準では、[HTMLの色には別名](https://www.w3schools.com/colors/colors_names.asp)も多数定義されています。例えば先ほどの`#fff`は、`white`と書くこともできます。話を戻して、[リスト5.9](/chapters/filling_in_the_layout?version=5.1#code-logo_css)のCSSが反映されると、[図5.8](/chapters/filling_in_the_layout?version=5.1#fig-sample_app_logo)のようになっていれば成功です。

図 5.8: デザインされたロゴとサンプルアプリ

#### [演習](#sec-exercises_custom_css)

1.  [リスト5.10](/chapters/filling_in_the_layout?version=5.1#code-comment_out_image)を参考にして、[5.1.1.1](/chapters/filling_in_the_layout?version=5.1#sec-exercises_adding_to_the_layout)で使ったネコ画像をコメントアウトしてみてください。また、ブラウザのHTMLインスペクタ機能を使って、コメントアウトするとHTMLのソースからも消えていることを確認してみてください。
2.  [リスト5.11](/chapters/filling_in_the_layout?version=5.1#code-css_hide_image)のコードを`custom.scss`に追加し、すべての画像を非表示にしてみてください。うまくいけば、Railsのロゴ画像がHomeページから消えるはずです。先ほどと同様にインスペクタ機能を使って、今度はHTMLのソースコードは残ったままで、画像だけが表示されなくなっていることを確認してみてください。

リスト 5.10: 埋め込みRubyのコードをコメントアウトする

<%#= image_tag("kitten.jpg", alt: "Kitten") %>

リスト 5.11: すべての画像を非表示にするCSS

img {
  display: none;
}

### [5.1.3 パーシャル (partial)](/chapters/filling_in_the_layout?version=5.1#sec-partials)

レイアウトのコード ([リスト5.1](/chapters/filling_in_the_layout?version=5.1#code-layout_new_structure)) はその目的を果たしていますが、まだ少々散らかっています。例えば、IE特有の風変わりな文法のHTML shimだけで3行も占有していますが、もしこれをうまく隠すことができたらどんなによいでしょう。また、HTMLヘッダーは論理的な単位として分けられるため、一箇所にまとめた方が便利です。Railsでは_パーシャル (partial)_ という機能でこのような課題を解決できます。最初に、パーシャルを定義するとレイアウトがどのように変わるかを見てみましょう ([リスト5.12](/chapters/filling_in_the_layout?version=5.1#code-layout_with_partials))。

リスト 5.12: レイアウトにshimとheaderのパーシャルを追加する `app/views/layouts/application.html.erb`

<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <%= csrf_meta_tags %>
    <%= stylesheet_link_tag    'application', media: 'all',
                               'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application',
                               'data-turbolinks-track': 'reload' %>
    <%= render 'layouts/shim' %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
    </div>
  </body>
</html>

[リスト5.12](/chapters/filling_in_the_layout?version=5.1#code-layout_with_partials)では、次のように`render`と呼ばれるRailsヘルパー呼び出しだけを使って、HTML shimのスタイルシート行を置換しています。

<%= render 'layouts/shim' %>

この行では、`app/views/layouts/_shim.html.erb`というファイルを探してその内容を評価し、結果をビューに挿入しています[12](#cha-5_footnote-12) (`<%= ... %>` は、テンプレート内でRubyの式を評価するための埋め込みRuby記法であることを思い出してください。評価した結果がテンプレートに挿入されます)。ファイル名 `_shim.html.erb` の先頭にあるアンダースコアに注目してください。このアンダースコアは、パーシャルで使う普遍的な命名規約であり、また、一目見ただけでディレクトリ中のすべてのパーシャルを識別することが可能になります。

もちろん、パーシャルが動作するためには、それに対応するファイルとコンテンツを記述しなければなりません。このshimパーシャルの場合は、[リスト5.1](/chapters/filling_in_the_layout?version=5.1#code-layout_new_structure)のわずか3行のshimコードだけです。作成したコードを[リスト5.13](/chapters/filling_in_the_layout?version=5.1#code-stylesheets_partial)に示します。

リスト 5.13: HTML shim用のパーシャル `app/views/layouts/_shim.html.erb`

<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js">
  </script>
<![endif]-->

同様に、ヘッダーの情報も[リスト5.14](/chapters/filling_in_the_layout?version=5.1#code-header_partial)のパーシャルに移動し、`render`を呼び出してレイアウトに挿入することができます。(パーシャルでは、自動生成せずに、テキストエディタを使って手動で作成するのが一般的です。)

リスト 5.14: header用のパーシャル `app/views/layouts/_header.html.erb`

<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", '#', id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",   '#' %></li>
        <li><%= link_to "Help",   '#' %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>

これでパーシャルの作成方法がわかりましたので、今度はヘッダーに対応するフッタを同じ方法で追加しましょう。ここまでくれば、ファイル名は `_footer.html.erb` で、layoutsディレクトリ ([リスト5.15](/chapters/filling_in_the_layout?version=5.1#code-footer_partial)) に置けばよいということが分かると思います[13](#cha-5_footnote-13) 。

リスト 5.15: footer用のパーシャル `app/views/layouts/_footer.html.erb`

<footer class="footer">
  <small>
    The <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    by <a href="http://www.michaelhartl.com/">Michael Hartl</a>
  </small>
  <nav>
    <ul>
      <li><%= link_to "About",   '#' %></li>
      <li><%= link_to "Contact", '#' %></li>
      <li><a href="http://news.railstutorial.org/">News</a></li>
    </ul>
  </nav>
</footer>

ヘッダーの場合と同様に、フッターの中でも`link_to`メソッドを使って、AboutページとContactページへの内部リンクを追加してあります。ひとまず、リンク先のURLは`'#'`としておきます (`header`タグと同様、`footer`タグもHTML5で新たに追加された要素です)。

footerパーシャルは、スタイルシートやheaderパーシャルのときと同じ方法でレイアウト中に追加できます ([リスト5.16](/chapters/filling_in_the_layout?version=5.1#code-layout_with_footer))。

リスト 5.16: レイアウトにfooterパーシャルを追加する `app/views/layouts/application.html.erb`

<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <%= csrf_meta_tags %>
    <%= stylesheet_link_tag    'application', media: 'all',
                               'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application',
                               'data-turbolinks-track': 'reload' %>
    <%= render 'layouts/shim' %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div>
  </body>
</html>

そのまま実際にfooterを表示してみるとどうにも見苦しいので、[リスト5.17](/chapters/filling_in_the_layout?version=5.1#code-footer_css)でスタイルを若干追加しましょう。スタイルを追加した結果を[図5.9](/chapters/filling_in_the_layout?version=5.1#fig-site_with_footer)に示します。

リスト 5.17: サイトにfooter用CSSを追加する `app/assets/stylesheets/custom.scss`

.
.
.
/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #777;
}

footer a {
  color: #555;
}

footer a:hover {
  color: #222;
}

footer small {
  float: left;
}

footer ul {
  float: right;
  list-style: none;
}

footer ul li {
  float: left;
  margin-left: 15px;
}

図 5.9: Homeページにfooterを追加する

#### [演習](#sec-exercises_partials)

1.  Railsがデフォルトで生成する`head`タグの部分を、[リスト5.18](/chapters/filling_in_the_layout?version=5.1#code-rails_default_head)のように`render`に置き換えてみてください。_ヒント_: 単純に削除してしまうと後でパーシャルを１から書き直す必要が出てくるので、削除する前にどこかに退避しておきましょう。
2.  [リスト5.18](/chapters/filling_in_the_layout?version=5.1#code-rails_default_head)のようなパーシャルはまだ作っていないので、現時点ではテストは **red**になっているはずです。実際にテストを実行して確認してみましょう。
3.  `layouts`ディレクトリに`head`タグ用のパーシャルを作成し、先ほど退避しておいたコードを書き込み、最後にテストが **green** に戻ることを確認しましょう。

リスト 5.18: Railsのデフォルトのheadタグを`render`に置き換える `app/views/layouts/application.html.erb`

<!DOCTYPE html>
<html>
  <head>
    <title><%= full_title(yield(:title)) %></title>
    <%= render 'layouts/rails_default' %>
    <%= render 'layouts/shim' %>
  </head>
  <body>
    <%= render 'layouts/header' %>
    <div class="container">
      <%= yield %>
      <%= render 'layouts/footer' %>
    </div>
  </body>
</html>

[5.2 Sassとアセットパイプライン](/chapters/filling_in_the_layout?version=5.1#sec-sass_and_the_asset_pipeline)
--------------------------------------------------------------------------------------------------

最近のRailsに追加された機能の中で最も特筆すべき機能の１つは、CSS、JavaScript、画像などの静的コンテンツの生産性と管理を大幅に強化する「_アセットパイプライン (Asset Pipeline)_」です。このセクションでは、アセットパイプラインの概要と、素晴らしいCSS生成ツールである「_Sass_」の使い方について説明します。

### [5.2.1 アセットパイプライン](/chapters/filling_in_the_layout?version=5.1#sec-the_asset_pipeline)

Rails開発者の視点からは、アセットディレクトリ、マニフェストファイル、プリプロセッサエンジンという、3つの主要な機能が理解の対象となります[14](#cha-5_footnote-14) 。では、それぞれを順に見ていきましょう。

#### [アセットディレクトリ](#sec-asset_directories)

Railsのアセットパイプラインでは、静的ファイルを目的別に分類する、標準的な３つのディレクトリが使われています。

*   `app/assets`: 現在のアプリケーション固有のアセット
*   `lib/assets`: あなたの開発チームによって作成されたライブラリ用のアセット
*   `vendor/assets`: サードパーティのアセット

これらのディレクトリには、それぞれのアセットクラス用のサブディレクトリがあります。例えばapp/assetsの場合、次のような画像用、JavaScript用、CSS用のサブディレクトリがあります。
```sh
$ ls app/assets/
```
mages/  javascripts/  stylesheets/

上記の説明から、[5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)で取り上げたカスタムCSSが配置された場所と、その理由について理解することができると思います。つまり、`custom.scss`はサンプルアプリケーション固有のアセットなので、`app/assets/stylesheets`に配置されていたのです。

#### [マニフェストファイル](#sec-manifest_files)

静的ファイル (アセット) を上記の場所へそれぞれ配置すれば、_マニフェストファイル_を使って、それらをどのように1つのファイルにまとめるのかをRailsに指示することができます。なお、実際にアセットをまとめる処理を行うのは[Sprockets](https://github.com/rails/sprockets)というgemです。また、マニフェストファイルはCSSとJavaScriptには適用されますが、画像ファイルには適用されません。1つの具体例として、アプリケーションのCSS用マニフェストファイルを見てみましょう ([リスト5.19](/chapters/filling_in_the_layout?version=5.1#code-app_css_manifest))。

リスト 5.19: アプリケーション固有のCSS用マニフェストファイル `app/assets/stylesheets/application.css`

/*
 * This is a manifest file that'll be compiled into application.css, which
 * will include all the files listed below.
 *
 * Any CSS and SCSS file within this directory, lib/assets/stylesheets,
 * vendor/assets/stylesheets, or vendor/assets/stylesheets of plugins, if any,
 * can be referenced here using a relative path.
 *
 * You're free to add application-wide styles to this file and they'll appear
 * at the bottom of the compiled file so the styles you add here take
 * precedence over styles defined in any styles defined in the other CSS/SCSS
 * files in this directory. It is generally better to create a new file per
 * style scope.
 *
 *= require_tree .
 *= require_self
 */

上の行で重要な部分は、実はCSSコメントの中にあります。コメント内の次の部分は、Sprocketsが適切なファイルを読み込むために使われます。

/*
 .
 .
 .
 *= require_tree .
 *= require_self
*/

例えばこの行は、

 *= require_tree .

`app/assets/stylesheets`ディレクトリ (サブディレクトリを含む) 中のすべてのCSSファイルが、アプリケーションCSSに含まれるようにしています。また、次の行は、

 *= require_self

CSSの読み込みシーケンスの中で、`application.css`自身もその対象に含めています。

Railsには実用的なデフォルトのマニフェストファイルが付属しているので、Railsチュートリアルでは変更を加える必要がありませんが、もし必要な場合は、Railsガイドの「[アセットパイプライン](http://railsguides.jp/asset_pipeline.html)」で詳細な情報を参照できます。

#### [プリプロセッサエンジン](#sec-preprocessor_engines)

必要なアセットをディレクトリに配置してまとめた後、Railsはさまざまなプリプロセッサエンジンを介してそれらを実行し、ブラウザに配信できるようにそれらをマニフェストファイルを用いて結合し、サイトテンプレート用に準備します。Railsはどのプリプロセッサを使うのかを、ファイル名の拡張子を使って判断します。最も一般的な拡張子は、Sass用の`.scss`、CoffeeScript用の`.coffee`、埋め込みRuby (ERb) 用の`.erb`です。[3.4.3](/chapters/static_pages?version=5.1#sec-layouts_and_embedded_ruby)では最初にERbを、[5.2.2](/chapters/filling_in_the_layout?version=5.1#sec-sass)ではSassをそれぞれ扱いました (なお本書では詳しく説明しませんが、CoffeeScriptはエレガントかつ簡潔な言語で、JavaScriptにコンパイルしてくれるJavaScriptの拡張言語です)。

プリプロセッサエンジンは、繋げて実行する (chain) ことができます。

`foobar.js.coffee`

上の拡張子の場合、CoffeeScriptプロセッサ経由で実行されます。

`foobar.js.erb.coffee`

上の拡張子の場合は、CoffeeScriptとERbの両方で実行されます (コードは右から左へと実行されますので、この例ではCoffeeScriptが最初に実行されます)。

#### [本番環境での効率性](#sec-efficiency_in_production)

Asset Pipelineの最大のメリットの1つは、本番のアプリケーションで効率的になるように最適化されたアセットも自動的に生成されることです。従来は、CSSとJavaScriptを整理するために、機能を個別のファイルに分割し、(インデントを多用して) 読みやすいフォーマットに整えていました。これは、プログラマにとっては便利な方法ですが、本番環境にとっては非効率です。それというのも、最小化されていないCSSやJavaScriptファイルを多数に分割すると、ページの読み込み時間が著しく遅くなるからです (読み込み時間は、ユーザー体験の質に影響を与える重要な指標の1つです)。Asset Pipelineを使うと、この「開発効率と読み込み時間のどちらを重視するか」という問題について悩む必要がなくなります。開発環境ではプログラマにとって読みやすいように整理しておき、本番環境ではAsset Pipelineを使ってファイルを最小化すればよいのです。具体的には、Asset Pipelineがすべてのスタイルシートを1つのCSSファイル (`application.css`) にまとめ、すべてのJavaScriptファイルを1つのJSファイル (`javascripts.js`) にまとめてくれます。さらに、それらのファイルすべてに対して 不要な空白やインデントを取り除く処理を行い、ファイルサイズを_最小化_してくれます。結果として、開発環境と本番環境という、2つの異なった状況に対してそれぞれ最高の環境を提供してくれます。

### [5.2.2 素晴らしい構文を備えたスタイルシート](/chapters/filling_in_the_layout?version=5.1#sec-sass)

関連: Progate[「Sass」コース](https://prog-8.com/languages/sass?utm_source=rails_tutorial)

_Sass_ は、スタイルシートを記述するための言語であり、CSSに比べて多くの点が強化されています。この節では、Sassが提供する2つの重要な機能、_ネスト_と_変数_について説明します。(3つ目の重要な機能である_ミックスイン_については、[7.1.1](/chapters/sign_up?version=5.1#sec-rails_environments)で紹介します。)

[5.1.2](/chapters/filling_in_the_layout?version=5.1#sec-custom_css)でも簡単に説明しましたが、SassはSCSSというフォーマットに対応しています (`.scss`という拡張子はSCSSであることを表します)。SCSSは厳密な意味で、CSS本体を抽象化したフォーマットです。つまり、SCSSはCSSに_新しい機能を追加した_だけで、全く新しい構文を定義したようなものではないということです[15](#cha-5_footnote-15) 。このため、有効なCSSファイルは、すべてSCSSファイルとしても扱うことができ、既存の記法ルールを使っているプロジェクトにとっても互換性のある便利なフォーマットになっています。本書の例では、Bootstrapの恩恵を得るために、私達は最初からSCSSを使っています。Railsのアセットパイプラインは、`.scss`という拡張子を持つファイルをSassを使って自動的に処理してくれます。このため、`custom.scss`ファイルはSassプリプロセッサによって前処理され、その後ブラウザへの配信に備えてパッケージ化されます。

#### [ネスト](#sec-nesting)

スタイルシート内に共通のパターンがある場合は、要素をネストさせることができます。例えば[リスト5.7](/chapters/filling_in_the_layout?version=5.1#code-universal_css)では、次のように`.center`と`.center h1`の両方に対してルールがあります。

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}

上のルールは、Sassを使って次のように書き換えることができます。

.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

上の例では、ネストの内側にある`h1`というルールは、`.center`のルールを継承しています。

今度は、もう少し異なるルールに対してネスト機能を使う例を見てみましょう。[リスト5.9](/chapters/filling_in_the_layout?version=5.1#code-logo_css)には次のコードがあります。

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}

上のコードでは`#logo`というidが2回使われています。1回目はロゴ自身を定義するために、2回目は`hover`属性を定義するために使われています (なお`hover`属性は、該当する要素の上にマウスポインタをかざしたときの表示を定義します)。2つ目のルールをネストするためには、親属性である`#logo`を参照する必要があります。このような場合、SCSSでは次のようにアンパーサンド`&`を使って実現できます。

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  &:hover {
    color: #fff;
    text-decoration: none;
  }
}

Sassは、SCSSをCSSに変換する際に、`&:hover`を`#logo:hover`に置き換えています。

これらのネスト機能は、フッターのCSSでも使えます。[リスト5.17](/chapters/filling_in_the_layout?version=5.1#code-footer_css)のコードは、SCSSを使って次のように書き換えることができます。

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #777;
  a {
    color: #555;
    &:hover {
      color: #222;
    }
  }
  small {
    float: left;
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 15px;
    }
  }
}

[リスト5.17](/chapters/filling_in_the_layout?version=5.1#code-footer_css)を手作業で変換してみることは、良い演習になります (実際に[5.2.2.3](/chapters/filling_in_the_layout?version=5.1#sec-exercises_sass)でも取り入れてみました)。変換後にも、CSSが適切に動作していることを確認してみましょう。

#### [変数](#sec-variables)

Sassでは、冗長なコードを削除し、より自由な表現を可能にするために、_変数_が定義できるようになっています。例えば[リスト5.8](/chapters/filling_in_the_layout?version=5.1#code-typography_css)や[リスト5.17](/chapters/filling_in_the_layout?version=5.1#code-footer_css)を見てみると、同じ色を繰り返し参照している箇所があります。

h2 {
  .
  .
  .
  color: #777;
}
.
.
.
footer {
  .
  .
  .
  color: #777;
}

上のコードの`#777`は薄い灰色を指しています。Sassでは、このような値を変数として定義し、次のように変数名を与えることができます。
```sh
$light-gray: #777;
```
この機能を使って、SCSSを次のように書き直すことができます。
```sh
$light-gray: #777;
```

.
.
h2 {
  .
  .
  .
  color: $light-gray;
}
.
.
.
footer {
  .
  .
  .
  color: $light-gray;
}

`$light-gray`のような変数名は、`#777`のような値よりも分かりやすいので、たとえその変数が繰り返し使われないとしても、変数名を与えることは多くの場合有用です。実際、Bootstrapフレームワークでは、多くの色に対して変数名を定義しています。定義されている変数はBootstrapページの「[LESS変数一覧](http://getbootstrap.com/customize/#less-variables)」で参照することができます。このWebサイトでは、SassではなくLESSを使って変数が定義されていますが、`bootstrap-sass`というgemを使えば、Sassでも同様の変数が使えるようになります。例えばLESSではアットマーク`@`を使っているのに対して、Sassはドルマーク`$`を使っていることはすぐにわかります。話を戻して、Bootstrapの変数の一覧表を見ると、薄い灰色に対して次の変数名が与えられることに気が付きます。

 @gray-light: #777;

これはつまり、`bootstrap-sass`というgemを使えば、SCSSでも同様に`$gray-light`という変数が使えることを意味しています。先ほど定義した`$light-gray`というカスタム変数の代わりに、用意された変数を使ってみましょう。

h2 {
  .
  .
  .
  color: $gray-light;
}
.
.
.
footer {
  .
  .
  .
  color: $gray-light;
}

今回取り上げたSassのネスト機能や変数機能を使ってSCSSファイルを全面的に書き直すと、[リスト5.20](/chapters/filling_in_the_layout?version=5.1#code-refactored_scss)のようになります。このリストでは、Sassの変数 (詳しくはBootstrap LESSの変数一覧を参照) や、組み込みの色変数 (例えば`#fff`には`white`という変数) を使っています。`footer`タグのルールが、劇的に向上していることを確認してみてください。

リスト 5.20: ネストや変数を使って初期のSCSSファイルを書き直した結果 `app/assets/stylesheets/custom.scss`

@import "bootstrap-sprockets";
@import "bootstrap";

/* mixins, variables, etc. */
```sh
$gray-medium-light: #eaeaea;
```
/* universal */

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.2em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: $gray-light;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}


/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: white;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  &:hover {
    color: white;
    text-decoration: none;
  }
}

/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid $gray-medium-light;
  color: $gray-light;
  a {
    color: $gray;
    &:hover {
      color: $gray-darker;
    }
  }
  small {
    float: left;
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 15px;
    }
  }
}

Sassを使ってスタイルシートをより簡単にする方法は他にもありますが、今回はその中でも最も重要な機能を使って[リスト5.20](/chapters/filling_in_the_layout?version=5.1#code-refactored_scss)を書き直しました。Sassを使うことによって、素晴らしいスタートを切ることができました。Sassの詳細については、[Sassの公式サイト](http://sass-lang.com/) (英語) を参照してください。

#### [演習](#sec-exercises_sass)

1.  [5.2.2](/chapters/filling_in_the_layout?version=5.1#sec-sass)で提案したように、footerのCSSを手作業で変換してみましょう。具体的には、[リスト5.17](/chapters/filling_in_the_layout?version=5.1#code-footer_css)の内容を１つずつ変換していき、[リスト5.20](/chapters/filling_in_the_layout?version=5.1#code-refactored_scss)のようにしてみてください。

[5.3 レイアウトのリンク](/chapters/filling_in_the_layout?version=5.1#sec-layout_links)
-----------------------------------------------------------------------------

サイトのレイアウトが美しく仕上がったので、今度は`'#'`で代用していたリンクを書き換えてみましょう。もちろん、次のようにリンクを直接記述することもできます。

<a href="/static_pages/about">About</a>

しかし、上の記法はRails流ではありません。まず、aboutページへのURLは /static_pages/about よりも /about の方がよいでしょう。さらに、Railsでは次のようなコードでは_名前付きルート_を使うのが慣例となっています。

<%= link_to "About", about_path %>

上のようにすることでコードの意味がわかりやすくなり、`about_path`の定義を変えれば`about_path`が使われているすべてのURLを変更できるため、柔軟性が高まります。

今後使う予定のURLとルーティング (route) とのマッピングを、[表5.1](/chapters/filling_in_the_layout?version=5.1#table-url_mapping)に示します。[3.4.4](/chapters/static_pages?version=5.1#sec-setting_the_root_route)で最初のルートは設定済みですが、それ以外のルートについても同様に実装していきます。なお、loginについては本章の最後で少しだけ実装します ([第8章](/chapters/basic_login?version=5.1#cha-basic_login)で本格的に実装します)。

<table><tbody><tr><td><strong>ページ名</strong></td><td><strong>URL</strong></td><td><strong>名前付きルート</strong></td></tr><tr><td>Home</td><td>/</td><td><code>root_path</code></td></tr><tr><td>About</td><td>/about</td><td><code>about_path</code></td></tr><tr><td>Help</td><td>/help</td><td><code>help_path</code></td></tr><tr><td>Contact</td><td>/contact</td><td><code>contact_path</code></td></tr><tr><td>Sign up</td><td>/signup</td><td><code>signup_path</code></td></tr><tr><td>Log in</td><td>/login</td><td><code>login_path</code></td></tr></tbody></table>

表 5.1: サイトリンクのルーティングとURLのマッピング

### [5.3.1 Contactページ](/chapters/filling_in_the_layout?version=5.1#sec-contact_page)

まずは、[第3章](/chapters/static_pages?version=5.1#cha-static_pages)の演習で取り上げたContactページについて追加しましょう。Contactページのテストを[リスト5.21](/chapters/filling_in_the_layout?version=5.1#code-contact_page_test)に示します。これは単に[リスト3.24](/chapters/static_pages?version=5.1#code-title_tests)で使われているテストのパターンに従ったものです。

リスト 5.21: Contactページのテスト **red** `test/controllers/static_pages_controller_test.rb`
```ruby

require 'test_helper'

class StaticPagesControllerTest < ActionDispatch::IntegrationTest

  test "should get home" do
    get static_pages_home_url
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get static_pages_help_url
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get static_pages_about_url
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end

  test "should get contact" do
    get static_pages_contact_url
    assert_response :success
    assert_select "title", "Contact | Ruby on Rails Tutorial Sample App"
  end
end
```

この時点では、[リスト5.21](/chapters/filling_in_the_layout?version=5.1#code-contact_page_test)のテストは **red**になっているはずです。

リスト 5.22: **red**
```sh
$ rails test
```
アプリケーションコードは、[3.3](/chapters/static_pages?version=5.1#sec-getting_started_with_testing)のAboutページへの追加と良く似ています。最初にルート ([リスト5.23](/chapters/filling_in_the_layout?version=5.1#code-contact_route)) を更新します。次に`contact`アクションをStaticPagesコントローラ ([リスト5.24](/chapters/filling_in_the_layout?version=5.1#code-contact_action)) に追加します。最後にContactビュー ([リスト5.25](/chapters/filling_in_the_layout?version=5.1#code-contact_view)) を作成します。

リスト 5.23: Contactページのルートを追加する **red** `config/routes.rb`
```ruby

Rails.application.routes.draw do
  root 'static_pages#home'
  get  'static_pages/home'
  get  'static_pages/help'
  get  'static_pages/about'
  get  'static_pages/contact'
end
```

リスト 5.24: Contactページ用のアクションを追加する **red** `app/controllers/static_pages_controller.rb`
```ruby

class StaticPagesController < ApplicationController
  .
  .
  .
  def contact
  end
end
```

リスト 5.25: Contactページのビューを追加する **green** `app/views/static_pages/contact.html.erb`

<% provide(:title, 'Contact') %>
<h1>Contact</h1>
<p>
  Contact the Ruby on Rails Tutorial about the sample app at the
  <a href="https://railstutorial.jp/contact">contact page</a>.
</p>

ここで、すべてのテストが **green**であることを確認しておいてください。

リスト 5.26: **green**
```sh
$ rails test
```
### [5.3.2 RailsのルートURL](/chapters/filling_in_the_layout?version=5.1#sec-rails_routes)

本項では、名前付きルートをサンプルアプリケーションの静的ページで使うために、ルーティング用のファイル (`config/routes.rb`) を編集していきます。まずは、[3.4.4](/chapters/static_pages?version=5.1#sec-setting_the_root_route)で定義したHomeページのルーティングについて見直していきましょう。あのときは特別にHomeページのみ設定をしましたが、残りの静的ページについても同様にルーティングを設定していきます。

私たちはこれまでに、ルートURLを定義するコードを3回見てきました。1つ目は、

root 'application#hello'

というHelloアプリケーションのコード ([リスト1.9](/chapters/beginning?version=5.1#code-hello_root_route))です。2つ目は、

root 'users#index'

というToyアプリケーションのコード ([リスト2.6](/chapters/toy_app?version=5.1#code-rails_routes_root_route))。そして最後は、

root 'static_pages#home'

というSampleアプリケーションのコードです ([リスト3.41](/chapters/static_pages?version=5.1#code-home_root_route))。いずれの場合においても、`root`メソッドを使ってルートURL "/" をコントローラーのアクションに紐付けていました。ルートURLのようなルーティングを定義することの効果は、ブラウザからアクセスしやすくすることだけではありません。それ以外にも、生のURLではなく、名前付きルートを使ってURLを参照することができるようになります。例えばルートURLを定義すると、`root_path`や`root_url`といったメソッドを通してURLを参照することができます。ちなみに前者はルートURL以下の文字列を、後者は完全なURLの文字列を返します。

root_path -> '/'
root_url  -> 'http://www.example.com/'

なお、Railsチュートリアルでは一般的な規約に従い、基本的には`_path`書式を使い、リダイレクトの場合のみ`_url`書式を使うようにします。これはHTTPの標準としては、リダイレクトのときに完全なURLが要求されるためです。ただしほとんどのブラウザでは、どちらの方法でも動作します。

[リスト5.21](/chapters/filling_in_the_layout?version=5.1#code-contact_page_test)などで使われたデフォルトのルーティングはやや回りくどいので、HelpページやAboutページ、Contactページなどの名前付きルートを定義していきましょう。具体的には、`get`ルールを使って定義していきます ([リスト5.23](/chapters/filling_in_the_layout?version=5.1#code-contact_route))。例えば次のようなルーティングは、

get 'static_pages/help'

このように変換します。

get  '/help', to: 'static_pages#help'

このようにgetルールを使って変更すると、`GET`リクエストが /help に送信されたときにStaticPagesコントローラーの`help`アクションを呼び出してくれるようになります。また、ルートURLのときと同様に、`help_path`や`help_url`といった名前付きルートも使えるようになります。

help_path -> '/help'
help_url  -> 'http://www.example.com/help'

他の静的ページについても同様にルーティングを変更していくと、[リスト5.23](/chapters/filling_in_the_layout?version=5.1#code-contact_route)は[リスト5.27](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes)のようなコードになります。

リスト 5.27: 静的なページのルーティング一覧 **red** `config/routes.rb`
```ruby

Rails.application.routes.draw do
  root 'static_pages#home'
  get  '/help',    to: 'static_pages#help'
  get  '/about',   to: 'static_pages#about'
  get  '/contact', to: 'static_pages#contact'
end
```

なお、[リスト5.27](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes)では`'static_pages/home'`という以前のルールを削除している点に注意してください。今後は常に`root_path`または`root_url`を使っていきます。

さらに、[リスト5.21](/chapters/filling_in_the_layout?version=5.1#code-contact_page_test)のテストも古くなったので、変更する必要があります。実際、現時点のテストは **red**になっているはずです。もう一度 **green** の状態に戻すには、次の[リスト5.28](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes_test)のように修正していく必要があります。このとき、先ほどのルーティングの変更で名前付きルート (`*_path`) が使えるようになったので、早速テストの修正で使っている点に注意してください。

リスト 5.28: StaticPagesで扱う新しい名前付きルートに対するテスト **green** `test/controllers/static_pages_controller_test.rb`
```ruby

require 'test_helper'

class StaticPagesControllerTest < ActionDispatch::IntegrationTest

  test "should get home" do
    get root_path
    assert_response :success
    assert_select "title", "Ruby on Rails Tutorial Sample App"
  end

  test "should get help" do
    get help_path
    assert_response :success
    assert_select "title", "Help | Ruby on Rails Tutorial Sample App"
  end

  test "should get about" do
    get about_path
    assert_response :success
    assert_select "title", "About | Ruby on Rails Tutorial Sample App"
  end

  test "should get contact" do
    get contact_path
    assert_response :success
    assert_select "title", "Contact | Ruby on Rails Tutorial Sample App"
  end
end
```

#### [演習](#sec-exercises_rails_routes)

1.  実は名前付きルートは、`as:`オプションを使って変更することができます。[有名な_Far Side_の漫画](https://www.google.com/search?q=far+side+helf)に倣って、Helpページの名前付きルートを`helf`に変更してみてください ([リスト5.29](/chapters/filling_in_the_layout?version=5.1#code-helf))。
2.  先ほどの変更により、テストが **red**になっていることを確認してください。[リスト5.28](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes_test)を参考にルーティングを更新して、テストを **green**にして見てください。
3.  エディタのUndo機能を使って、今回の演習で行った変更を元に戻して見てください。

リスト 5.29: helpをhelfに変更する `config/routes.rb`
```ruby

Rails.application.routes.draw do
  root 'static_pages#home'
  get  '/help',    to: 'static_pages#help', as: 'helf'
  get  '/about',   to: 'static_pages#about'
  get  '/contact', to: 'static_pages#contact'
end
```

### [5.3.3 名前付きルート](/chapters/filling_in_the_layout?version=5.1#sec-named_routes)

[リスト5.27](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes)でルートを定義したことにより、レイアウトの中で名前付きルートが使えるようになりました。早速、`link_to`メソッドの2番目の引数で、適切な名前付きルートを使ってみましょう。例えば次のコードの場合、

<%= link_to "About", '#' %>

このように置き換えます。

<%= link_to "About", about_path %>

他も同様です。

最初に、HomeページとHelpページへのリンクを持つheaderパーシャル `_header.html.erb` ([リスト5.30](/chapters/filling_in_the_layout?version=5.1#code-header_partial_links)) から取り掛かります。headerパーシャルでは、Web共通の慣習に従って、ロゴにもHomeページへのリンクを追加します。

リスト 5.30: headerパーシャルにリンクを追加する `app/views/layouts/_header.html.erb`

<header class="navbar navbar-fixed-top navbar-inverse">
  <div class="container">
    <%= link_to "sample app", root_path, id: "logo" %>
    <nav>
      <ul class="nav navbar-nav navbar-right">
        <li><%= link_to "Home",    root_path %></li>
        <li><%= link_to "Help",    help_path %></li>
        <li><%= link_to "Log in", '#' %></li>
      </ul>
    </nav>
  </div>
</header>

[Log in] リンクの名前付きルートは[第8章](/chapters/basic_login?version=5.1#cha-basic_login)で作成するため、今の段階では`'#'`のままにしておきます。

footerパーシャル `_footer.html.erb` にもリンクがあります。これらはAboutページとContactページへのリンクです ([リスト5.31](/chapters/filling_in_the_layout?version=5.1#code-footer_partial_links))。

リスト 5.31: footerパーシャルにリンクを追加する `app/views/layouts/_footer.html.erb`

<footer class="footer">
  <small>
    The <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    by <a href="http://www.michaelhartl.com/">Michael Hartl</a>
  </small>
  <nav>
    <ul>
      <li><%= link_to "About",   about_path %></li>
      <li><%= link_to "Contact", contact_path %></li>
      <li><a href="http://news.railstutorial.org/">News</a></li>
    </ul>
  </nav>
</footer>

これで、レイアウトに[第3章](/chapters/static_pages?version=5.1#cha-static_pages)で作成したすべての静的ページへのリンクができました。例えば /about の場合はAboutページ ([図5.10](/chapters/filling_in_the_layout?version=5.1#fig-about_page)) に移動します。

図 5.10: /about で表示されるAboutページ

#### [演習](#sec-exercises_named_routes)

1.  [リスト5.29](/chapters/filling_in_the_layout?version=5.1#code-helf)のように`helf`ルーティングを作成し、レイアウトのリンクを更新してみてください。
2.  前回の演習と同様に、エディタのUndo機能を使ってこの演習で行った変更を元に戻してみてください。

### [5.3.4 リンクのテスト](/chapters/filling_in_the_layout?version=5.1#sec-layout_link_tests)

レイアウト内のいくつかのリンクを埋めることができたので、これらのリンクが正しく動いているかどうかチェックするテストを書いてみましょう。ブラウザを立ち上げてルートURLにアクセスし、それぞれのリンクをクリックして確かめることもできますが、変更する度にこの作業を毎回繰り返していくのは大きな負担です。そこで、「統合テスト _(Integration Test)_」を使って一連の作業を自動化してみましょう。統合テストを使うと、アプリケーションの動作を端から端まで (end-to-end) シミュレートしてテストすることができます。まずは、`site_layout`というテストのテンプレートを生成するところから始めてみます。
```sh
$ rails generate integration_test site_layout
```
     invoke  test_unit
      create    test/integration/site_layout_test.rb

このとき、Railsは渡されたファイル名の末尾に `_test` という文字列を追加することに注目してください。

今回の目的は、アプリケーションのHTML構造を調べて、レイアウトの各リンクが正しく動くかどうかチェックすることです。つまり、

1.  ルートURL (Homeページ) にGETリクエストを送る.
2.  正しいページテンプレートが描画されているかどうか確かめる.
3.  Home、Help、About、Contactの各ページへのリンクが正しく動くか確かめる.

Railsの統合テストでは、上のステップをコードに落とし込んでいくことになります ([リスト5.32](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test))。具体的には、まず`assert_template`メソッドを使って、Homeページが正しいビューを描画しているかどうか確かめます[16](#cha-5_footnote-16) 。

リスト 5.32: レイアウトのリンクに対するテスト **green** `test/integration/site_layout_test.rb`
```ruby

require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest

  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
  end
end
```

[リスト5.32](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test)では、`assert_select`メソッドの高度なオプションを使っています (このメソッド自体は[リスト3.24](/chapters/static_pages?version=5.1#code-title_tests)や[リスト5.21](/chapters/filling_in_the_layout?version=5.1#code-contact_page_test)でも登場しました)。今回のケースでは、特定のリンクが存在するかどうかを、`a`タグと`href`属性をオプションで指定して調べています。例えば、

assert_select "a[href=?]", about_path

上のコードでは、Railsは自動的にはてなマーク "?" を`about_path`に置換しています (このとき "about_path" 内に特殊記号があればエスケープ処理されます)。これにより、次のようなHTMLがあるかどうかをチェックすることができます。

<a href="/about">...</a>

一方で、ルートURLへのリンクは_2つ_あることを思い出してください (1つはロゴに、もう1つはナビゲーションバーにあります)。このようなとき、

assert_select "a[href=?]", root_path, count: 2

といった風に書くことで、[リスト5.30](/chapters/filling_in_the_layout?version=5.1#code-header_partial_links)で定義したHomeページのリンクの個数も調べることもできます

`assert_select`には色々な指定の仕方があります。その代表例をいくつか[表5.2](/chapters/filling_in_the_layout?version=5.1#table-assert_select)で紹介します。`assert_select`は柔軟でパワフルな機能で、ここでは紹介し切れないほど他にも多くのオプションがあります。しかし経験的には、このメソッドで複雑なテストはしない方が賢明です。今回のようなレイアウト内で頻繁に変更されるHTML要素 (リンクなど) をテストするぐらいに抑えておくとよいです。

<table><tbody><tr><td><strong>Code</strong></td><td><strong>マッチするHTML</strong></td></tr><tr><td><code>assert_select "div"</code></td><td><code>&lt;div&gt;foobar&lt;/div&gt;</code></td></tr><tr><td><code>assert_select "div", "foobar"</code></td><td><code>&lt;div&gt;foobar&lt;/div&gt;</code></td></tr><tr><td><code>assert_select "div.nav"</code></td><td><code>&lt;div class="nav"&gt;foobar&lt;/div&gt;</code></td></tr><tr><td><code>assert_select "div#profile"</code></td><td><code>&lt;div id="profile"&gt;foobar&lt;/div&gt;</code></td></tr><tr><td><code>assert_select "div[name=yo]"</code></td><td><code>&lt;div name="yo"&gt;hey&lt;/div&gt;</code></td></tr><tr><td><code>assert_select "a[href=?]", '/', count: 1</code></td><td><code>&lt;a href="/"&gt;foo&lt;/a&gt;</code></td></tr><tr><td><code>assert_select "a[href=?]", '/', text: "foo"</code></td><td><code>&lt;a href="/"&gt;foo&lt;/a&gt;</code></td></tr></tbody></table>

表 5.2: `assert_select`のいくつかの使用例

[リスト5.32](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test)で追加した統合テストが通るかどうかは、次のようにRakeタスクを実行することで試すことができます。

リスト 5.33: **green**
```sh
$ rails test:integration
```
統合テストが成功したら、今度はすべてのテストを流して **green**するかどうか確かめてみてください。

リスト 5.34: **green**
```sh
$ rails test
```
レイアウトのリンクをテストする統合テストが追加されたことで、リンクに間違った変更が加えられたらすぐに気付けるようになりました。

#### [演習](#sec-exercises_layout_link_tests)

1.  footerパーシャルの`about_path`を`contact_path`に変更してみて、テストが正しくエラーを捕まえてくれるかどうか確認してみてください。
2.  [リスト5.35](/chapters/filling_in_the_layout?version=5.1#code-test_helper_application_helper)で示すように、Applicationヘルパーで使っている`full_title`ヘルパーを、test環境でも使えるようにすると便利です。こうしておくと、[リスト5.36](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test_signup_full_title_helper)のようなコードを使って、正しいタイトルをテストすることができます。ただし、これは完璧なテストではありません。例えばベースタイトルに「Ruby on Rails Tutoial」といった誤字があったとしても、このテストでは発見することができないでしょう。この問題を解決するためには、`full_title`ヘルパーに対するテストを書く必要があります。そこで、Applicationヘルパーをテストするファイルを作成し、[リスト5.37](/chapters/filling_in_the_layout?version=5.1#code-full_title_helper_tests)の`FILL_IN`の部分を適切なコードに置き換えてみてください。_ヒント_: [リスト5.37](/chapters/filling_in_the_layout?version=5.1#code-full_title_helper_tests)では`assert_equal <期待される値>, <実際の値>`といった形で使っていましたが、内部では`==`演算子で期待される値と実際の値を比較し、正しいかどうかのテストをしています。

リスト 5.35: test環境でもApplicationヘルパーを使えるようにする `test/test_helper.rb`
```ruby

ENV['RAILS_ENV'] ||= 'test'
.
.
.
class ActiveSupport::TestCase
  fixtures :all
  include ApplicationHelper
  .
  .
  .
end
```

リスト 5.36: test環境で`full_title`ヘルパーを使う **green** `test/integration/site_layout_test.rb`
```ruby

require 'test_helper'

class SiteLayoutTest < ActionDispatch::IntegrationTest

  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
    get contact_path
    assert_select "title", full_title("Contact")
  end
end
```

リスト 5.37: `full_title`ヘルパーの単体テスト `test/helpers/application_helper_test.rb`
```ruby

require 'test_helper'

class ApplicationHelperTest < ActionView::TestCase
  test "full title helper" do
    assert_equal full_title,         FILL_IN
    assert_equal full_title("Help"), FILL_IN
  end
end
```

[5.4 ユーザー登録: 最初のステップ](/chapters/filling_in_the_layout?version=5.1#sec-user_signup)
----------------------------------------------------------------------------------

この節では、レイアウトとルーティングの取り組みにおける頂点として、ユーザー登録ページへのルーティングを作成します。そのために2番目のコントローラを作成することになります。これは、Webサイトでユーザー登録を行えるようにするための最初の重要な一歩となります。次の一歩であるユーザーのモデリングは[第6章](/chapters/modeling_users?version=5.1#cha-modeling_users)で行い、[第7章](/chapters/sign_up?version=5.1#cha-sign_up)でユーザー登録が完成します。

### [5.4.1 Usersコントローラ](/chapters/filling_in_the_layout?version=5.1#sec-users_controller)

[3.2](/chapters/static_pages?version=5.1#sec-static_pages)で、最初のコントローラであるStaticPagesコントローラを作成しました。今度は2番目のコントローラであるUsersコントローラを作成しましょう。以前のときと同様に、`generate`を実行して、現時点での要求である新規ユーザー用のユーザー登録ページ (スタブ) を持つ、最も簡単なコントローラを作成します。Railsで好まれている[RESTアーキテクチャ](http://ja.wikipedia.org/wiki/Representational_State_Transfer)の規約に従い、新規ユーザー用のアクションを`new`とします。したがって、`generate controller`の引数に`new`を渡して、自動的にアクションを作成してみましょう。変更の結果を[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)に示します。

リスト 5.38: Usersコントローラの生成 (`new`アクションを追加)
```sh
$ rails generate controller Users new
```
     create  app/controllers/users_controller.rb
       route  get 'users/new'
      invoke  erb
      create    app/views/users
      create    app/views/users/new.html.erb
      invoke  test_unit
      create    test/controllers/users_controller_test.rb
      invoke  helper
      create    app/helpers/users_helper.rb
      invoke    test_unit
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/users.coffee
      invoke    scss
      create      app/assets/stylesheets/users.scss

[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)により、`new`アクションを持つUsersコントローラ([リスト5.39](/chapters/filling_in_the_layout?version=5.1#code-initial_users_controller))と、スタブのユーザービューを作成します([リスト5.40](/chapters/filling_in_the_layout?version=5.1#code-initial_new_action))。このとき、新しいUserページ用の小さなテスト ([リスト5.41](/chapters/filling_in_the_layout?version=5.1#code-user_new_test)) も生成されていて、この時点ではパスするはずです。

リスト 5.39: `new`アクションを持つ最初のUsersコントローラ `app/controllers/users_controller.rb`
```ruby

class UsersController < ApplicationController

  def new
  end
end
```

リスト 5.40: Users用の最初の`new`アクション `app/views/users/new.html.erb`

<h1>Users#new</h1>
<p>Find me in app/views/users/new.html.erb</p>

リスト 5.41: Userページ用の最初のテスト **green** `test/controllers/users_controller_test.rb`
```ruby

require 'test_helper'

class UsersControllerTest < ActionDispatch::IntegrationTest

  test "should get new" do
    get users_new_url
    assert_response :success
  end
end
```

この時点では、テストは **green**になっているはずです。

リスト 5.42: **green**
```sh
$ rails test
```
#### [演習](#sec-exercises_users_controller)

1.  [表5.1](/chapters/filling_in_the_layout?version=5.1#table-url_mapping)を参考にしながら[リスト5.41](/chapters/filling_in_the_layout?version=5.1#code-user_new_test)を変更し、`users_new_url`ではなく`signup_path`を使えるようにしてみてください。
2.  先ほどの変更を加えたことにより、テストが **red**になったことを確認してください。なお、この演習はテスト駆動開発 ([コラム3.3](/chapters/static_pages?version=5.1#aside-when_to_test)) で説明した **red**/**green** のリズムを作ることを目的としています。このテストは次の[5.4.2](/chapters/filling_in_the_layout?version=5.1#sec-signup_url)で **green**になるよう修正します。

### [5.4.2 ユーザー登録用URL](/chapters/filling_in_the_layout?version=5.1#sec-signup_url)

[5.4.1](/chapters/filling_in_the_layout?version=5.1#sec-users_controller)のコードにより、新規ユーザー用の動作するページが/users/new にできました。ここで[表5.1](/chapters/filling_in_the_layout?version=5.1#table-url_mapping)を思い出していただきたいのですが、URLは/users/newではなく表のとおりに/signupにしたいと思います。[リスト5.27](/chapters/filling_in_the_layout?version=5.1#code-static_page_routes)の例に従い、ユーザー登録URL用に`get '/signup'`のルートを追加します ([リスト5.43](/chapters/filling_in_the_layout?version=5.1#code-signup_route))。

リスト 5.43: ユーザー登録ページのルート **red** `config/routes.rb`
```ruby

Rails.application.routes.draw do
  root 'static_pages#home'
  get  '/help',    to: 'static_pages#help'
  get  '/about',   to: 'static_pages#about'
  get  '/contact', to: 'static_pages#contact'
  get  '/signup',  to: 'users#new'
end
```

[リスト5.43](/chapters/filling_in_the_layout?version=5.1#code-signup_route)の変更に合わせて、[リスト5.38](/chapters/filling_in_the_layout?version=5.1#code-generate_users_controller)で生成されたテストも修正していきましょう。修正した結果を[リスト5.44](/chapters/filling_in_the_layout?version=5.1#code-users_controller_test_signup_route)に示します。

リスト 5.44: Usersコントローラのテストで名前付きルートを使うようにする **green** `test/controllers/users_controller_test.rb`
```ruby

require 'test_helper'

class UsersControllerTest < ActionDispatch::IntegrationTest

  test "should get new" do
    get signup_path
    assert_response :success
  end
end
```

次に、新しく定義された名前付きルートを使って、Homeページのボタンに適切なリンクを追加します。他のルートと同様、`get ’/signup’`と記述したことで`signup_path`という名前付きルートができ、それを[リスト5.45](/chapters/filling_in_the_layout?version=5.1#code-home_page_signup_link)で使います。なお、signupページへのテストは演習に回すことにします ([5.3.2.1](/chapters/filling_in_the_layout?version=5.1#sec-exercises_rails_routes))。

リスト 5.45: ボタンにユーザー登録ページへのリンクを追加する `app/views/static_pages/home.html.erb`

<div class="center jumbotron">
  <h1>Welcome to the Sample App</h1>

  <h2>
    This is the home page for the
    <a href="https://railstutorial.jp/">Ruby on Rails Tutorial</a>
    sample application.
  </h2>

  <%= link_to "Sign up now!", signup_path, class: "btn btn-lg btn-primary" %>
</div>

<%= link_to image_tag("rails.png", alt: "Rails logo"),
            'http://rubyonrails.org/' %>

最後に、signupページ用のカスタムスタブ (stub) のビューを追加します ([5.46](/chapters/filling_in_the_layout?version=5.1#code-initial_signup_page))。

リスト 5.46: 最初のユーザー登録ページ (スタブ) `app/views/users/new.html.erb`

<% provide(:title, 'Sign up') %>
<h1>Sign up</h1>
<p>This will be a signup page for new users.</p>

これで、少なくともサインインのルートを追加するまでの間、リンクと名前付きルートが完成しました ([第8章](/chapters/basic_login?version=5.1#cha-basic_login))。結果を[図5.11](/chapters/filling_in_the_layout?version=5.1#fig-new_signup_page)の新規ユーザーのページ (URI /signup) に示します。

図 5.11: 新しいユーザー登録ページ (/signup)

#### [演習](#sec-exercises_signup_url)

1.  もしまだ[5.4.1.1](/chapters/filling_in_the_layout?version=5.1#sec-exercises_users_controller)の演習に取り掛かっていなければ、まずは[リスト5.41](/chapters/filling_in_the_layout?version=5.1#code-user_new_test)のように変更し、名前付きルート`signup_path`を使えるようにしてください。また、[リスト5.43](/chapters/filling_in_the_layout?version=5.1#code-signup_route)で名前付きルートが使えるようになったので、現時点でテストが **green**になっていることを確認してください。
2.  先ほどのテストが正しく動いていることを確認するため、`signup`ルートの部分をコメントアウトし、テスト **red**になることを確認してください。確認できたら、コメントアウトを解除して **green**の状態に戻してください。
3.  [リスト5.32](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test)の統合テストにsignupページにアクセスするコードを追加してください (`get`メソッドを使います)。コードを追加したら実際にテストを実行し、結果が正しいことを確認してください。_ヒント_: [リスト5.36](/chapters/filling_in_the_layout?version=5.1#code-layout_links_test_signup_full_title_helper)で紹介した`full_title`ヘルパーを使ってみてください。

[5.5 最後に](/chapters/filling_in_the_layout?version=5.1#sec-layout_conclusion)
----------------------------------------------------------------------------

この章では、アプリケーションのレイアウトを形にし、ルーティングを洗練させました。本書では、以後サンプルアプリケーションを肉付けすることに専念します。最初に、ユーザー登録、サインイン、サインアウトできるユーザーを追加します。次に、マイクロポストを追加します。最後に、他のユーザーをフォローできるようにします。

Gitを使っている方は、この時点でmasterブランチに変更をマージしてください。

```sh
$ git add -A
$ git commit -m "Finish layout and routes"
$ git checkout maste
$ git merge filling-in-layout
```
続いて、テストスイートを実行して **green**になるか確認し、問題なければBitbucketにプッシュします。

$ rails tes
$ git push
```
最後に、Herokuへデプロイします。
```sh
$ git push heroku
```
デプロイが無事に終わると、本番環境でサンプルアプリケーションが動いているはずです ([図5.12](/chapters/filling_in_the_layout?version=5.1#fig-layout_production))。

図 5.12: 本番環境で動くサンプルアプリケーション

### [5.5.1 本章のまとめ](/chapters/filling_in_the_layout?version=5.1#sec-filling_in_the_layout_what_we_learned_in_this_chapter)

*   HTML5を使ってheaderやfooter、logoやbodyといったコンテンツのレイアウトを定義しました
*   Railsのパーシャルは効率化のために使われ、別ファイルにマークアップを切り出すことができます
*   CSSは、CSSクラスとidを使ってレイアウトやデザインを調整します
*   Bootstrapフレームワークを使うと、いい感じのデザインを素早く実装できる
*   SassとAsset Pipelineは、(開発効率のために切り分けられた) CSSの冗長な部分を圧縮し、本番環境に最適化した結果を出力する
*   Railsのルーティングでは自由にルールを定義することができ、また、その際に名前付きルートも使えるようになる
*   統合テストは、ブラウザによるページ間の遷移を効率的にシミュレートする

#### ここまでの進捗をTwitterに投稿しませんか？

[  
#Railsチュートリアル の第5章を走破しました！ https://railstutorial.jp/ @RailsTutorialJP](https://twitter.com/intent/tweet?text=%23Railsチュートリアル%20の第5章を走破しました！%20https%3A%2F%2Frailstutorial.jp%2F%20%40RailsTutorialJP&source=webclient)[](https://railstutorial.jp/trial)[](https://railstutorial.jp/#text)

[«前の章](rails_flavored_ruby?version=5.1#cha-rails_flavored_ruby) [次の章»](modeling_users?version=5.1#cha-modeling_users)

[1.](#cha-5_footnote-ref-1) [Colm Tuite](https://twitter.com/colmtuite)の多大な貢献により、サンプルアプリケーションをBootstrap CSSのフレームワークに変換することができました。感謝します。

[2.](#cha-5_footnote-ref-2) Railsチュートリアルのモックアップは、「[Mockingbird](http://gomockingbird.com)」という素晴らしいモックアップ作成サービスで作られています。

[3.](#cha-5_footnote-ref-3) _shim_と_shiv_という単語は、今回の用途ではどちらでも大丈夫です。shimの意味は「洗う機械、もしくは薄い物質を整理しフィットさせるためのモノ、あるいは服を削除すること」なので、意味合いとしては前者が正しいです。ちなみに後者は「ナイフ、もしくは武器として使う剃刀」という意味なので、おそらく原著者である Sjoerd Visscherのちょっとしたイタズラ心でしょう。

[4.](#cha-5_footnote-ref-4) CSSクラスは、Rubyのクラスとはまったく関係がありません。

[5.](#cha-5_footnote-ref-5) スペースを入れると見栄えが変わるかもしれませんが、[3.4.1](/chapters/static_pages?version=5.1#sec-testing_titles)で触れたようにHTMLは重複する空白を無視するのでどちらでも大丈夫です。

[6.](#cha-5_footnote-ref-6) このロゴ画像は実はちょっと古いロゴです。ただ最新のロゴは拡張可能なベクター画像 (SVG) になっていて、やや扱いには手間がかかります。今回はサッと済ませてしまいたいので古いロゴ画像を使っています。

[7.](#cha-5_footnote-ref-7) 既にお気づきだと思いますが、`img`タグは`<img>...</img>`と書いても良いのですが、一般的には`<img ... />`と書きます。このような書式のタグを_閉じタグ_と呼びます。

[8.](#cha-5_footnote-ref-8) 画像の引用元とライセンス: https://www.flickr.com/photos/deborah_s_perspective/14144861329 on 2016-01-09. Copyright © 2009 by [Deborah](https://www.flickr.com/photos/deborah_s_perspective/) (改変不可の [Creative Commons Attribution 2.0 Generic](https://creativecommons.org/licenses/by/2.0/) ライセンス)

[9.](#cha-5_footnote-ref-9) これまでと同様に、Gemfileで指定した各gemのバージョンは[gemfiles-4th-ed.railstutorial.org](http://gemfiles-4th-ed.railstutorial.org/)と一致している必要があります。もしうまく次に進めない場合はチェックしてみてください。

[10.](#cha-5_footnote-ref-10) Asset PipelineではLessを使うこともできます。詳しくは[`less-rails-bootstrap` gem](http://rubygems.org/gems/less-rails-bootstrap)を参照してください。

[11.](#cha-5_footnote-ref-11) もしこのステップが摩訶不思議に思えたら、次のように考えてみましょう。「私はただ[bootstrap-sassのREADMEファイル](https://github.com/twbs/bootstrap-sass#bootstrap-for-sass---)に従っているのだ」と。

[12.](#cha-5_footnote-ref-12) 多くのRails開発者は、異なるビューの間で共通して使うパーシャル用のディレクトリとして、`shared`ディレクトリをよく使います。著者は、複数のビューで共有するユーティリティパーシャルについては`shared`フォルダに保存し、文字どおり全ページ (サイトレイアウトの一部として) 共通のパーシャルについては`layouts`ディレクトリへ保存することを好んでいます (`shared`ディレクトリは[第7章](/chapters/sign_up?version=5.1#cha-sign_up)で作成します)。著者はこのように分割保存するのが論理的であると考えますが、`shared`フォルダにすべて保存しても問題なく動作します。

[13.](#cha-5_footnote-ref-13) `footer`タグと`.footer`クラスを両方使っていることに疑問に思う方がいるかもしれません。その理由は、footerタグとする方が読み手にとって意味が明確であるのと、.footerクラスはBootstrapで使うためです。`footer`を`div`に置き換えても動作は変わりません。

[14.](#cha-5_footnote-ref-14) このチュートリアル構成は、Michael Erasmusによる素晴らしいブログ記事「5分でわかるRails 3のAsset Pipeline (英語)」をもとにしています。詳細についてはRailsガイドの「[アセットパイプライン](http://railsguides.jp/asset_pipeline.html)」の項を参照してください。

[15.](#cha-5_footnote-ref-15) Sassはもう１つの全く新しい文法もサポートしています。この文法は冗長性が少ない (カッコが少ない) 新しい言語と言えるのですが、ただ既存のプロジェクトには若干不便であり、既にCSSに慣れ親しんだ人にとっては学習が面倒でもあります。

[16.](#cha-5_footnote-ref-16) 何人かの開発者は「1つのテストに複数のアサーションを入れるべきではない」と強く主張するでしょう。この演習は不必要に複雑で、もし各テストの直前に共通のセットアップ用タスクがあれば、たしかに不要な負荷がかかることでしょう。しかし、よく書かれたテストは一貫したストーリーのようになり、人間にとって理解しやすいです。ストーリーを独立した場面ごとに分割されてしまうと、物語調ではなくなってしまいます。このことから、複数のアサーションを1つのテストにまとめるようにして、(minitestを通して) Rubyにどのセリフで間違ったのかを話させるようにしています。
